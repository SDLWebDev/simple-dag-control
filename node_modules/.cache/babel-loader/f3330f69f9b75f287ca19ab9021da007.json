{"ast":null,"code":"/*! JointJS v2.2.1 (2018-11-12) - JavaScript diagramming library\n\n\nThis Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.\n*/\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // For AMD.\n    define(['backbone', 'lodash', 'jquery'], function (Backbone, _, $) {\n      Backbone.$ = $;\n      return factory(root, Backbone, _, $);\n    });\n  } else if (typeof exports !== 'undefined') {\n    // For Node.js or CommonJS.\n    var Backbone = require('backbone');\n\n    var _ = require('lodash');\n\n    var $ = Backbone.$ = require('jquery');\n\n    module.exports = factory(root, Backbone, _, $);\n  } else {\n    // As a browser global.\n    var Backbone = root.Backbone;\n    var _ = root._;\n    var $ = Backbone.$ = root.jQuery || root.$;\n    root.joint = factory(root, Backbone, _, $);\n    root.g = root.joint.g;\n    root.V = root.Vectorizer = root.joint.V;\n  }\n})(this, function (root, Backbone, _, $) {\n  !function () {\n    var t = \"undefined\" != typeof exports ? exports : this,\n        f = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n    function u(t) {\n      this.message = t;\n    }\n\n    (u.prototype = new Error()).name = \"InvalidCharacterError\", t.btoa || (t.btoa = function (t) {\n      for (var r, e, n = String(t), o = 0, i = f, a = \"\"; n.charAt(0 | o) || (i = \"=\", o % 1); a += i.charAt(63 & r >> 8 - o % 1 * 8)) {\n        if (255 < (e = n.charCodeAt(o += .75))) throw new u(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n        r = r << 8 | e;\n      }\n\n      return a;\n    }), t.atob || (t.atob = function (t) {\n      var r = String(t).replace(/=+$/, \"\");\n      if (r.length % 4 == 1) throw new u(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n\n      for (var e, n, o = 0, i = 0, a = \"\"; n = r.charAt(i++); ~n && (e = o % 4 ? 64 * e + n : n, o++ % 4) ? a += String.fromCharCode(255 & e >> (-2 * o & 6)) : 0) {\n        n = f.indexOf(n);\n      }\n\n      return a;\n    });\n  }(), function () {\n    function n(t, r) {\n      return this.slice(t, r);\n    }\n\n    function o(t, r) {\n      arguments.length < 2 && (r = 0);\n\n      for (var e = 0, n = t.length; e < n; ++e, ++r) {\n        this[r] = 255 & t[e];\n      }\n    }\n\n    function t(t) {\n      var r;\n\n      if (\"number\" == typeof t) {\n        r = new Array(t);\n\n        for (var e = 0; e < t; ++e) {\n          r[e] = 0;\n        }\n      } else r = t.slice(0);\n\n      return r.subarray = n, (r.buffer = r).byteLength = r.length, r.set = o, \"object\" == typeof t && t.buffer && (r.buffer = t.buffer), r;\n    }\n\n    \"undefined\" == typeof Uint8Array && \"undefined\" != typeof window && (window.Uint8Array = t, window.Uint32Array = t, window.Int32Array = t);\n  }(), \"undefined\" != typeof XMLHttpRequest && (\"response\" in XMLHttpRequest.prototype || \"mozResponseArrayBuffer\" in XMLHttpRequest.prototype || \"mozResponse\" in XMLHttpRequest.prototype || \"responseArrayBuffer\" in XMLHttpRequest.prototype || Object.defineProperty(XMLHttpRequest.prototype, \"response\", {\n    get: function get() {\n      return new Uint8Array(new VBArray(this.responseBody).toArray());\n    }\n  })), Array.prototype.includes || Object.defineProperty(Array.prototype, \"includes\", {\n    value: function value(t, r) {\n      if (null == this) throw new TypeError('\"this\" is null or not defined');\n      var e = Object(this),\n          n = e.length >>> 0;\n      if (0 === n) return !1;\n      var o,\n          i,\n          a = 0 | r,\n          f = Math.max(0 <= a ? a : n - Math.abs(a), 0);\n\n      for (; f < n;) {\n        if ((o = e[f]) === (i = t) || \"number\" == typeof o && \"number\" == typeof i && isNaN(o) && isNaN(i)) return !0;\n        f++;\n      }\n\n      return !1;\n    }\n  }), Array.prototype.find || Object.defineProperty(Array.prototype, \"find\", {\n    value: function value(t) {\n      if (null == this) throw new TypeError('\"this\" is null or not defined');\n      var r = Object(this),\n          e = r.length >>> 0;\n      if (\"function\" != typeof t) throw new TypeError(\"predicate must be a function\");\n\n      for (var n = arguments[1], o = 0; o < e;) {\n        var i = r[o];\n        if (t.call(n, i, o, r)) return i;\n        o++;\n      }\n    }\n  }), Array.from || (Array.from = function () {\n    var r = Object.prototype.toString,\n        u = function u(t) {\n      return \"function\" == typeof t || \"[object Function]\" === r.call(t);\n    },\n        n = Math.pow(2, 53) - 1,\n        s = function s(t) {\n      var r,\n          e = (r = Number(t), isNaN(r) ? 0 : 0 !== r && isFinite(r) ? (0 < r ? 1 : -1) * Math.floor(Math.abs(r)) : r);\n      return Math.min(Math.max(e, 0), n);\n    };\n\n    return function (t) {\n      var r = Object(t);\n      if (null == t) throw new TypeError(\"Array.from requires an array-like object - not null or undefined\");\n      var e,\n          n = 1 < arguments.length ? arguments[1] : void 0;\n\n      if (void 0 !== n) {\n        if (!u(n)) throw new TypeError(\"Array.from: when provided, the second argument must be a function\");\n        2 < arguments.length && (e = arguments[2]);\n      }\n\n      for (var o, i = s(r.length), a = u(this) ? Object(new this(i)) : new Array(i), f = 0; f < i;) {\n        o = r[f], a[f] = n ? void 0 === e ? n(o, f) : n.call(e, o, f) : o, f += 1;\n      }\n\n      return a.length = i, a;\n    };\n  }()), Array.prototype.findIndex || Object.defineProperty(Array.prototype, \"findIndex\", {\n    value: function value(t) {\n      if (null == this) throw new TypeError('\"this\" is null or not defined');\n      var r = Object(this),\n          e = r.length >>> 0;\n      if (\"function\" != typeof t) throw new TypeError(\"predicate must be a function\");\n\n      for (var n = arguments[1], o = 0; o < e;) {\n        var i = r[o];\n        if (t.call(n, i, o, r)) return o;\n        o++;\n      }\n\n      return -1;\n    }\n  }), String.prototype.includes || (String.prototype.includes = function (t, r) {\n    \"use strict\";\n\n    return \"number\" != typeof r && (r = 0), !(r + t.length > this.length) && -1 !== this.indexOf(t, r);\n  }), String.prototype.startsWith || (String.prototype.startsWith = function (t, r) {\n    return this.substr(r || 0, t.length) === t;\n  }), Number.isFinite = Number.isFinite || function (t) {\n    return \"number\" == typeof t && isFinite(t);\n  }, Number.isNaN = Number.isNaN || function (t) {\n    return t != t;\n  };\n  var g = {};\n  !function (o) {\n    var t = Math,\n        R = t.abs,\n        u = t.cos,\n        a = t.sin,\n        q = t.sqrt,\n        z = t.min,\n        j = t.max,\n        c = t.atan2,\n        e = t.round,\n        r = t.floor,\n        s = t.PI,\n        h = t.random,\n        E = t.pow;\n    o.bezier = {\n      curveThroughPoints: function curveThroughPoints(t) {\n        return console.warn(\"deprecated\"), new l(g.throughPoints(t)).serialize();\n      },\n      getCurveControlPoints: function getCurveControlPoints(t) {\n        console.warn(\"deprecated\");\n        var n,\n            e = [],\n            i = [],\n            r = t.length - 1;\n        if (1 == r) return e[0] = new y((2 * t[0].x + t[1].x) / 3, (2 * t[0].y + t[1].y) / 3), i[0] = new y(2 * e[0].x - t[0].x, 2 * e[0].y - t[0].y), [e, i];\n        var s = [];\n\n        for (n = 1; n < r - 1; n++) {\n          s[n] = 4 * t[n].x + 2 * t[n + 1].x;\n        }\n\n        s[0] = t[0].x + 2 * t[1].x, s[r - 1] = (8 * t[r - 1].x + t[r].x) / 2;\n        var o = this.getFirstControlPoints(s);\n\n        for (n = 1; n < r - 1; ++n) {\n          s[n] = 4 * t[n].y + 2 * t[n + 1].y;\n        }\n\n        s[0] = t[0].y + 2 * t[1].y, s[r - 1] = (8 * t[r - 1].y + t[r].y) / 2;\n        var h = this.getFirstControlPoints(s);\n\n        for (n = 0; n < r; n++) {\n          e.push(new y(o[n], h[n])), n < r - 1 ? i.push(new y(2 * t[n + 1].x - o[n + 1], 2 * t[n + 1].y - h[n + 1])) : i.push(new y((t[r].x + o[r - 1]) / 2, (t[r].y + h[r - 1]) / 2));\n        }\n\n        return [e, i];\n      },\n      getCurveDivider: function getCurveDivider(t, n, e, i) {\n        console.warn(\"deprecated\");\n        var r = new g(t, n, e, i);\n        return function (t) {\n          var n = r.divide(t);\n          return [{\n            p0: n[0].start,\n            p1: n[0].controlPoint1,\n            p2: n[0].controlPoint2,\n            p3: n[0].end\n          }, {\n            p0: n[1].start,\n            p1: n[1].controlPoint1,\n            p2: n[1].controlPoint2,\n            p3: n[1].end\n          }];\n        };\n      },\n      getFirstControlPoints: function getFirstControlPoints(t) {\n        console.warn(\"deprecated\");\n        var n = t.length,\n            e = [],\n            i = [],\n            r = 2;\n        e[0] = t[0] / r;\n\n        for (var s = 1; s < n; s++) {\n          i[s] = 1 / r, r = (s < n - 1 ? 4 : 3.5) - i[s], e[s] = (t[s] - e[s - 1]) / r;\n        }\n\n        for (s = 1; s < n; s++) {\n          e[n - s - 1] -= i[n - s] * e[n - s];\n        }\n\n        return e;\n      },\n      getInversionSolver: function getInversionSolver(t, n, e, i) {\n        console.warn(\"deprecated\");\n        var r = new g(t, n, e, i);\n        return function (t) {\n          return r.closestPointT(t);\n        };\n      }\n    };\n\n    var g = o.Curve = function (t, n, e, i) {\n      return this instanceof g ? t instanceof g ? new g(t.start, t.controlPoint1, t.controlPoint2, t.end) : (this.start = new y(t), this.controlPoint1 = new y(n), this.controlPoint2 = new y(e), void (this.end = new y(i))) : new g(t, n, e, i);\n    };\n\n    g.throughPoints = function () {\n      function u(t) {\n        var n = t.length,\n            e = [],\n            i = [],\n            r = 2;\n        e[0] = t[0] / r;\n\n        for (var s = 1; s < n; s++) {\n          i[s] = 1 / r, r = (s < n - 1 ? 4 : 3.5) - i[s], e[s] = (t[s] - e[s - 1]) / r;\n        }\n\n        for (s = 1; s < n; s++) {\n          e[n - s - 1] -= i[n - s] * e[n - s];\n        }\n\n        return e;\n      }\n\n      return function (t) {\n        if (!t || Array.isArray(t) && t.length < 2) throw new Error(\"At least 2 points are required\");\n\n        for (var n = function (t) {\n          var n,\n              e = [],\n              i = [],\n              r = t.length - 1;\n          if (1 == r) return e[0] = new y((2 * t[0].x + t[1].x) / 3, (2 * t[0].y + t[1].y) / 3), i[0] = new y(2 * e[0].x - t[0].x, 2 * e[0].y - t[0].y), [e, i];\n          var s = [];\n\n          for (n = 1; n < r - 1; n++) {\n            s[n] = 4 * t[n].x + 2 * t[n + 1].x;\n          }\n\n          s[0] = t[0].x + 2 * t[1].x, s[r - 1] = (8 * t[r - 1].x + t[r].x) / 2;\n          var o = u(s);\n\n          for (n = 1; n < r - 1; ++n) {\n            s[n] = 4 * t[n].y + 2 * t[n + 1].y;\n          }\n\n          s[0] = t[0].y + 2 * t[1].y, s[r - 1] = (8 * t[r - 1].y + t[r].y) / 2;\n          var h = u(s);\n\n          for (n = 0; n < r; n++) {\n            e.push(new y(o[n], h[n])), n < r - 1 ? i.push(new y(2 * t[n + 1].x - o[n + 1], 2 * t[n + 1].y - h[n + 1])) : i.push(new y((t[r].x + o[r - 1]) / 2, (t[r].y + h[r - 1]) / 2));\n          }\n\n          return [e, i];\n        }(t), e = [], i = n[0].length, r = 0; r < i; r++) {\n          var s = new y(n[0][r].x, n[0][r].y),\n              o = new y(n[1][r].x, n[1][r].y);\n          e.push(new g(t[r], s, o, t[r + 1]));\n        }\n\n        return e;\n      };\n    }(), g.prototype = {\n      bbox: function bbox() {\n        for (var t, n, e, i, r, s, o, h, u = this.start, a = this.controlPoint1, c = this.controlPoint2, l = this.end, f = u.x, g = u.y, p = a.x, d = a.y, v = c.x, y = c.y, w = l.x, m = l.y, x = new Array(), b = new Array(), S = [new Array(), new Array()], P = 0; P < 2; ++P) {\n          if (e = 0 === P ? (n = 6 * f - 12 * p + 6 * v, t = -3 * f + 9 * p - 9 * v + 3 * w, 3 * p - 3 * f) : (n = 6 * g - 12 * d + 6 * y, t = -3 * g + 9 * d - 9 * y + 3 * m, 3 * d - 3 * g), R(t) < 1e-12) {\n            if (R(n) < 1e-12) continue;\n            0 < (i = -e / n) && i < 1 && b.push(i);\n          } else h = q(o = n * n - 4 * e * t), o < 0 || (0 < (r = (-n + h) / (2 * t)) && r < 1 && b.push(r), 0 < (s = (-n - h) / (2 * t)) && s < 1 && b.push(s));\n        }\n\n        for (var A, L, E, T = b.length, I = T; T--;) {\n          L = (A = 1 - (i = b[T])) * A * A * f + 3 * A * A * i * p + 3 * A * i * i * v + i * i * i * w, S[0][T] = L, E = A * A * A * g + 3 * A * A * i * d + 3 * A * i * i * y + i * i * i * m, S[1][T] = E, x[T] = {\n            X: L,\n            Y: E\n          };\n        }\n\n        b[I] = 0, b[I + 1] = 1, x[I] = {\n          X: f,\n          Y: g\n        }, x[I + 1] = {\n          X: w,\n          Y: m\n        }, S[0][I] = f, S[1][I] = g, S[0][I + 1] = w, S[1][I + 1] = m, b.length = I + 2, S[0].length = I + 2, S[1].length = I + 2, x.length = I + 2;\n        var C = z.apply(null, S[0]),\n            N = z.apply(null, S[1]),\n            O = j.apply(null, S[0]),\n            D = j.apply(null, S[1]);\n        return new M(C, N, O - C, D - N);\n      },\n      clone: function clone() {\n        return new g(this.start, this.controlPoint1, this.controlPoint2, this.end);\n      },\n      closestPoint: function closestPoint(t, n) {\n        return this.pointAtT(this.closestPointT(t, n));\n      },\n      closestPointLength: function closestPointLength(t, n) {\n        var e = void 0 === (n = n || {}).precision ? this.PRECISION : n.precision,\n            i = {\n          precision: e,\n          subdivisions: void 0 === n.subdivisions ? this.getSubdivisions({\n            precision: e\n          }) : n.subdivisions\n        };\n        return this.lengthAtT(this.closestPointT(t, i), i);\n      },\n      closestPointNormalizedLength: function closestPointNormalizedLength(t, n) {\n        var e = void 0 === (n = n || {}).precision ? this.PRECISION : n.precision,\n            i = {\n          precision: e,\n          subdivisions: void 0 === n.subdivisions ? this.getSubdivisions({\n            precision: e\n          }) : n.subdivisions\n        },\n            r = this.closestPointLength(t, i);\n        if (!r) return 0;\n        var s = this.length(i);\n        return 0 === s ? 0 : r / s;\n      },\n      closestPointT: function closestPointT(t, n) {\n        for (var e, i, r, s, o, h, u = void 0 === (n = n || {}).precision ? this.PRECISION : n.precision, a = void 0 === n.subdivisions ? this.getSubdivisions({\n          precision: u\n        }) : n.subdivisions, c = a.length, l = c ? 1 / c : 0, f = 0; f < c; f++) {\n          var g = a[f],\n              p = g.start.distance(t),\n              d = g.end.distance(t),\n              v = p + d;\n          (!h || v < h) && (e = g, i = f * l, r = (f + 1) * l, s = p, o = d, h = v);\n        }\n\n        for (var y = E(10, -u);;) {\n          var w, m;\n          if (w = s ? R(s - o) / s : 0, m = o ? R(s - o) / o : 0, w < y || m < y) return s <= o ? i : r;\n          var x = e.divide(.5);\n          l /= 2;\n          var b = x[0].start.distance(t),\n              S = x[0].end.distance(t),\n              P = b + S,\n              A = x[1].start.distance(t),\n              L = x[1].end.distance(t);\n          o = P <= A + L ? (e = x[0], r -= l, s = b, S) : (e = x[1], i += l, s = A, L);\n        }\n      },\n      closestPointTangent: function closestPointTangent(t, n) {\n        return this.tangentAtT(this.closestPointT(t, n));\n      },\n      divide: function divide(t) {\n        var n = this.start,\n            e = this.controlPoint1,\n            i = this.controlPoint2,\n            r = this.end;\n        if (t <= 0) return [new g(n, n, n, n), new g(n, e, i, r)];\n        if (1 <= t) return [new g(n, e, i, r), new g(r, r, r, r)];\n        var s = this.getSkeletonPoints(t),\n            o = s.startControlPoint1,\n            h = s.startControlPoint2,\n            u = s.divider,\n            a = s.dividerControlPoint1,\n            c = s.dividerControlPoint2;\n        return [new g(n, o, h, u), new g(u, a, c, r)];\n      },\n      endpointDistance: function endpointDistance() {\n        return this.start.distance(this.end);\n      },\n      equals: function equals(t) {\n        return !!t && this.start.x === t.start.x && this.start.y === t.start.y && this.controlPoint1.x === t.controlPoint1.x && this.controlPoint1.y === t.controlPoint1.y && this.controlPoint2.x === t.controlPoint2.x && this.controlPoint2.y === t.controlPoint2.y && this.end.x === t.end.x && this.end.y === t.end.y;\n      },\n      getSkeletonPoints: function getSkeletonPoints(t) {\n        var n = this.start,\n            e = this.controlPoint1,\n            i = this.controlPoint2,\n            r = this.end;\n        if (t <= 0) return {\n          startControlPoint1: n.clone(),\n          startControlPoint2: n.clone(),\n          divider: n.clone(),\n          dividerControlPoint1: e.clone(),\n          dividerControlPoint2: i.clone()\n        };\n        if (1 <= t) return {\n          startControlPoint1: e.clone(),\n          startControlPoint2: i.clone(),\n          divider: r.clone(),\n          dividerControlPoint1: r.clone(),\n          dividerControlPoint2: r.clone()\n        };\n        var s = new p(n, e).pointAt(t),\n            o = new p(e, i).pointAt(t),\n            h = new p(i, r).pointAt(t),\n            u = new p(s, o).pointAt(t),\n            a = new p(o, h).pointAt(t);\n        return {\n          startControlPoint1: s,\n          startControlPoint2: u,\n          divider: new p(u, a).pointAt(t),\n          dividerControlPoint1: a,\n          dividerControlPoint2: h\n        };\n      },\n      getSubdivisions: function getSubdivisions(t) {\n        var n = void 0 === (t = t || {}).precision ? this.PRECISION : t.precision,\n            e = [new g(this.start, this.controlPoint1, this.controlPoint2, this.end)];\n        if (0 === n) return e;\n\n        for (var i = this.endpointDistance(), r = E(10, -n), s = 0;;) {\n          s += 1;\n\n          for (var o = [], h = e.length, u = 0; u < h; u++) {\n            var a = e[u].divide(.5);\n            o.push(a[0], a[1]);\n          }\n\n          for (var c = 0, l = o.length, f = 0; f < l; f++) {\n            c += o[f].endpointDistance();\n          }\n\n          if (1 < s && (0 !== c ? (c - i) / c : 0) < r) return o;\n          e = o, i = c;\n        }\n      },\n      isDifferentiable: function isDifferentiable() {\n        var t = this.start,\n            n = this.controlPoint1,\n            e = this.controlPoint2,\n            i = this.end;\n        return !(t.equals(n) && n.equals(e) && e.equals(i));\n      },\n      length: function length(t) {\n        for (var n = void 0 === (t = t || {}).precision ? this.PRECISION : t.precision, e = void 0 === t.subdivisions ? this.getSubdivisions({\n          precision: n\n        }) : t.subdivisions, i = 0, r = e.length, s = 0; s < r; s++) {\n          i += e[s].endpointDistance();\n        }\n\n        return i;\n      },\n      lengthAtT: function lengthAtT(t, n) {\n        if (t <= 0) return 0;\n        var e = void 0 === (n = n || {}).precision ? this.PRECISION : n.precision;\n        return this.divide(t)[0].length({\n          precision: e\n        });\n      },\n      pointAt: function pointAt(t, n) {\n        if (t <= 0) return this.start.clone();\n        if (1 <= t) return this.end.clone();\n        var e = this.tAt(t, n);\n        return this.pointAtT(e);\n      },\n      pointAtLength: function pointAtLength(t, n) {\n        var e = this.tAtLength(t, n);\n        return this.pointAtT(e);\n      },\n      pointAtT: function pointAtT(t) {\n        return t <= 0 ? this.start.clone() : 1 <= t ? this.end.clone() : this.getSkeletonPoints(t).divider;\n      },\n      PRECISION: 3,\n      scale: function scale(t, n, e) {\n        return this.start.scale(t, n, e), this.controlPoint1.scale(t, n, e), this.controlPoint2.scale(t, n, e), this.end.scale(t, n, e), this;\n      },\n      tangentAt: function tangentAt(t, n) {\n        if (!this.isDifferentiable()) return null;\n        t < 0 ? t = 0 : 1 < t && (t = 1);\n        var e = this.tAt(t, n);\n        return this.tangentAtT(e);\n      },\n      tangentAtLength: function tangentAtLength(t, n) {\n        if (!this.isDifferentiable()) return null;\n        var e = this.tAtLength(t, n);\n        return this.tangentAtT(e);\n      },\n      tangentAtT: function tangentAtT(t) {\n        if (!this.isDifferentiable()) return null;\n        t < 0 ? t = 0 : 1 < t && (t = 1);\n        var n = this.getSkeletonPoints(t),\n            e = n.startControlPoint2,\n            i = n.dividerControlPoint1,\n            r = n.divider,\n            s = new p(e, i);\n        return s.translate(r.x - e.x, r.y - e.y), s;\n      },\n      tAt: function tAt(t, n) {\n        if (t <= 0) return 0;\n        if (1 <= t) return 1;\n        var e = void 0 === (n = n || {}).precision ? this.PRECISION : n.precision,\n            i = {\n          precision: e,\n          subdivisions: void 0 === n.subdivisions ? this.getSubdivisions({\n            precision: e\n          }) : n.subdivisions\n        },\n            r = this.length(i) * t;\n        return this.tAtLength(r, i);\n      },\n      tAtLength: function tAtLength(t, n) {\n        var e = !0;\n        t < 0 && (e = !1, t = -t);\n\n        for (var i, r, s, o, h, u = void 0 === (n = n || {}).precision ? this.PRECISION : n.precision, a = void 0 === n.subdivisions ? this.getSubdivisions({\n          precision: u\n        }) : n.subdivisions, c = {\n          precision: u,\n          subdivisions: a\n        }, l = 0, f = a.length, g = 1 / f, p = e ? 0 : f - 1; e ? p < f : 0 <= p; e ? p++ : p--) {\n          var d = a[p],\n              v = d.endpointDistance();\n\n          if (t <= l + v) {\n            i = d, r = p * g, s = (p + 1) * g, o = e ? t - l : v + l - t, h = e ? v + l - t : t - l;\n            break;\n          }\n\n          l += v;\n        }\n\n        if (!i) return e ? 1 : 0;\n\n        for (var y = this.length(c), w = E(10, -u);;) {\n          var m, x;\n          if ((0 !== y ? o / y : 0) < w) return r;\n          if ((0 !== y ? h / y : 0) < w) return s;\n          var b = i.divide(.5);\n          g /= 2;\n          var S = b[0].endpointDistance(),\n              P = b[1].endpointDistance();\n          x = o <= S ? (i = b[0], s -= g, S - (m = o)) : (i = b[1], r += g, P - (m = o - S)), o = m, h = x;\n        }\n      },\n      toPoints: function toPoints(t) {\n        for (var n = void 0 === (t = t || {}).precision ? this.PRECISION : t.precision, e = void 0 === t.subdivisions ? this.getSubdivisions({\n          precision: n\n        }) : t.subdivisions, i = [e[0].start.clone()], r = e.length, s = 0; s < r; s++) {\n          var o = e[s];\n          i.push(o.end.clone());\n        }\n\n        return i;\n      },\n      toPolyline: function toPolyline(t) {\n        return new T(this.toPoints(t));\n      },\n      toString: function toString() {\n        return this.start + \" \" + this.controlPoint1 + \" \" + this.controlPoint2 + \" \" + this.end;\n      },\n      translate: function translate(t, n) {\n        return this.start.translate(t, n), this.controlPoint1.translate(t, n), this.controlPoint2.translate(t, n), this.end.translate(t, n), this;\n      }\n    };\n\n    var i = o.Ellipse = function (t, n, e) {\n      return this instanceof i ? t instanceof i ? new i(new y(t.x, t.y), t.a, t.b) : (t = new y(t), this.x = t.x, this.y = t.y, this.a = n, void (this.b = e)) : new i(t, n, e);\n    };\n\n    i.fromRect = function (t) {\n      return t = new M(t), new i(t.center(), t.width / 2, t.height / 2);\n    }, i.prototype = {\n      bbox: function bbox() {\n        return new M(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\n      },\n      center: function center() {\n        return new y(this.x, this.y);\n      },\n      clone: function clone() {\n        return new i(this);\n      },\n      containsPoint: function containsPoint(t) {\n        return this.normalizedDistance(t) <= 1;\n      },\n      equals: function equals(t) {\n        return !!t && t.x === this.x && t.y === this.y && t.a === this.a && t.b === this.b;\n      },\n      inflate: function inflate(t, n) {\n        return void 0 === t && (t = 0), void 0 === n && (n = t), this.a += 2 * t, this.b += 2 * n, this;\n      },\n      intersectionWithLine: function intersectionWithLine(t) {\n        var n = [],\n            e = t.start,\n            i = t.end,\n            r = this.a,\n            s = this.b,\n            o = t.vector(),\n            h = e.difference(new y(this)),\n            u = new y(o.x / (r * r), o.y / (s * s)),\n            a = new y(h.x / (r * r), h.y / (s * s)),\n            c = o.dot(u),\n            l = o.dot(a),\n            f = l * l - c * (h.dot(a) - 1);\n        if (f < 0) return null;\n\n        if (0 < f) {\n          var g = q(f),\n              p = (-l - g) / c,\n              d = (-l + g) / c;\n          if ((p < 0 || 1 < p) && (d < 0 || 1 < d)) return null;\n          0 <= p && p <= 1 && n.push(e.lerp(i, p)), 0 <= d && d <= 1 && n.push(e.lerp(i, d));\n        } else {\n          var v = -l / c;\n          if (!(0 <= v && v <= 1)) return null;\n          n.push(e.lerp(i, v));\n        }\n\n        return n;\n      },\n      intersectionWithLineFromCenterToPoint: function intersectionWithLineFromCenterToPoint(t, n) {\n        t = new y(t), n && t.rotate(new y(this.x, this.y), n);\n        var e,\n            i = t.x - this.x,\n            r = t.y - this.y;\n        if (0 === i) return e = this.bbox().pointNearestToPoint(t), n ? e.rotate(new y(this.x, this.y), -n) : e;\n        var s = r / i,\n            o = s * s,\n            h = this.a * this.a,\n            u = this.b * this.b,\n            a = q(1 / (1 / h + o / u)),\n            c = s * (a = i < 0 ? -a : a);\n        return e = new y(this.x + a, this.y + c), n ? e.rotate(new y(this.x, this.y), -n) : e;\n      },\n      normalizedDistance: function normalizedDistance(t) {\n        var n = t.x,\n            e = t.y,\n            i = this.a,\n            r = this.b,\n            s = this.x,\n            o = this.y;\n        return (n - s) * (n - s) / (i * i) + (e - o) * (e - o) / (r * r);\n      },\n      tangentTheta: function tangentTheta(t) {\n        var n,\n            e,\n            i = t.x,\n            r = t.y,\n            s = this.a,\n            o = this.b,\n            h = this.bbox().center(),\n            u = h.x,\n            a = h.y,\n            c = i > h.x + s / 2,\n            l = i < h.x - s / 2;\n        return c || l ? e = s * s / (i - u) - s * s * (r - a) * ((n = i > h.x ? r - 30 : r + 30) - a) / (o * o * (i - u)) + u : n = o * o / (r - a) - o * o * (i - u) * ((e = r > h.y ? i + 30 : i - 30) - u) / (s * s * (r - a)) + a, new y(e, n).theta(t);\n      },\n      toString: function toString() {\n        return new y(this.x, this.y).toString() + \" \" + this.a + \" \" + this.b;\n      }\n    };\n\n    var p = o.Line = function (t, n) {\n      return this instanceof p ? t instanceof p ? new p(t.start, t.end) : (this.start = new y(t), void (this.end = new y(n))) : new p(t, n);\n    };\n\n    p.prototype = {\n      bbox: function bbox() {\n        var t = z(this.start.x, this.end.x),\n            n = z(this.start.y, this.end.y),\n            e = j(this.start.x, this.end.x),\n            i = j(this.start.y, this.end.y);\n        return new M(t, n, e - t, i - n);\n      },\n      bearing: function bearing() {\n        var t = w(this.start.y),\n            n = w(this.end.y),\n            e = this.start.x,\n            i = this.end.x,\n            r = w(i - e),\n            s = a(r) * u(n),\n            o = u(t) * a(n) - a(t) * u(n) * u(r),\n            h = v(c(s, o)) - 22.5;\n        return h < 0 && (h += 360), [\"NE\", \"E\", \"SE\", \"S\", \"SW\", \"W\", \"NW\", \"N\"][h = parseInt(h / 45)];\n      },\n      clone: function clone() {\n        return new p(this.start, this.end);\n      },\n      closestPoint: function closestPoint(t) {\n        return this.pointAt(this.closestPointNormalizedLength(t));\n      },\n      closestPointLength: function closestPointLength(t) {\n        return this.closestPointNormalizedLength(t) * this.length();\n      },\n      closestPointNormalizedLength: function closestPointNormalizedLength(t) {\n        var n = this.vector().dot(new p(this.start, t).vector()),\n            e = z(1, j(0, n / this.squaredLength()));\n        return e != e ? 0 : e;\n      },\n      closestPointTangent: function closestPointTangent(t) {\n        return this.tangentAt(this.closestPointNormalizedLength(t));\n      },\n      equals: function equals(t) {\n        return !!t && this.start.x === t.start.x && this.start.y === t.start.y && this.end.x === t.end.x && this.end.y === t.end.y;\n      },\n      intersect: function intersect(t, n) {\n        if (t instanceof p || t instanceof M || t instanceof T || t instanceof i || t instanceof l) {\n          var e = t.intersectionWithLine(this, n);\n          return e && t instanceof p && (e = e[0]), e;\n        }\n\n        return null;\n      },\n      intersectionWithLine: function intersectionWithLine(t) {\n        var n = new y(this.end.x - this.start.x, this.end.y - this.start.y),\n            e = new y(t.end.x - t.start.x, t.end.y - t.start.y),\n            i = n.x * e.y - n.y * e.x,\n            r = new y(t.start.x - this.start.x, t.start.y - this.start.y),\n            s = r.x * e.y - r.y * e.x,\n            o = r.x * n.y - r.y * n.x;\n        if (0 === i || s * i < 0 || o * i < 0) return null;\n\n        if (0 < i) {\n          if (i < s || i < o) return null;\n        } else if (s < i || o < i) return null;\n\n        return [new y(this.start.x + s * n.x / i, this.start.y + s * n.y / i)];\n      },\n      isDifferentiable: function isDifferentiable() {\n        return !this.start.equals(this.end);\n      },\n      length: function length() {\n        return q(this.squaredLength());\n      },\n      midpoint: function midpoint() {\n        return new y((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n      },\n      pointAt: function pointAt(t) {\n        var n = this.start,\n            e = this.end;\n        return t <= 0 ? n.clone() : 1 <= t ? e.clone() : n.lerp(e, t);\n      },\n      pointAtLength: function pointAtLength(t) {\n        var n = this.start,\n            e = this.end,\n            i = !0;\n        t < 0 && (i = !1, t = -t);\n        var r = this.length();\n        return r <= t ? i ? e.clone() : n.clone() : this.pointAt((i ? t : r - t) / r);\n      },\n      pointOffset: function pointOffset(t) {\n        t = new o.Point(t);\n        var n = this.start,\n            e = this.end;\n        return ((e.x - n.x) * (t.y - n.y) - (e.y - n.y) * (t.x - n.x)) / this.length();\n      },\n      rotate: function rotate(t, n) {\n        return this.start.rotate(t, n), this.end.rotate(t, n), this;\n      },\n      round: function round(t) {\n        var n = E(10, t || 0);\n        return this.start.x = e(this.start.x * n) / n, this.start.y = e(this.start.y * n) / n, this.end.x = e(this.end.x * n) / n, this.end.y = e(this.end.y * n) / n, this;\n      },\n      scale: function scale(t, n, e) {\n        return this.start.scale(t, n, e), this.end.scale(t, n, e), this;\n      },\n      setLength: function setLength(t) {\n        var n = this.length();\n        if (!n) return this;\n        var e = t / n;\n        return this.scale(e, e, this.start);\n      },\n      squaredLength: function squaredLength() {\n        var t = this.start.x,\n            n = this.start.y;\n        return (t -= this.end.x) * t + (n -= this.end.y) * n;\n      },\n      tangentAt: function tangentAt(t) {\n        if (!this.isDifferentiable()) return null;\n        var n = this.start,\n            e = this.end,\n            i = this.pointAt(t),\n            r = new p(n, e);\n        return r.translate(i.x - n.x, i.y - n.y), r;\n      },\n      tangentAtLength: function tangentAtLength(t) {\n        if (!this.isDifferentiable()) return null;\n        var n = this.start,\n            e = this.end,\n            i = this.pointAtLength(t),\n            r = new p(n, e);\n        return r.translate(i.x - n.x, i.y - n.y), r;\n      },\n      toString: function toString() {\n        return this.start.toString() + \" \" + this.end.toString();\n      },\n      translate: function translate(t, n) {\n        return this.start.translate(t, n), this.end.translate(t, n), this;\n      },\n      vector: function vector() {\n        return new y(this.end.x - this.start.x, this.end.y - this.start.y);\n      }\n    }, p.prototype.intersection = p.prototype.intersect;\n\n    var l = o.Path = function (t) {\n      if (!(this instanceof l)) return new l(t);\n      if (\"string\" == typeof t) return new l.parse(t);\n      var n, e;\n\n      if (this.segments = [], t) {\n        if (Array.isArray(t) && 0 !== t.length) {\n          if (e = t.length, t[0].isSegment) for (n = 0; n < e; n++) {\n            var i = t[n];\n            this.appendSegment(i);\n          } else {\n            var r = null;\n\n            for (n = 0; n < e; n++) {\n              var s = t[n];\n              if (!(s instanceof p || s instanceof g)) throw new Error(\"Cannot construct a path segment from the provided object.\");\n              0 === n && this.appendSegment(l.createSegment(\"M\", s.start)), r && !r.end.equals(s.start) && this.appendSegment(l.createSegment(\"M\", s.start)), s instanceof p ? this.appendSegment(l.createSegment(\"L\", s.end)) : s instanceof g && this.appendSegment(l.createSegment(\"C\", s.controlPoint1, s.controlPoint2, s.end)), r = s;\n            }\n          }\n        } else if (t.isSegment) this.appendSegment(t);else if (t instanceof p) this.appendSegment(l.createSegment(\"M\", t.start)), this.appendSegment(l.createSegment(\"L\", t.end));else if (t instanceof g) this.appendSegment(l.createSegment(\"M\", t.start)), this.appendSegment(l.createSegment(\"C\", t.controlPoint1, t.controlPoint2, t.end));else if (t instanceof T && t.points && 0 !== t.points.length) for (e = t.points.length, n = 0; n < e; n++) {\n          var o = t.points[n];\n          0 === n ? this.appendSegment(l.createSegment(\"M\", o)) : this.appendSegment(l.createSegment(\"L\", o));\n        }\n      } else ;\n    };\n\n    l.parse = function (t) {\n      if (!t) return new l();\n\n      for (var n = new l(), e = t.match(/(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g), i = e.length, r = 0; r < i; r++) {\n        var s = e[r].match(/(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?))|(?:(?:-?\\.\\d+))/g),\n            o = l.createSegment.apply(this, s);\n        n.appendSegment(o);\n      }\n\n      return n;\n    }, l.createSegment = function (t) {\n      if (!t) throw new Error(\"Type must be provided.\");\n      var n = l.segmentTypes[t];\n      if (!n) throw new Error(t + \" is not a recognized path segment type.\");\n\n      for (var e = [], i = arguments.length, r = 1; r < i; r++) {\n        e.push(arguments[r]);\n      }\n\n      return m(n, e);\n    }, l.prototype = {\n      appendSegment: function appendSegment(t) {\n        var n,\n            e = this.segments,\n            i = e.length,\n            r = 0 !== i ? e[i - 1] : null;\n\n        if (Array.isArray(t)) {\n          if (!t[0].isSegment) throw new Error(\"Segments required.\");\n\n          for (var s = t.length, o = 0; o < s; o++) {\n            var h = t[o];\n            n = this.prepareSegment(h, r, null), e.push(n), r = n;\n          }\n        } else {\n          if (!t || !t.isSegment) throw new Error(\"Segment required.\");\n          n = this.prepareSegment(t, r, null), e.push(n);\n        }\n      },\n      bbox: function bbox() {\n        var t,\n            n = this.segments,\n            e = n.length;\n        if (0 === e) return null;\n\n        for (var i = 0; i < e; i++) {\n          var r = n[i];\n\n          if (r.isVisible) {\n            var s = r.bbox();\n            t = t ? t.union(s) : s;\n          }\n        }\n\n        if (t) return t;\n        var o = n[e - 1];\n        return new M(o.end.x, o.end.y, 0, 0);\n      },\n      clone: function clone() {\n        for (var t = this.segments, n = t.length, e = new l(), i = 0; i < n; i++) {\n          var r = t[i].clone();\n          e.appendSegment(r);\n        }\n\n        return e;\n      },\n      closestPoint: function closestPoint(t, n) {\n        var e = this.closestPointT(t, n);\n        return e ? this.pointAtT(e) : null;\n      },\n      closestPointLength: function closestPointLength(t, n) {\n        var e = void 0 === (n = n || {}).precision ? this.PRECISION : n.precision,\n            i = {\n          precision: e,\n          segmentSubdivisions: void 0 === n.segmentSubdivisions ? this.getSegmentSubdivisions({\n            precision: e\n          }) : n.segmentSubdivisions\n        },\n            r = this.closestPointT(t, i);\n        return r ? this.lengthAtT(r, i) : 0;\n      },\n      closestPointNormalizedLength: function closestPointNormalizedLength(t, n) {\n        var e = void 0 === (n = n || {}).precision ? this.PRECISION : n.precision,\n            i = {\n          precision: e,\n          segmentSubdivisions: void 0 === n.segmentSubdivisions ? this.getSegmentSubdivisions({\n            precision: e\n          }) : n.segmentSubdivisions\n        },\n            r = this.closestPointLength(t, i);\n        if (0 === r) return 0;\n        var s = this.length(i);\n        return 0 === s ? 0 : r / s;\n      },\n      closestPointT: function closestPointT(t, n) {\n        var e = this.segments,\n            i = e.length;\n        if (0 === i) return null;\n\n        for (var r, s = void 0 === (n = n || {}).precision ? this.PRECISION : n.precision, o = void 0 === n.segmentSubdivisions ? this.getSegmentSubdivisions({\n          precision: s\n        }) : n.segmentSubdivisions, h = 1 / 0, u = 0; u < i; u++) {\n          var a = e[u],\n              c = o[u];\n\n          if (a.isVisible) {\n            var l = a.closestPointT(t, {\n              precision: s,\n              subdivisions: c\n            }),\n                f = a.pointAtT(l),\n                g = new p(f, t).squaredLength();\n            g < h && (r = {\n              segmentIndex: u,\n              value: l\n            }, h = g);\n          }\n        }\n\n        return r || {\n          segmentIndex: i - 1,\n          value: 1\n        };\n      },\n      closestPointTangent: function closestPointTangent(t, n) {\n        var e = this.segments,\n            i = e.length;\n        if (0 === i) return null;\n\n        for (var r, s = void 0 === (n = n || {}).precision ? this.PRECISION : n.precision, o = void 0 === n.segmentSubdivisions ? this.getSegmentSubdivisions({\n          precision: s\n        }) : n.segmentSubdivisions, h = 1 / 0, u = 0; u < i; u++) {\n          var a = e[u],\n              c = o[u];\n\n          if (a.isDifferentiable()) {\n            var l = a.closestPointT(t, {\n              precision: s,\n              subdivisions: c\n            }),\n                f = a.pointAtT(l),\n                g = new p(f, t).squaredLength();\n            g < h && (r = a.tangentAtT(l), h = g);\n          }\n        }\n\n        return r || null;\n      },\n      equals: function equals(t) {\n        if (!t) return !1;\n        var n = this.segments,\n            e = t.segments,\n            i = n.length;\n        if (e.length !== i) return !1;\n\n        for (var r = 0; r < i; r++) {\n          var s = n[r],\n              o = e[r];\n          if (s.type !== o.type || !s.equals(o)) return !1;\n        }\n\n        return !0;\n      },\n      getSegment: function getSegment(t) {\n        var n = this.segments,\n            e = n.length;\n        if (0 === e) throw new Error(\"Path has no segments.\");\n        if (t < 0 && (t = e + t), e <= t || t < 0) throw new Error(\"Index out of range.\");\n        return n[t];\n      },\n      getSegmentSubdivisions: function getSegmentSubdivisions(t) {\n        for (var n = this.segments, e = n.length, i = void 0 === (t = t || {}).precision ? this.PRECISION : t.precision, r = [], s = 0; s < e; s++) {\n          var o = n[s].getSubdivisions({\n            precision: i\n          });\n          r.push(o);\n        }\n\n        return r;\n      },\n      insertSegment: function insertSegment(t, n) {\n        var e,\n            i = this.segments,\n            r = i.length;\n        if (t < 0 && (t = r + t + 1), r < t || t < 0) throw new Error(\"Index out of range.\");\n        var s = null,\n            o = null;\n\n        if (0 !== r && (o = 1 <= t ? (s = i[t - 1]).nextSegment : i[0]), Array.isArray(n)) {\n          if (!n[0].isSegment) throw new Error(\"Segments required.\");\n\n          for (var h = n.length, u = 0; u < h; u++) {\n            var a = n[u];\n            e = this.prepareSegment(a, s, o), i.splice(t + u, 0, e), s = e;\n          }\n        } else {\n          if (!n || !n.isSegment) throw new Error(\"Segment required.\");\n          e = this.prepareSegment(n, s, o), i.splice(t, 0, e);\n        }\n      },\n      intersectionWithLine: function intersectionWithLine(t, n) {\n        var e = null,\n            i = this.toPolylines(n);\n        if (!i) return null;\n\n        for (var r = 0, s = i.length; r < s; r++) {\n          var o = i[r],\n              h = t.intersect(o);\n          h && (e || (e = []), Array.isArray(h) ? Array.prototype.push.apply(e, h) : e.push(h));\n        }\n\n        return e;\n      },\n      isDifferentiable: function isDifferentiable() {\n        for (var t = this.segments, n = t.length, e = 0; e < n; e++) {\n          if (t[e].isDifferentiable()) return !0;\n        }\n\n        return !1;\n      },\n      isValid: function isValid() {\n        var t = this.segments;\n        return 0 === t.length || \"M\" === t[0].type;\n      },\n      length: function length(t) {\n        var n = this.segments,\n            e = n.length;\n        if (0 === e) return 0;\n\n        for (var i = void 0 === (t = t || {}).precision ? this.PRECISION : t.precision, r = void 0 === t.segmentSubdivisions ? this.getSegmentSubdivisions({\n          precision: i\n        }) : t.segmentSubdivisions, s = 0, o = 0; o < e; o++) {\n          var h = n[o],\n              u = r[o];\n          s += h.length({\n            subdivisions: u\n          });\n        }\n\n        return s;\n      },\n      lengthAtT: function lengthAtT(t, n) {\n        var e = this.segments,\n            i = e.length;\n        if (0 === i) return 0;\n        var r = t.segmentIndex;\n        if (r < 0) return 0;\n        var s = t.value;\n        i <= r ? (r = i - 1, s = 1) : s < 0 ? s = 0 : 1 < s && (s = 1);\n\n        for (var o, h = void 0 === (n = n || {}).precision ? this.PRECISION : n.precision, u = void 0 === n.segmentSubdivisions ? this.getSegmentSubdivisions({\n          precision: h\n        }) : n.segmentSubdivisions, a = 0, c = 0; c < r; c++) {\n          var l = e[c];\n          o = u[c], a += l.length({\n            precisison: h,\n            subdivisions: o\n          });\n        }\n\n        return l = e[r], o = u[r], a += l.lengthAtT(s, {\n          precisison: h,\n          subdivisions: o\n        });\n      },\n      pointAt: function pointAt(t, n) {\n        if (0 === this.segments.length) return null;\n        if (t <= 0) return this.start.clone();\n        if (1 <= t) return this.end.clone();\n        var e = void 0 === (n = n || {}).precision ? this.PRECISION : n.precision,\n            i = {\n          precision: e,\n          segmentSubdivisions: void 0 === n.segmentSubdivisions ? this.getSegmentSubdivisions({\n            precision: e\n          }) : n.segmentSubdivisions\n        },\n            r = this.length(i) * t;\n        return this.pointAtLength(r, i);\n      },\n      pointAtLength: function pointAtLength(t, n) {\n        var e = this.segments,\n            i = e.length;\n        if (0 === i) return null;\n        if (0 === t) return this.start.clone();\n        var r = !0;\n        t < 0 && (r = !1, t = -t);\n\n        for (var s, o = void 0 === (n = n || {}).precision ? this.PRECISION : n.precision, h = void 0 === n.segmentSubdivisions ? this.getSegmentSubdivisions({\n          precision: o\n        }) : n.segmentSubdivisions, u = 0, a = r ? 0 : i - 1; r ? a < i : 0 <= a; r ? a++ : a--) {\n          var c = e[a],\n              l = h[a],\n              f = c.length({\n            precision: o,\n            subdivisions: l\n          });\n\n          if (c.isVisible) {\n            if (t <= u + f) return c.pointAtLength((r ? 1 : -1) * (t - u), {\n              precision: o,\n              subdivisions: l\n            });\n            s = c;\n          }\n\n          u += f;\n        }\n\n        return s ? r ? s.end : s.start : e[i - 1].end.clone();\n      },\n      pointAtT: function pointAtT(t) {\n        var n = this.segments,\n            e = n.length;\n        if (0 === e) return null;\n        var i = t.segmentIndex;\n        if (i < 0) return n[0].pointAtT(0);\n        if (e <= i) return n[e - 1].pointAtT(1);\n        var r = t.value;\n        return r < 0 ? r = 0 : 1 < r && (r = 1), n[i].pointAtT(r);\n      },\n      PRECISION: 3,\n      prepareSegment: function prepareSegment(t, n, e) {\n        t.previousSegment = n, t.nextSegment = e, n && (n.nextSegment = t), e && (e.previousSegment = t);\n        var i = t;\n        return t.isSubpathStart && (t.subpathStartSegment = t, i = e), i && this.updateSubpathStartSegment(i), t;\n      },\n      removeSegment: function removeSegment(t) {\n        var n = this.segments,\n            e = n.length;\n        if (0 === e) throw new Error(\"Path has no segments.\");\n        if (t < 0 && (t = e + t), e <= t || t < 0) throw new Error(\"Index out of range.\");\n        var i = n.splice(t, 1)[0],\n            r = i.previousSegment,\n            s = i.nextSegment;\n        r && (r.nextSegment = s), s && (s.previousSegment = r), i.isSubpathStart && s && this.updateSubpathStartSegment(s);\n      },\n      replaceSegment: function replaceSegment(t, n) {\n        var e,\n            i = this.segments,\n            r = i.length;\n        if (0 === r) throw new Error(\"Path has no segments.\");\n        if (t < 0 && (t = r + t), r <= t || t < 0) throw new Error(\"Index out of range.\");\n        var s = i[t],\n            o = s.previousSegment,\n            h = s.nextSegment,\n            u = s.isSubpathStart;\n\n        if (Array.isArray(n)) {\n          if (!n[0].isSegment) throw new Error(\"Segments required.\");\n          i.splice(t, 1);\n\n          for (var a = n.length, c = 0; c < a; c++) {\n            var l = n[c];\n            e = this.prepareSegment(l, o, h), i.splice(t + c, 0, e), o = e, u && e.isSubpathStart && (u = !1);\n          }\n        } else {\n          if (!n || !n.isSegment) throw new Error(\"Segment required.\");\n          e = this.prepareSegment(n, o, h), i.splice(t, 1, e), u && e.isSubpathStart && (u = !1);\n        }\n\n        u && h && this.updateSubpathStartSegment(h);\n      },\n      scale: function scale(t, n, e) {\n        for (var i = this.segments, r = i.length, s = 0; s < r; s++) {\n          i[s].scale(t, n, e);\n        }\n\n        return this;\n      },\n      segmentAt: function segmentAt(t, n) {\n        var e = this.segmentIndexAt(t, n);\n        return e ? this.getSegment(e) : null;\n      },\n      segmentAtLength: function segmentAtLength(t, n) {\n        var e = this.segmentIndexAtLength(t, n);\n        return e ? this.getSegment(e) : null;\n      },\n      segmentIndexAt: function segmentIndexAt(t, n) {\n        if (0 === this.segments.length) return null;\n        t < 0 && (t = 0), 1 < t && (t = 1);\n        var e = void 0 === (n = n || {}).precision ? this.PRECISION : n.precision,\n            i = {\n          precision: e,\n          segmentSubdivisions: void 0 === n.segmentSubdivisions ? this.getSegmentSubdivisions({\n            precision: e\n          }) : n.segmentSubdivisions\n        },\n            r = this.length(i) * t;\n        return this.segmentIndexAtLength(r, i);\n      },\n      segmentIndexAtLength: function segmentIndexAtLength(t, n) {\n        var e = this.segments,\n            i = e.length;\n        if (0 === i) return null;\n        var r = !0;\n        t < 0 && (r = !1, t = -t);\n\n        for (var s = void 0 === (n = n || {}).precision ? this.PRECISION : n.precision, o = void 0 === n.segmentSubdivisions ? this.getSegmentSubdivisions({\n          precision: s\n        }) : n.segmentSubdivisions, h = null, u = 0, a = r ? 0 : i - 1; r ? a < i : 0 <= a; r ? a++ : a--) {\n          var c = e[a],\n              l = o[a],\n              f = c.length({\n            precision: s,\n            subdivisions: l\n          });\n\n          if (c.isVisible) {\n            if (t <= u + f) return a;\n            h = a;\n          }\n\n          u += f;\n        }\n\n        return h;\n      },\n      serialize: function serialize() {\n        if (!this.isValid()) throw new Error(\"Invalid path segments.\");\n        return this.toString();\n      },\n      tangentAt: function tangentAt(t, n) {\n        if (0 === this.segments.length) return null;\n        t < 0 && (t = 0), 1 < t && (t = 1);\n        var e = void 0 === (n = n || {}).precision ? this.PRECISION : n.precision,\n            i = {\n          precision: e,\n          segmentSubdivisions: void 0 === n.segmentSubdivisions ? this.getSegmentSubdivisions({\n            precision: e\n          }) : n.segmentSubdivisions\n        },\n            r = this.length(i) * t;\n        return this.tangentAtLength(r, i);\n      },\n      tangentAtLength: function tangentAtLength(t, n) {\n        var e = this.segments,\n            i = e.length;\n        if (0 === i) return null;\n        var r = !0;\n        t < 0 && (r = !1, t = -t);\n\n        for (var s, o = void 0 === (n = n || {}).precision ? this.PRECISION : n.precision, h = void 0 === n.segmentSubdivisions ? this.getSegmentSubdivisions({\n          precision: o\n        }) : n.segmentSubdivisions, u = 0, a = r ? 0 : i - 1; r ? a < i : 0 <= a; r ? a++ : a--) {\n          var c = e[a],\n              l = h[a],\n              f = c.length({\n            precision: o,\n            subdivisions: l\n          });\n\n          if (c.isDifferentiable()) {\n            if (t <= u + f) return c.tangentAtLength((r ? 1 : -1) * (t - u), {\n              precision: o,\n              subdivisions: l\n            });\n            s = c;\n          }\n\n          u += f;\n        }\n\n        if (s) {\n          var g = r ? 1 : 0;\n          return s.tangentAtT(g);\n        }\n\n        return null;\n      },\n      tangentAtT: function tangentAtT(t) {\n        var n = this.segments,\n            e = n.length;\n        if (0 === e) return null;\n        var i = t.segmentIndex;\n        if (i < 0) return n[0].tangentAtT(0);\n        if (e <= i) return n[e - 1].tangentAtT(1);\n        var r = t.value;\n        return r < 0 ? r = 0 : 1 < r && (r = 1), n[i].tangentAtT(r);\n      },\n      toPoints: function toPoints(t) {\n        var n = this.segments,\n            e = n.length;\n        if (0 === e) return null;\n\n        for (var i = void 0 === (t = t || {}).precision ? this.PRECISION : t.precision, r = void 0 === t.segmentSubdivisions ? this.getSegmentSubdivisions({\n          precision: i\n        }) : t.segmentSubdivisions, s = [], o = [], h = 0; h < e; h++) {\n          var u = n[h];\n\n          if (u.isVisible) {\n            var a = r[h];\n\n            if (0 < a.length) {\n              var c = a.map(function (t) {\n                return t.start;\n              });\n              Array.prototype.push.apply(o, c);\n            } else o.push(u.start);\n          } else 0 < o.length && (o.push(n[h - 1].end), s.push(o), o = []);\n        }\n\n        return 0 < o.length && (o.push(this.end), s.push(o)), s;\n      },\n      toPolylines: function toPolylines(t) {\n        var n = [],\n            e = this.toPoints(t);\n        if (!e) return null;\n\n        for (var i = 0, r = e.length; i < r; i++) {\n          n.push(new T(e[i]));\n        }\n\n        return n;\n      },\n      toString: function toString() {\n        for (var t = this.segments, n = t.length, e = \"\", i = 0; i < n; i++) {\n          e += t[i].serialize() + \" \";\n        }\n\n        return e.trim();\n      },\n      translate: function translate(t, n) {\n        for (var e = this.segments, i = e.length, r = 0; r < i; r++) {\n          e[r].translate(t, n);\n        }\n\n        return this;\n      },\n      updateSubpathStartSegment: function updateSubpathStartSegment(t) {\n        for (var n = t.previousSegment; t && !t.isSubpathStart;) {\n          t.subpathStartSegment = n ? n.subpathStartSegment : null, t = (n = t).nextSegment;\n        }\n      }\n    }, Object.defineProperty(l.prototype, \"start\", {\n      configurable: !0,\n      enumerable: !0,\n      get: function get() {\n        var t = this.segments,\n            n = t.length;\n        if (0 === n) return null;\n\n        for (var e = 0; e < n; e++) {\n          var i = t[e];\n          if (i.isVisible) return i.start;\n        }\n\n        return t[n - 1].end;\n      }\n    }), Object.defineProperty(l.prototype, \"end\", {\n      configurable: !0,\n      enumerable: !0,\n      get: function get() {\n        var t = this.segments,\n            n = t.length;\n        if (0 === n) return null;\n\n        for (var e = n - 1; 0 <= e; e--) {\n          var i = t[e];\n          if (i.isVisible) return i.end;\n        }\n\n        return t[n - 1].end;\n      }\n    });\n\n    var y = o.Point = function (t, n) {\n      if (!(this instanceof y)) return new y(t, n);\n\n      if (\"string\" == typeof t) {\n        var e = t.split(-1 === t.indexOf(\"@\") ? \" \" : \"@\");\n        t = parseFloat(e[0]), n = parseFloat(e[1]);\n      } else Object(t) === t && (n = t.y, t = t.x);\n\n      this.x = void 0 === t ? 0 : t, this.y = void 0 === n ? 0 : n;\n    };\n\n    y.fromPolar = function (t, n, e) {\n      e = e && new y(e) || new y(0, 0);\n      var i = R(t * u(n)),\n          r = R(t * a(n)),\n          s = f(v(n));\n      return s < 90 ? r = -r : s < 180 ? (i = -i, r = -r) : s < 270 && (i = -i), new y(e.x + i, e.y + r);\n    }, y.random = function (t, n, e, i) {\n      return new y(r(h() * (n - t + 1) + t), r(h() * (i - e + 1) + e));\n    }, y.prototype = {\n      adhereToRect: function adhereToRect(t) {\n        return t.containsPoint(this) || (this.x = z(j(this.x, t.x), t.x + t.width), this.y = z(j(this.y, t.y), t.y + t.height)), this;\n      },\n      angleBetween: function angleBetween(t, n) {\n        var e = this.equals(t) || this.equals(n) ? NaN : this.theta(n) - this.theta(t);\n        return e < 0 && (e += 360), e;\n      },\n      bearing: function bearing(t) {\n        return new p(this, t).bearing();\n      },\n      changeInAngle: function changeInAngle(t, n, e) {\n        return this.clone().offset(-t, -n).theta(e) - this.theta(e);\n      },\n      clone: function clone() {\n        return new y(this);\n      },\n      cross: function cross(t, n) {\n        return t && n ? (n.x - this.x) * (t.y - this.y) - (n.y - this.y) * (t.x - this.x) : NaN;\n      },\n      difference: function difference(t, n) {\n        return Object(t) === t && (n = t.y, t = t.x), new y(this.x - (t || 0), this.y - (n || 0));\n      },\n      distance: function distance(t) {\n        return new p(this, t).length();\n      },\n      dot: function dot(t) {\n        return t ? this.x * t.x + this.y * t.y : NaN;\n      },\n      equals: function equals(t) {\n        return !!t && this.x === t.x && this.y === t.y;\n      },\n      lerp: function lerp(t, n) {\n        var e = this.x,\n            i = this.y;\n        return new y((1 - n) * e + n * t.x, (1 - n) * i + n * t.y);\n      },\n      magnitude: function magnitude() {\n        return q(this.x * this.x + this.y * this.y) || .01;\n      },\n      manhattanDistance: function manhattanDistance(t) {\n        return R(t.x - this.x) + R(t.y - this.y);\n      },\n      move: function move(t, n) {\n        var e = w(new y(t).theta(this));\n        return this.offset(u(e) * n, -a(e) * n);\n      },\n      normalize: function normalize(t) {\n        var n = (t || 1) / this.magnitude();\n        return this.scale(n, n);\n      },\n      offset: function offset(t, n) {\n        return Object(t) === t && (n = t.y, t = t.x), this.x += t || 0, this.y += n || 0, this;\n      },\n      reflection: function reflection(t) {\n        return new y(t).move(this, this.distance(t));\n      },\n      rotate: function rotate(t, n) {\n        t = t || new o.Point(0, 0), n = w(f(-n));\n        var e = u(n),\n            i = a(n),\n            r = e * (this.x - t.x) - i * (this.y - t.y) + t.x,\n            s = i * (this.x - t.x) + e * (this.y - t.y) + t.y;\n        return this.x = r, this.y = s, this;\n      },\n      round: function round(t) {\n        var n = E(10, t || 0);\n        return this.x = e(this.x * n) / n, this.y = e(this.y * n) / n, this;\n      },\n      scale: function scale(t, n, e) {\n        return e = e && new y(e) || new y(0, 0), this.x = e.x + t * (this.x - e.x), this.y = e.y + n * (this.y - e.y), this;\n      },\n      snapToGrid: function snapToGrid(t, n) {\n        return this.x = d(this.x, t), this.y = d(this.y, n || t), this;\n      },\n      squaredDistance: function squaredDistance(t) {\n        return new p(this, t).squaredLength();\n      },\n      theta: function theta(t) {\n        var n = -((t = new y(t)).y - this.y),\n            e = t.x - this.x,\n            i = c(n, e);\n        return i < 0 && (i = 2 * s + i), 180 * i / s;\n      },\n      toJSON: function toJSON() {\n        return {\n          x: this.x,\n          y: this.y\n        };\n      },\n      toPolar: function toPolar(t) {\n        t = t && new y(t) || new y(0, 0);\n        var n = this.x,\n            e = this.y;\n        return this.x = q((n - t.x) * (n - t.x) + (e - t.y) * (e - t.y)), this.y = w(t.theta(new y(n, e))), this;\n      },\n      toString: function toString() {\n        return this.x + \"@\" + this.y;\n      },\n      update: function update(t, n) {\n        return this.x = t || 0, this.y = n || 0, this;\n      },\n      vectorAngle: function vectorAngle(t) {\n        return new y(0, 0).angleBetween(this, t);\n      }\n    }, y.prototype.translate = y.prototype.offset;\n\n    var T = o.Polyline = function (t) {\n      return this instanceof T ? \"string\" == typeof t ? new T.parse(t) : void (this.points = Array.isArray(t) ? t.map(y) : []) : new T(t);\n    };\n\n    T.parse = function (t) {\n      if (\"\" === (t = t.trim())) return new T();\n\n      for (var n = [], e = t.split(/\\s*,\\s*|\\s+/), i = e.length, r = 0; r < i; r += 2) {\n        n.push({\n          x: +e[r],\n          y: +e[r + 1]\n        });\n      }\n\n      return new T(n);\n    }, T.prototype = {\n      bbox: function bbox() {\n        var t = 1 / 0,\n            n = -1 / 0,\n            e = 1 / 0,\n            i = -1 / 0,\n            r = this.points,\n            s = r.length;\n        if (0 === s) return null;\n\n        for (var o = 0; o < s; o++) {\n          var h = r[o],\n              u = h.x,\n              a = h.y;\n          u < t && (t = u), n < u && (n = u), a < e && (e = a), i < a && (i = a);\n        }\n\n        return new M(t, e, n - t, i - e);\n      },\n      clone: function clone() {\n        var t = this.points,\n            n = t.length;\n        if (0 === n) return new T();\n\n        for (var e = [], i = 0; i < n; i++) {\n          var r = t[i].clone();\n          e.push(r);\n        }\n\n        return new T(e);\n      },\n      closestPoint: function closestPoint(t) {\n        var n = this.closestPointLength(t);\n        return this.pointAtLength(n);\n      },\n      closestPointLength: function closestPointLength(t) {\n        var n,\n            e = this.points,\n            i = e.length;\n        if (0 === i) return 0;\n        if (1 === i) return 0;\n\n        for (var r = 1 / 0, s = 0, o = i - 1, h = 0; h < o; h++) {\n          var u = new p(e[h], e[h + 1]),\n              a = u.length(),\n              c = u.closestPointNormalizedLength(t),\n              l = u.pointAt(c).squaredDistance(t);\n          l < r && (r = l, n = s + c * a), s += a;\n        }\n\n        return n;\n      },\n      closestPointNormalizedLength: function closestPointNormalizedLength(t) {\n        var n = this.closestPointLength(t);\n        if (0 === n) return 0;\n        var e = this.length();\n        return 0 === e ? 0 : n / e;\n      },\n      closestPointTangent: function closestPointTangent(t) {\n        var n = this.closestPointLength(t);\n        return this.tangentAtLength(n);\n      },\n      convexHull: function convexHull() {\n        var t,\n            n,\n            e,\n            i = this.points,\n            r = i.length;\n        if (0 === r) return new T();\n\n        for (t = 0; t < r; t++) {\n          void 0 === e ? e = i[t] : i[t].y < e.y ? e = i[t] : i[t].y === e.y && i[t].x > e.x && (e = i[t]);\n        }\n\n        var s = [];\n\n        for (t = 0; t < r; t++) {\n          var o = e.theta(i[t]);\n          0 === o && (o = 360);\n          var h = [i[t], t, o];\n          s.push(h);\n        }\n\n        if (s.sort(function (t, n) {\n          var e = t[2] - n[2];\n          return 0 === e && (e = n[1] - t[1]), e;\n        }), 2 < s.length) {\n          var u = s[s.length - 1];\n          s.unshift(u);\n        }\n\n        for (var a, c, l, f, g, p, d, v = {}, y = []; 0 !== s.length;) {\n          if (c = (a = s.pop())[0], !v.hasOwnProperty(a[0] + \"@@\" + a[1])) for (var w = !1; !w;) {\n            if (y.length < 2) y.push(a), w = !0;else {\n              f = (l = y.pop())[0];\n              var m = (p = (g = y.pop())[0]).cross(f, c);\n              if (m < 0) y.push(g), y.push(l), y.push(a), w = !0;else if (0 === m) {\n                var x = f.angleBetween(p, c);\n                R(x - 180) < 1e-10 ? (v[l[0] + \"@@\" + l[1]] = f, y.push(g)) : f.equals(c) || p.equals(f) ? (v[l[0] + \"@@\" + l[1]] = f, y.push(g)) : R((x + 1) % 360 - 1) < 1e-10 && (y.push(g), s.push(l));\n              } else v[l[0] + \"@@\" + l[1]] = f, y.push(g);\n            }\n          }\n        }\n\n        2 < y.length && y.pop();\n        var b = -1;\n\n        for (n = y.length, t = 0; t < n; t++) {\n          var S = y[t][1];\n          (void 0 === d || S < d) && (d = S, b = t);\n        }\n\n        var P = [];\n\n        if (0 < b) {\n          var A = y.slice(b),\n              L = y.slice(0, b);\n          P = A.concat(L);\n        } else P = y;\n\n        var E = [];\n\n        for (n = P.length, t = 0; t < n; t++) {\n          E.push(P[t][0]);\n        }\n\n        return new T(E);\n      },\n      equals: function equals(t) {\n        if (!t) return !1;\n        var n = this.points,\n            e = t.points,\n            i = n.length;\n        if (e.length !== i) return !1;\n\n        for (var r = 0; r < i; r++) {\n          var s = n[r],\n              o = t.points[r];\n          if (!s.equals(o)) return !1;\n        }\n\n        return !0;\n      },\n      intersectionWithLine: function intersectionWithLine(t) {\n        for (var n = new p(t), e = [], i = this.points, r = 0, s = i.length - 1; r < s; r++) {\n          var o = i[r],\n              h = i[r + 1],\n              u = new p(o, h),\n              a = n.intersectionWithLine(u);\n          a && e.push(a[0]);\n        }\n\n        return 0 < e.length ? e : null;\n      },\n      isDifferentiable: function isDifferentiable() {\n        var t = this.points,\n            n = t.length;\n        if (0 === n) return !1;\n\n        for (var e = n - 1, i = 0; i < e; i++) {\n          var r = t[i],\n              s = t[i + 1];\n          if (new p(r, s).isDifferentiable()) return !0;\n        }\n\n        return !1;\n      },\n      length: function length() {\n        var t = this.points,\n            n = t.length;\n        if (0 === n) return 0;\n\n        for (var e = 0, i = n - 1, r = 0; r < i; r++) {\n          e += t[r].distance(t[r + 1]);\n        }\n\n        return e;\n      },\n      pointAt: function pointAt(t) {\n        var n = this.points,\n            e = n.length;\n        if (0 === e) return null;\n        if (1 === e) return n[0].clone();\n        if (t <= 0) return n[0].clone();\n        if (1 <= t) return n[e - 1].clone();\n        var i = this.length() * t;\n        return this.pointAtLength(i);\n      },\n      pointAtLength: function pointAtLength(t) {\n        var n = this.points,\n            e = n.length;\n        if (0 === e) return null;\n        if (1 === e) return n[0].clone();\n        var i = !0;\n        t < 0 && (i = !1, t = -t);\n\n        for (var r = 0, s = e - 1, o = i ? 0 : s - 1; i ? o < s : 0 <= o; i ? o++ : o--) {\n          var h = n[o],\n              u = n[o + 1],\n              a = new p(h, u),\n              c = h.distance(u);\n          if (t <= r + c) return a.pointAtLength((i ? 1 : -1) * (t - r));\n          r += c;\n        }\n\n        return (i ? n[e - 1] : n[0]).clone();\n      },\n      scale: function scale(t, n, e) {\n        var i = this.points,\n            r = i.length;\n        if (0 === r) return this;\n\n        for (var s = 0; s < r; s++) {\n          i[s].scale(t, n, e);\n        }\n\n        return this;\n      },\n      tangentAt: function tangentAt(t) {\n        var n = this.points.length;\n        if (0 === n) return null;\n        if (1 === n) return null;\n        t < 0 && (t = 0), 1 < t && (t = 1);\n        var e = this.length() * t;\n        return this.tangentAtLength(e);\n      },\n      tangentAtLength: function tangentAtLength(t) {\n        var n = this.points,\n            e = n.length;\n        if (0 === e) return null;\n        if (1 === e) return null;\n        var i,\n            r = !0;\n        t < 0 && (r = !1, t = -t);\n\n        for (var s = 0, o = e - 1, h = r ? 0 : o - 1; r ? h < o : 0 <= h; r ? h++ : h--) {\n          var u = n[h],\n              a = n[h + 1],\n              c = new p(u, a),\n              l = u.distance(a);\n\n          if (c.isDifferentiable()) {\n            if (t <= s + l) return c.tangentAtLength((r ? 1 : -1) * (t - s));\n            i = c;\n          }\n\n          s += l;\n        }\n\n        if (i) {\n          var f = r ? 1 : 0;\n          return i.tangentAt(f);\n        }\n\n        return null;\n      },\n      toString: function toString() {\n        return this.points + \"\";\n      },\n      translate: function translate(t, n) {\n        var e = this.points,\n            i = e.length;\n        if (0 === i) return this;\n\n        for (var r = 0; r < i; r++) {\n          e[r].translate(t, n);\n        }\n\n        return this;\n      },\n      serialize: function serialize() {\n        var t = this.points,\n            n = t.length;\n        if (0 === n) return \"\";\n\n        for (var e = \"\", i = 0; i < n; i++) {\n          var r = t[i];\n          e += r.x + \",\" + r.y + \" \";\n        }\n\n        return e.trim();\n      }\n    }, Object.defineProperty(T.prototype, \"start\", {\n      configurable: !0,\n      enumerable: !0,\n      get: function get() {\n        return 0 === this.points.length ? null : this.points[0];\n      }\n    }), Object.defineProperty(T.prototype, \"end\", {\n      configurable: !0,\n      enumerable: !0,\n      get: function get() {\n        var t = this.points.length;\n        return 0 === t ? null : this.points[t - 1];\n      }\n    });\n\n    var M = o.Rect = function (t, n, e, i) {\n      if (!(this instanceof M)) return new M(t, n, e, i);\n      Object(t) === t && (n = t.y, e = t.width, i = t.height, t = t.x), this.x = void 0 === t ? 0 : t, this.y = void 0 === n ? 0 : n, this.width = void 0 === e ? 0 : e, this.height = void 0 === i ? 0 : i;\n    };\n\n    M.fromEllipse = function (t) {\n      return t = new i(t), new M(t.x - t.a, t.y - t.b, 2 * t.a, 2 * t.b);\n    }, M.prototype = {\n      bbox: function bbox(t) {\n        if (!t) return this.clone();\n        var n = w(t),\n            e = R(a(n)),\n            i = R(u(n)),\n            r = this.width * i + this.height * e,\n            s = this.width * e + this.height * i;\n        return new M(this.x + (this.width - r) / 2, this.y + (this.height - s) / 2, r, s);\n      },\n      bottomLeft: function bottomLeft() {\n        return new y(this.x, this.y + this.height);\n      },\n      bottomLine: function bottomLine() {\n        return new p(this.bottomLeft(), this.bottomRight());\n      },\n      bottomMiddle: function bottomMiddle() {\n        return new y(this.x + this.width / 2, this.y + this.height);\n      },\n      center: function center() {\n        return new y(this.x + this.width / 2, this.y + this.height / 2);\n      },\n      clone: function clone() {\n        return new M(this);\n      },\n      containsPoint: function containsPoint(t) {\n        return (t = new y(t)).x >= this.x && t.x <= this.x + this.width && t.y >= this.y && t.y <= this.y + this.height;\n      },\n      containsRect: function containsRect(t) {\n        var n = new M(this).normalize(),\n            e = new M(t).normalize(),\n            i = n.width,\n            r = n.height,\n            s = e.width,\n            o = e.height;\n        if (!(i && r && s && o)) return !1;\n        var h = n.x,\n            u = n.y,\n            a = e.x,\n            c = e.y;\n        return s += a, i += h, o += c, r += u, h <= a && s <= i && u <= c && o <= r;\n      },\n      corner: function corner() {\n        return new y(this.x + this.width, this.y + this.height);\n      },\n      equals: function equals(t) {\n        var n = new M(this).normalize(),\n            e = new M(t).normalize();\n        return n.x === e.x && n.y === e.y && n.width === e.width && n.height === e.height;\n      },\n      inflate: function inflate(t, n) {\n        return void 0 === t && (t = 0), void 0 === n && (n = t), this.x -= t, this.y -= n, this.width += 2 * t, this.height += 2 * n, this;\n      },\n      intersect: function intersect(t) {\n        var n = this.origin(),\n            e = this.corner(),\n            i = t.origin(),\n            r = t.corner();\n        if (r.x <= n.x || r.y <= n.y || i.x >= e.x || i.y >= e.y) return null;\n        var s = j(n.x, i.x),\n            o = j(n.y, i.y);\n        return new M(s, o, z(e.x, r.x) - s, z(e.y, r.y) - o);\n      },\n      intersectionWithLine: function intersectionWithLine(t) {\n        var n,\n            e,\n            i = [this.topLine(), this.rightLine(), this.bottomLine(), this.leftLine()],\n            r = [],\n            s = [],\n            o = i.length;\n\n        for (e = 0; e < o; e++) {\n          null !== (n = t.intersect(i[e])) && s.indexOf(n.toString()) < 0 && (r.push(n), s.push(n.toString()));\n        }\n\n        return 0 < r.length ? r : null;\n      },\n      intersectionWithLineFromCenterToPoint: function intersectionWithLineFromCenterToPoint(t, n) {\n        t = new y(t);\n        var e,\n            i = new y(this.x + this.width / 2, this.y + this.height / 2);\n        n && t.rotate(i, n);\n\n        for (var r = [this.topLine(), this.rightLine(), this.bottomLine(), this.leftLine()], s = new p(i, t), o = r.length - 1; 0 <= o; --o) {\n          var h = r[o].intersection(s);\n\n          if (null !== h) {\n            e = h;\n            break;\n          }\n        }\n\n        return e && n && e.rotate(i, -n), e;\n      },\n      leftLine: function leftLine() {\n        return new p(this.topLeft(), this.bottomLeft());\n      },\n      leftMiddle: function leftMiddle() {\n        return new y(this.x, this.y + this.height / 2);\n      },\n      maxRectScaleToFit: function maxRectScaleToFit(t, n) {\n        var e, i, r, s, o, h, u, a;\n        t = new M(t), n || (n = t.center());\n        var c = n.x,\n            l = n.y;\n        e = i = r = s = o = h = u = a = 1 / 0;\n        var f = t.topLeft();\n        f.x < c && (e = (this.x - c) / (f.x - c)), f.y < l && (o = (this.y - l) / (f.y - l));\n        var g = t.bottomRight();\n        g.x > c && (i = (this.x + this.width - c) / (g.x - c)), g.y > l && (h = (this.y + this.height - l) / (g.y - l));\n        var p = t.topRight();\n        p.x > c && (r = (this.x + this.width - c) / (p.x - c)), p.y < l && (u = (this.y - l) / (p.y - l));\n        var d = t.bottomLeft();\n        return d.x < c && (s = (this.x - c) / (d.x - c)), d.y > l && (a = (this.y + this.height - l) / (d.y - l)), {\n          sx: z(e, i, r, s),\n          sy: z(o, h, u, a)\n        };\n      },\n      maxRectUniformScaleToFit: function maxRectUniformScaleToFit(t, n) {\n        var e = this.maxRectScaleToFit(t, n);\n        return z(e.sx, e.sy);\n      },\n      moveAndExpand: function moveAndExpand(t) {\n        return this.x += t.x || 0, this.y += t.y || 0, this.width += t.width || 0, this.height += t.height || 0, this;\n      },\n      normalize: function normalize() {\n        var t = this.x,\n            n = this.y,\n            e = this.width,\n            i = this.height;\n        return this.width < 0 && (t = this.x + this.width, e = -this.width), this.height < 0 && (n = this.y + this.height, i = -this.height), this.x = t, this.y = n, this.width = e, this.height = i, this;\n      },\n      offset: function offset(t, n) {\n        return y.prototype.offset.call(this, t, n);\n      },\n      origin: function origin() {\n        return new y(this.x, this.y);\n      },\n      pointNearestToPoint: function pointNearestToPoint(t) {\n        if (t = new y(t), this.containsPoint(t)) switch (this.sideNearestToPoint(t)) {\n          case \"right\":\n            return new y(this.x + this.width, t.y);\n\n          case \"left\":\n            return new y(this.x, t.y);\n\n          case \"bottom\":\n            return new y(t.x, this.y + this.height);\n\n          case \"top\":\n            return new y(t.x, this.y);\n        }\n        return t.adhereToRect(this);\n      },\n      rightLine: function rightLine() {\n        return new p(this.topRight(), this.bottomRight());\n      },\n      rightMiddle: function rightMiddle() {\n        return new y(this.x + this.width, this.y + this.height / 2);\n      },\n      round: function round(t) {\n        var n = E(10, t || 0);\n        return this.x = e(this.x * n) / n, this.y = e(this.y * n) / n, this.width = e(this.width * n) / n, this.height = e(this.height * n) / n, this;\n      },\n      scale: function scale(t, n, e) {\n        return e = this.origin().scale(t, n, e), this.x = e.x, this.y = e.y, this.width *= t, this.height *= n, this;\n      },\n      sideNearestToPoint: function sideNearestToPoint(t) {\n        var n = (t = new y(t)).x - this.x,\n            e = this.x + this.width - t.x,\n            i = t.y - this.y,\n            r = n,\n            s = \"left\";\n        return e < r && (r = e, s = \"right\"), i < r && (r = i, s = \"top\"), this.y + this.height - t.y < r && (s = \"bottom\"), s;\n      },\n      snapToGrid: function snapToGrid(t, n) {\n        var e = this.origin().snapToGrid(t, n),\n            i = this.corner().snapToGrid(t, n);\n        return this.x = e.x, this.y = e.y, this.width = i.x - e.x, this.height = i.y - e.y, this;\n      },\n      toJSON: function toJSON() {\n        return {\n          x: this.x,\n          y: this.y,\n          width: this.width,\n          height: this.height\n        };\n      },\n      topLine: function topLine() {\n        return new p(this.topLeft(), this.topRight());\n      },\n      topMiddle: function topMiddle() {\n        return new y(this.x + this.width / 2, this.y);\n      },\n      topRight: function topRight() {\n        return new y(this.x + this.width, this.y);\n      },\n      toString: function toString() {\n        return this.origin().toString() + \" \" + this.corner().toString();\n      },\n      union: function union(t) {\n        t = new M(t);\n        var n = this.origin(),\n            e = this.corner(),\n            i = t.origin(),\n            r = t.corner(),\n            s = z(n.x, i.x),\n            o = z(n.y, i.y),\n            h = j(e.x, r.x),\n            u = j(e.y, r.y);\n        return new M(s, o, h - s, u - o);\n      }\n    }, M.prototype.bottomRight = M.prototype.corner, M.prototype.topLeft = M.prototype.origin, M.prototype.translate = M.prototype.offset, o.scale = {\n      linear: function linear(t, n, e) {\n        var i = t[1] - t[0],\n            r = n[1] - n[0];\n        return (e - t[0]) / i * r + n[0] || 0;\n      }\n    };\n\n    var f = o.normalizeAngle = function (t) {\n      return t % 360 + (t < 0 ? 360 : 0);\n    },\n        d = o.snapToGrid = function (t, n) {\n      return n * e(t / n);\n    },\n        v = o.toDeg = function (t) {\n      return 180 * t / s % 360;\n    },\n        w = o.toRad = function (t, n) {\n      return (t = (n = n || !1) ? t : t % 360) * s / 180;\n    };\n\n    function m(t, n) {\n      return n.unshift(null), new (Function.prototype.bind.apply(t, n))();\n    }\n\n    function n(t) {\n      var n,\n          e,\n          i = [];\n\n      for (e = arguments.length, n = 1; n < e; n++) {\n        i.push(arguments[n]);\n      }\n\n      if (!t) throw new Error(\"Missing a parent object.\");\n      var r = Object.create(t);\n\n      for (e = i.length, n = 0; n < e; n++) {\n        var s,\n            o,\n            h = i[n];\n\n        for (o in h) {\n          h.hasOwnProperty(o) && (delete r[o], s = Object.getOwnPropertyDescriptor(h, o), Object.defineProperty(r, o, s));\n        }\n      }\n\n      return r;\n    }\n\n    o.ellipse = o.Ellipse, o.line = o.Line, o.point = o.Point, o.rect = o.Rect;\n    var x = {\n      bbox: function bbox() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      },\n      clone: function clone() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      },\n      closestPoint: function closestPoint() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      },\n      closestPointLength: function closestPointLength() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      },\n      closestPointNormalizedLength: function closestPointNormalizedLength() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      },\n      closestPointT: function closestPointT(t) {\n        if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(t);\n        throw new Error(\"Neither closestPointT() nor closestPointNormalizedLength() function is implemented.\");\n      },\n      closestPointTangent: function closestPointTangent() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      },\n      equals: function equals() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      },\n      getSubdivisions: function getSubdivisions() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      },\n      isDifferentiable: function isDifferentiable() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      },\n      isSegment: !0,\n      isSubpathStart: !1,\n      isVisible: !0,\n      length: function length() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      },\n      lengthAtT: function lengthAtT(t) {\n        if (t <= 0) return 0;\n        var n = this.length();\n        return 1 <= t ? n : n * t;\n      },\n      nextSegment: null,\n      pointAt: function pointAt() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      },\n      pointAtLength: function pointAtLength() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      },\n      pointAtT: function pointAtT(t) {\n        if (this.pointAt) return this.pointAt(t);\n        throw new Error(\"Neither pointAtT() nor pointAt() function is implemented.\");\n      },\n      previousSegment: null,\n      subpathStartSegment: null,\n      scale: function scale() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      },\n      serialize: function serialize() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      },\n      tangentAt: function tangentAt() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      },\n      tangentAtLength: function tangentAtLength() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      },\n      tangentAtT: function tangentAtT(t) {\n        if (this.tangentAt) return this.tangentAt(t);\n        throw new Error(\"Neither tangentAtT() nor tangentAt() function is implemented.\");\n      },\n      toString: function toString() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      },\n      translate: function translate() {\n        throw new Error(\"Declaration missing for virtual function.\");\n      }\n    };\n    Object.defineProperty(x, \"end\", {\n      configurable: !0,\n      enumerable: !0,\n      writable: !0\n    }), Object.defineProperty(x, \"start\", {\n      configurable: !0,\n      enumerable: !0,\n      get: function get() {\n        if (!this.previousSegment) throw new Error(\"Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)\");\n        return this.previousSegment.end;\n      }\n    }), Object.defineProperty(x, \"type\", {\n      configurable: !0,\n      enumerable: !0,\n      get: function get() {\n        throw new Error(\"Bad segment declaration. No type specified.\");\n      }\n    });\n\n    var b = function b() {\n      for (var t, n, e = [], i = arguments.length, r = 0; r < i; r++) {\n        e.push(arguments[r]);\n      }\n\n      if (!(this instanceof b)) return m(b, e);\n      if (0 === i) throw new Error(\"Lineto constructor expects 1 point or 2 coordinates (none provided).\");\n\n      if (\"string\" == typeof e[0] || \"number\" == typeof e[0]) {\n        if (2 === i) return this.end = new y(+e[0], +e[1]), this;\n        if (i < 2) throw new Error(\"Lineto constructor expects 1 point or 2 coordinates (\" + i + \" coordinates provided).\");\n        var s;\n\n        for (t = [], r = 0; r < i; r += 2) {\n          s = e.slice(r, r + 2), t.push(m(b, s));\n        }\n\n        return t;\n      }\n\n      if (1 === i) return this.end = new y(e[0]), this;\n\n      for (t = [], r = 0; r < i; r += 1) {\n        n = e[r], t.push(new b(n));\n      }\n\n      return t;\n    },\n        S = {\n      clone: function clone() {\n        return new b(this.end);\n      },\n      getSubdivisions: function getSubdivisions() {\n        return [];\n      },\n      isDifferentiable: function isDifferentiable() {\n        return !!this.previousSegment && !this.start.equals(this.end);\n      },\n      scale: function scale(t, n, e) {\n        return this.end.scale(t, n, e), this;\n      },\n      serialize: function serialize() {\n        var t = this.end;\n        return this.type + \" \" + t.x + \" \" + t.y;\n      },\n      toString: function toString() {\n        return this.type + \" \" + this.start + \" \" + this.end;\n      },\n      translate: function translate(t, n) {\n        return this.end.translate(t, n), this;\n      }\n    };\n\n    Object.defineProperty(S, \"type\", {\n      configurable: !0,\n      enumerable: !0,\n      value: \"L\"\n    }), b.prototype = n(x, p.prototype, S);\n\n    var P = function P() {\n      for (var t, n, e = [], i = arguments.length, r = 0; r < i; r++) {\n        e.push(arguments[r]);\n      }\n\n      if (!(this instanceof P)) return m(P, e);\n      if (0 === i) throw new Error(\"Curveto constructor expects 3 points or 6 coordinates (none provided).\");\n\n      if (\"string\" == typeof e[0] || \"number\" == typeof e[0]) {\n        if (6 === i) return this.controlPoint1 = new y(+e[0], +e[1]), this.controlPoint2 = new y(+e[2], +e[3]), this.end = new y(+e[4], +e[5]), this;\n        if (i < 6) throw new Error(\"Curveto constructor expects 3 points or 6 coordinates (\" + i + \" coordinates provided).\");\n        var s;\n\n        for (t = [], r = 0; r < i; r += 6) {\n          s = e.slice(r, r + 6), t.push(m(P, s));\n        }\n\n        return t;\n      }\n\n      if (3 === i) return this.controlPoint1 = new y(e[0]), this.controlPoint2 = new y(e[1]), this.end = new y(e[2]), this;\n      if (i < 3) throw new Error(\"Curveto constructor expects 3 points or 6 coordinates (\" + i + \" points provided).\");\n\n      for (t = [], r = 0; r < i; r += 3) {\n        n = e.slice(r, r + 3), t.push(m(P, n));\n      }\n\n      return t;\n    },\n        A = {\n      clone: function clone() {\n        return new P(this.controlPoint1, this.controlPoint2, this.end);\n      },\n      isDifferentiable: function isDifferentiable() {\n        if (!this.previousSegment) return !1;\n        var t = this.start,\n            n = this.controlPoint1,\n            e = this.controlPoint2,\n            i = this.end;\n        return !(t.equals(n) && n.equals(e) && e.equals(i));\n      },\n      scale: function scale(t, n, e) {\n        return this.controlPoint1.scale(t, n, e), this.controlPoint2.scale(t, n, e), this.end.scale(t, n, e), this;\n      },\n      serialize: function serialize() {\n        var t = this.controlPoint1,\n            n = this.controlPoint2,\n            e = this.end;\n        return this.type + \" \" + t.x + \" \" + t.y + \" \" + n.x + \" \" + n.y + \" \" + e.x + \" \" + e.y;\n      },\n      toString: function toString() {\n        return this.type + \" \" + this.start + \" \" + this.controlPoint1 + \" \" + this.controlPoint2 + \" \" + this.end;\n      },\n      translate: function translate(t, n) {\n        return this.controlPoint1.translate(t, n), this.controlPoint2.translate(t, n), this.end.translate(t, n), this;\n      }\n    };\n\n    Object.defineProperty(A, \"type\", {\n      configurable: !0,\n      enumerable: !0,\n      value: \"C\"\n    }), P.prototype = n(x, g.prototype, A);\n\n    var L = function L() {\n      for (var t, n, e = [], i = arguments.length, r = 0; r < i; r++) {\n        e.push(arguments[r]);\n      }\n\n      if (!(this instanceof L)) return m(L, e);\n      if (0 === i) throw new Error(\"Moveto constructor expects 1 point or 2 coordinates (none provided).\");\n\n      if (\"string\" == typeof e[0] || \"number\" == typeof e[0]) {\n        if (2 === i) return this.end = new y(+e[0], +e[1]), this;\n        if (i < 2) throw new Error(\"Moveto constructor expects 1 point or 2 coordinates (\" + i + \" coordinates provided).\");\n        var s;\n\n        for (t = [], r = 0; r < i; r += 2) {\n          s = e.slice(r, r + 2), 0 === r ? t.push(m(L, s)) : t.push(m(b, s));\n        }\n\n        return t;\n      }\n\n      if (1 === i) return this.end = new y(e[0]), this;\n\n      for (t = [], r = 0; r < i; r += 1) {\n        n = e[r], 0 === r ? t.push(new L(n)) : t.push(new b(n));\n      }\n\n      return t;\n    },\n        I = {\n      bbox: function bbox() {\n        return null;\n      },\n      clone: function clone() {\n        return new L(this.end);\n      },\n      closestPoint: function closestPoint() {\n        return this.end.clone();\n      },\n      closestPointNormalizedLength: function closestPointNormalizedLength() {\n        return 0;\n      },\n      closestPointLength: function closestPointLength() {\n        return 0;\n      },\n      closestPointT: function closestPointT() {\n        return 1;\n      },\n      closestPointTangent: function closestPointTangent() {\n        return null;\n      },\n      equals: function equals(t) {\n        return this.end.equals(t.end);\n      },\n      getSubdivisions: function getSubdivisions() {\n        return [];\n      },\n      isDifferentiable: function isDifferentiable() {\n        return !1;\n      },\n      isSubpathStart: !0,\n      isVisible: !1,\n      length: function length() {\n        return 0;\n      },\n      lengthAtT: function lengthAtT() {\n        return 0;\n      },\n      pointAt: function pointAt() {\n        return this.end.clone();\n      },\n      pointAtLength: function pointAtLength() {\n        return this.end.clone();\n      },\n      pointAtT: function pointAtT() {\n        return this.end.clone();\n      },\n      scale: function scale(t, n, e) {\n        return this.end.scale(t, n, e), this;\n      },\n      serialize: function serialize() {\n        var t = this.end;\n        return this.type + \" \" + t.x + \" \" + t.y;\n      },\n      tangentAt: function tangentAt() {\n        return null;\n      },\n      tangentAtLength: function tangentAtLength() {\n        return null;\n      },\n      tangentAtT: function tangentAtT() {\n        return null;\n      },\n      toString: function toString() {\n        return this.type + \" \" + this.end;\n      },\n      translate: function translate(t, n) {\n        return this.end.translate(t, n), this;\n      }\n    };\n\n    Object.defineProperty(I, \"start\", {\n      configurable: !0,\n      enumerable: !0,\n      get: function get() {\n        throw new Error(\"Illegal access. Moveto segments should not need a start property.\");\n      }\n    }), Object.defineProperty(I, \"type\", {\n      configurable: !0,\n      enumerable: !0,\n      value: \"M\"\n    }), L.prototype = n(x, I);\n\n    var C = function C() {\n      for (var t = [], n = arguments.length, e = 0; e < n; e++) {\n        t.push(arguments[e]);\n      }\n\n      if (!(this instanceof C)) return m(C, t);\n      if (0 < n) throw new Error(\"Closepath constructor expects no arguments.\");\n      return this;\n    },\n        N = {\n      clone: function clone() {\n        return new C();\n      },\n      getSubdivisions: function getSubdivisions() {\n        return [];\n      },\n      isDifferentiable: function isDifferentiable() {\n        return !(!this.previousSegment || !this.subpathStartSegment) && !this.start.equals(this.end);\n      },\n      scale: function scale() {\n        return this;\n      },\n      serialize: function serialize() {\n        return this.type;\n      },\n      toString: function toString() {\n        return this.type + \" \" + this.start + \" \" + this.end;\n      },\n      translate: function translate() {\n        return this;\n      }\n    };\n\n    Object.defineProperty(N, \"end\", {\n      configurable: !0,\n      enumerable: !0,\n      get: function get() {\n        if (!this.subpathStartSegment) throw new Error(\"Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)\");\n        return this.subpathStartSegment.end;\n      }\n    }), Object.defineProperty(N, \"type\", {\n      configurable: !0,\n      enumerable: !0,\n      value: \"Z\"\n    }), C.prototype = n(x, p.prototype, N);\n    var O = l.segmentTypes = {\n      L: b,\n      C: P,\n      M: L,\n      Z: C,\n      z: C\n    };\n    l.regexSupportedData = new RegExp(\"^[\\\\s\\\\d\" + Object.keys(O).join(\"\") + \",.]*$\"), l.isDataSupported = function (t) {\n      return \"string\" == typeof t && this.regexSupportedData.test(t);\n    };\n  }(g);\n  var V, Vectorizer;\n\n  V = Vectorizer = function () {\n    \"use strict\";\n\n    if (!(\"object\" == typeof window && !(!window.SVGAngle && !document.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#BasicStructure\", \"1.1\")))) return function () {\n      throw new Error(\"SVG is required to use Vectorizer.\");\n    };\n\n    var c = {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      xml: \"http://www.w3.org/XML/1998/namespace\",\n      xlink: \"http://www.w3.org/1999/xlink\",\n      xhtml: \"http://www.w3.org/1999/xhtml\"\n    },\n        t = Math,\n        v = t.PI,\n        i = t.atan2,\n        s = t.sqrt,\n        h = t.min,\n        f = t.max,\n        p = t.cos,\n        x = t.sin,\n        N = function N(t, e, r) {\n      if (!(this instanceof N)) return N.apply(Object.create(N.prototype), arguments);\n\n      if (t) {\n        if (N.isV(t) && (t = t.node), e = e || {}, N.isString(t)) {\n          if (\"svg\" === t.toLowerCase()) t = N.createSvgDocument();else if (\"<\" === t[0]) {\n            var n = N.createSvgDocument(t);\n\n            if (1 < n.childNodes.length) {\n              var a,\n                  i,\n                  s = [];\n\n              for (a = 0, i = n.childNodes.length; a < i; a++) {\n                var o = n.childNodes[a];\n                s.push(new N(document.importNode(o, !0)));\n              }\n\n              return s;\n            }\n\n            t = document.importNode(n.firstChild, !0);\n          } else t = document.createElementNS(c.xmlns, t);\n          N.ensureId(t);\n        }\n\n        return this.node = t, this.setAttributes(e), r && this.append(r), this;\n      }\n    },\n        e = N.prototype;\n\n    function V(t, e, r) {\n      r || (r = {});\n\n      for (var n = r.includeAnnotationIndices, a = r.eol, i = r.lineHeight, s = r.baseSize, o = 0, c = {}, l = e.length - 1, u = 0; u <= l; u++) {\n        var h = e[u],\n            f = null;\n\n        if (N.isObject(h)) {\n          var d = h.attrs,\n              m = N(\"tspan\", d),\n              v = m.node,\n              g = h.t;\n          a && u === l && (g += a), v.textContent = g;\n          var p = d.class;\n          p && m.addClass(p), n && m.attr(\"annotations\", h.annotations), void 0 === (f = parseFloat(d[\"font-size\"])) && (f = s), f && o < f && (o = f);\n        } else a && u === l && (h += a), v = document.createTextNode(h || \" \"), s && o < s && (o = s);\n\n        t.appendChild(v);\n      }\n\n      return o && (c.maxFontSize = o), i ? c.lineHeight = i : o && (c.lineHeight = 1.2 * o), c;\n    }\n\n    Object.defineProperty(e, \"id\", {\n      enumerable: !0,\n      get: function get() {\n        return this.node.id;\n      },\n      set: function set(t) {\n        this.node.id = t;\n      }\n    }), e.getTransformToElement = function (t) {\n      var e = this.node;\n\n      if (N.isSVGGraphicsElement(t) && N.isSVGGraphicsElement(e)) {\n        var r = N.toNode(t).getScreenCTM(),\n            n = e.getScreenCTM();\n        if (r && n) return r.inverse().multiply(n);\n      }\n\n      return N.createSVGMatrix();\n    }, e.transform = function (t, e) {\n      var r = this.node;\n      if (N.isUndefined(t)) return N.transformStringToMatrix(this.attr(\"transform\"));\n      if (e && e.absolute) return this.attr(\"transform\", N.matrixToTransformString(t));\n      var n = N.createSVGTransform(t);\n      return r.transform.baseVal.appendItem(n), this;\n    }, e.translate = function (t, e, r) {\n      r = r || {}, e = e || 0;\n      var n = this.attr(\"transform\") || \"\",\n          a = N.parseTransformString(n);\n      if (n = a.value, N.isUndefined(t)) return a.translate;\n      n = n.replace(/translate\\([^)]*\\)/g, \"\").trim();\n      var i = \"translate(\" + (r.absolute ? t : a.translate.tx + t) + \",\" + (r.absolute ? e : a.translate.ty + e) + \")\";\n      return this.attr(\"transform\", (i + \" \" + n).trim()), this;\n    }, e.rotate = function (t, e, r, n) {\n      n = n || {};\n      var a = this.attr(\"transform\") || \"\",\n          i = N.parseTransformString(a);\n      if (a = i.value, N.isUndefined(t)) return i.rotate;\n      a = a.replace(/rotate\\([^)]*\\)/g, \"\").trim(), t %= 360;\n      var s = \"rotate(\" + (n.absolute ? t : i.rotate.angle + t) + (void 0 !== e && void 0 !== r ? \",\" + e + \",\" + r : \"\") + \")\";\n      return this.attr(\"transform\", (a + \" \" + s).trim()), this;\n    }, e.scale = function (t, e) {\n      e = N.isUndefined(e) ? t : e;\n      var r = this.attr(\"transform\") || \"\",\n          n = N.parseTransformString(r);\n      if (r = n.value, N.isUndefined(t)) return n.scale;\n      r = r.replace(/scale\\([^)]*\\)/g, \"\").trim();\n      var a = \"scale(\" + t + \",\" + e + \")\";\n      return this.attr(\"transform\", (r + \" \" + a).trim()), this;\n    }, e.bbox = function (t, e) {\n      var r,\n          n = this.node,\n          a = n.ownerSVGElement;\n      if (!a) return new g.Rect(0, 0, 0, 0);\n\n      try {\n        r = n.getBBox();\n      } catch (t) {\n        r = {\n          x: n.clientLeft,\n          y: n.clientTop,\n          width: n.clientWidth,\n          height: n.clientHeight\n        };\n      }\n\n      if (t) return new g.Rect(r);\n      var i = this.getTransformToElement(e || a);\n      return N.transformRect(r, i);\n    }, e.getBBox = function (t) {\n      var e,\n          r = {},\n          n = this.node;\n      if (!n.ownerSVGElement || !N.isSVGGraphicsElement(n)) return new g.Rect(0, 0, 0, 0);\n\n      if (t && (t.target && (r.target = N.toNode(t.target)), t.recursive && (r.recursive = t.recursive)), r.recursive) {\n        var a = this.children(),\n            i = a.length;\n        if (0 === i) return this.getBBox({\n          target: r.target,\n          recursive: !1\n        });\n        r.target || (r.target = this);\n\n        for (var s = 0; s < i; s++) {\n          var o,\n              c = a[s];\n          o = 0 === c.children().length ? c.getBBox({\n            target: r.target,\n            recursive: !1\n          }) : c.getBBox({\n            target: r.target,\n            recursive: !0\n          }), e = e ? e.union(o) : o;\n        }\n\n        return e;\n      }\n\n      try {\n        e = n.getBBox();\n      } catch (t) {\n        e = {\n          x: n.clientLeft,\n          y: n.clientTop,\n          width: n.clientWidth,\n          height: n.clientHeight\n        };\n      }\n\n      if (r.target) {\n        var l = this.getTransformToElement(r.target);\n        return N.transformRect(e, l);\n      }\n\n      return new g.Rect(e);\n    };\n    var L = /em$/;\n\n    function M(t, e) {\n      var r = parseFloat(t);\n      return L.test(t) ? r * e : r;\n    }\n\n    e.text = function (t, e) {\n      if (t && \"string\" != typeof t) throw new Error(\"Vectorizer: text() expects the first argument to be a string.\");\n      t = N.sanitizeText(t), e || (e = {});\n      var r = e.eol,\n          n = e.textPath,\n          a = e.textVerticalAnchor,\n          i = \"middle\" === a || \"bottom\" === a || \"top\" === a,\n          s = e.x;\n      void 0 === s && (s = this.attr(\"x\") || 0);\n      var o = e.includeAnnotationIndices,\n          c = e.annotations;\n      c && !N.isArray(c) && (c = [c]);\n      var l = e.lineHeight,\n          u = \"auto\" === l,\n          h = u ? \"1.5em\" : l || \"1em\";\n      this.empty(), this.attr({\n        \"xml:space\": \"preserve\",\n        display: t ? null : \"none\"\n      });\n      var f = parseFloat(this.attr(\"font-size\"));\n      f || (f = 16, (i || c) && this.attr(\"font-size\", f));\n      var d,\n          m = document;\n      d = n ? (\"string\" == typeof n && (n = {\n        d: n\n      }), function (t, e) {\n        t || (t = {});\n        var r = N(\"textPath\"),\n            n = t.d;\n\n        if (n && void 0 === t[\"xlink:href\"]) {\n          var a = N(\"path\").attr(\"d\", n).appendTo(e.defs());\n          r.attr(\"xlink:href\", \"#\" + a.id);\n        }\n\n        return N.isObject(t) && r.attr(t), r.node;\n      }(n, this)) : m.createDocumentFragment();\n\n      for (var v, g = 0, p = t.split(\"\\n\"), x = [], y = 0, T = p.length - 1; y <= T; y++) {\n        var b,\n            P = h,\n            w = \"v-line\",\n            A = m.createElementNS(N.namespace.xmlns, \"tspan\"),\n            S = p[y];\n        if (S) {\n          if (c) {\n            var F = (b = V(A, N.annotateString(S, c, {\n              offset: -g,\n              includeAnnotationIndices: o\n            }), {\n              includeAnnotationIndices: o,\n              eol: y !== T && r,\n              lineHeight: u ? null : h,\n              baseSize: f\n            })).lineHeight;\n            F && u && 0 !== y && (P = F), 0 === y && (v = .8 * b.maxFontSize);\n          } else r && y !== T && (S += r), A.textContent = S;\n        } else {\n          A.textContent = \"-\", w += \" v-empty-line\";\n          var C = A.style;\n          C.fillOpacity = 0, C.strokeOpacity = 0, c && (b = {});\n        }\n        b && x.push(b), 0 < y && A.setAttribute(\"dy\", P), (0 < y || n) && A.setAttribute(\"x\", s), A.className.baseVal = w, d.appendChild(A), g += S.length + 1;\n      }\n\n      if (i) {\n        if (c) P = function (t, e, r, n) {\n          if (!Array.isArray(e)) return 0;\n          var a = e.length;\n          if (!a) return 0;\n\n          for (var i = e[0], s = M(i.maxFontSize, r) || r, o = 0, c = M(n, r), l = 1; l < a; l++) {\n            o += M((i = e[l]).lineHeight, r) || c;\n          }\n\n          var u,\n              h = M(i.maxFontSize, r) || r;\n\n          switch (t) {\n            case \"middle\":\n              u = s / 2 - .15 * h - o / 2;\n              break;\n\n            case \"bottom\":\n              u = -.25 * h - o;\n              break;\n\n            default:\n            case \"top\":\n              u = .8 * s;\n          }\n\n          return u;\n        }(a, x, f, h);else if (\"top\" === a) P = \"0.8em\";else {\n          var E;\n\n          switch (0 < T ? (E = parseFloat(h) || 1, E *= T, L.test(h) || (E /= f)) : E = 0, a) {\n            case \"middle\":\n              P = .3 - E / 2 + \"em\";\n              break;\n\n            case \"bottom\":\n              P = -E - .3 + \"em\";\n          }\n        }\n      } else 0 === a ? P = \"0em\" : a ? P = a : (P = 0, null === this.attr(\"y\") && this.attr(\"y\", v || \"0.8em\"));\n      return d.firstChild.setAttribute(\"dy\", P), this.append(d), this;\n    }, e.removeAttr = function (t) {\n      var e = N.qualifyAttr(t),\n          r = this.node;\n      return e.ns ? r.hasAttributeNS(e.ns, e.local) && r.removeAttributeNS(e.ns, e.local) : r.hasAttribute(t) && r.removeAttribute(t), this;\n    }, e.attr = function (t, e) {\n      if (N.isUndefined(t)) {\n        for (var r = this.node.attributes, n = {}, a = 0; a < r.length; a++) {\n          n[r[a].name] = r[a].value;\n        }\n\n        return n;\n      }\n\n      if (N.isString(t) && N.isUndefined(e)) return this.node.getAttribute(t);\n      if (\"object\" == typeof t) for (var i in t) {\n        t.hasOwnProperty(i) && this.setAttribute(i, t[i]);\n      } else this.setAttribute(t, e);\n      return this;\n    }, e.normalizePath = function () {\n      return \"PATH\" === this.tagName() && this.attr(\"d\", N.normalizePathData(this.attr(\"d\"))), this;\n    }, e.remove = function () {\n      return this.node.parentNode && this.node.parentNode.removeChild(this.node), this;\n    }, e.empty = function () {\n      for (; this.node.firstChild;) {\n        this.node.removeChild(this.node.firstChild);\n      }\n\n      return this;\n    }, e.setAttributes = function (t) {\n      for (var e in t) {\n        t.hasOwnProperty(e) && this.setAttribute(e, t[e]);\n      }\n\n      return this;\n    }, e.append = function (t) {\n      N.isArray(t) || (t = [t]);\n\n      for (var e = 0, r = t.length; e < r; e++) {\n        this.node.appendChild(N.toNode(t[e]));\n      }\n\n      return this;\n    }, e.prepend = function (t) {\n      var e = this.node.firstChild;\n      return e ? N(e).before(t) : this.append(t);\n    }, e.before = function (t) {\n      var e = this.node,\n          r = e.parentNode;\n\n      if (r) {\n        N.isArray(t) || (t = [t]);\n\n        for (var n = 0, a = t.length; n < a; n++) {\n          r.insertBefore(N.toNode(t[n]), e);\n        }\n      }\n\n      return this;\n    }, e.appendTo = function (t) {\n      return N.toNode(t).appendChild(this.node), this;\n    }, e.svg = function () {\n      return this.node instanceof window.SVGSVGElement ? this : N(this.node.ownerSVGElement);\n    }, e.tagName = function () {\n      return this.node.tagName.toUpperCase();\n    }, e.defs = function () {\n      var t = this.svg() || this,\n          e = t.node.getElementsByTagName(\"defs\")[0];\n      return e ? N(e) : N(\"defs\").appendTo(t);\n    }, e.clone = function () {\n      var t = N(this.node.cloneNode(!0));\n      return t.node.id = N.uniqueId(), t;\n    }, e.findOne = function (t) {\n      var e = this.node.querySelector(t);\n      return e ? N(e) : void 0;\n    }, e.find = function (t) {\n      var e = [],\n          r = this.node.querySelectorAll(t);\n      if (r) for (var n = 0; n < r.length; n++) {\n        e.push(N(r[n]));\n      }\n      return e;\n    }, e.children = function () {\n      for (var t = this.node.childNodes, e = [], r = 0; r < t.length; r++) {\n        1 === t[r].nodeType && e.push(N(t[r]));\n      }\n\n      return e;\n    }, e.index = function () {\n      for (var t = 0, e = this.node.previousSibling; e;) {\n        1 === e.nodeType && t++, e = e.previousSibling;\n      }\n\n      return t;\n    }, e.findParentByClass = function (t, e) {\n      for (var r = this.node.ownerSVGElement, n = this.node.parentNode; n && n !== e && n !== r;) {\n        var a = N(n);\n        if (a.hasClass(t)) return a;\n        n = n.parentNode;\n      }\n\n      return null;\n    }, e.contains = function (t) {\n      var e = this.node,\n          r = N.toNode(t),\n          n = r && r.parentNode;\n      return e === n || !!(n && 1 === n.nodeType && 16 & e.compareDocumentPosition(n));\n    }, e.toLocalPoint = function (t, e) {\n      var r = this.svg().node,\n          n = r.createSVGPoint();\n      n.x = t, n.y = e;\n\n      try {\n        var a = n.matrixTransform(r.getScreenCTM().inverse()),\n            i = this.getTransformToElement(r).inverse();\n      } catch (t) {\n        return n;\n      }\n\n      return a.matrixTransform(i);\n    }, e.translateCenterToPoint = function (t) {\n      var e = this.getBBox({\n        target: this.svg()\n      }).center();\n      return this.translate(t.x - e.x, t.y - e.y), this;\n    }, e.translateAndAutoOrient = function (t, e, r) {\n      var n = this.scale();\n      this.attr(\"transform\", \"\"), this.scale(n.sx, n.sy);\n      var a = this.svg().node,\n          i = this.getBBox({\n        target: r || a\n      }),\n          s = a.createSVGTransform();\n      s.setTranslate(-i.x - i.width / 2, -i.y - i.height / 2);\n      var o = a.createSVGTransform(),\n          c = new g.Point(t).changeInAngle(t.x - e.x, t.y - e.y, e);\n      o.setRotate(c, 0, 0);\n      var l = a.createSVGTransform(),\n          u = new g.Point(t).move(e, i.width / 2);\n      l.setTranslate(t.x + (t.x - u.x), t.y + (t.y - u.y));\n      var h = this.getTransformToElement(r || a),\n          f = a.createSVGTransform();\n      f.setMatrix(l.matrix.multiply(o.matrix.multiply(s.matrix.multiply(h))));\n      var d = N.decomposeMatrix(f.matrix);\n      return this.translate(d.translateX, d.translateY), this.rotate(d.rotation), this;\n    }, e.animateAlongPath = function (t, e) {\n      e = N.toNode(e);\n      var r = N.ensureId(e),\n          n = N(\"animateMotion\", t),\n          a = N(\"mpath\", {\n        \"xlink:href\": \"#\" + r\n      });\n      n.append(a), this.append(n);\n\n      try {\n        n.node.beginElement();\n      } catch (t) {\n        if (\"fake\" === document.documentElement.getAttribute(\"smiling\")) {\n          var i = n.node;\n          i.animators = [];\n          var s = i.getAttribute(\"id\");\n          s && (id2anim[s] = i);\n\n          for (var o = getTargets(i), c = 0, l = o.length; c < l; c++) {\n            var u = o[c],\n                h = new Animator(i, u, c);\n            animators.push(h), (i.animators[c] = h).register();\n          }\n        }\n      }\n\n      return this;\n    }, e.hasClass = function (t) {\n      return new RegExp(\"(\\\\s|^)\" + t + \"(\\\\s|$)\").test(this.node.getAttribute(\"class\"));\n    }, e.addClass = function (t) {\n      if (t && !this.hasClass(t)) {\n        var e = this.node.getAttribute(\"class\") || \"\";\n        this.node.setAttribute(\"class\", (e + \" \" + t).trim());\n      }\n\n      return this;\n    }, e.removeClass = function (t) {\n      if (t && this.hasClass(t)) {\n        var e = this.node.getAttribute(\"class\").replace(new RegExp(\"(\\\\s|^)\" + t + \"(\\\\s|$)\", \"g\"), \"$2\");\n        this.node.setAttribute(\"class\", e);\n      }\n\n      return this;\n    }, e.toggleClass = function (t, e) {\n      return (N.isUndefined(e) ? this.hasClass(t) : !e) ? this.removeClass(t) : this.addClass(t), this;\n    }, e.sample = function (t) {\n      t = t || 1;\n\n      for (var e, r = this.node, n = r.getTotalLength(), a = [], i = 0; i < n;) {\n        e = r.getPointAtLength(i), a.push({\n          x: e.x,\n          y: e.y,\n          distance: i\n        }), i += t;\n      }\n\n      return a;\n    }, e.convertToPath = function () {\n      var t = N(\"path\");\n      t.attr(this.attr());\n      var e = this.convertToPathData();\n      return e && t.attr(\"d\", e), t;\n    }, e.convertToPathData = function () {\n      var t = this.tagName();\n\n      switch (t) {\n        case \"PATH\":\n          return this.attr(\"d\");\n\n        case \"LINE\":\n          return N.convertLineToPathData(this.node);\n\n        case \"POLYGON\":\n          return N.convertPolygonToPathData(this.node);\n\n        case \"POLYLINE\":\n          return N.convertPolylineToPathData(this.node);\n\n        case \"ELLIPSE\":\n          return N.convertEllipseToPathData(this.node);\n\n        case \"CIRCLE\":\n          return N.convertCircleToPathData(this.node);\n\n        case \"RECT\":\n          return N.convertRectToPathData(this.node);\n      }\n\n      throw new Error(t + \" cannot be converted to PATH.\");\n    }, N.prototype.toGeometryShape = function () {\n      var t, e, r, n, a, i, s, o, c, l, u, h, f, d, m;\n\n      switch (this.tagName()) {\n        case \"RECT\":\n          return t = parseFloat(this.attr(\"x\")) || 0, e = parseFloat(this.attr(\"y\")) || 0, r = parseFloat(this.attr(\"width\")) || 0, n = parseFloat(this.attr(\"height\")) || 0, new g.Rect(t, e, r, n);\n\n        case \"CIRCLE\":\n          return a = parseFloat(this.attr(\"cx\")) || 0, i = parseFloat(this.attr(\"cy\")) || 0, s = parseFloat(this.attr(\"r\")) || 0, new g.Ellipse({\n            x: a,\n            y: i\n          }, s, s);\n\n        case \"ELLIPSE\":\n          return a = parseFloat(this.attr(\"cx\")) || 0, i = parseFloat(this.attr(\"cy\")) || 0, o = parseFloat(this.attr(\"rx\")) || 0, c = parseFloat(this.attr(\"ry\")) || 0, new g.Ellipse({\n            x: a,\n            y: i\n          }, o, c);\n\n        case \"POLYLINE\":\n          return l = N.getPointsFromSvgNode(this), new g.Polyline(l);\n\n        case \"POLYGON\":\n          return 1 < (l = N.getPointsFromSvgNode(this)).length && l.push(l[0]), new g.Polyline(l);\n\n        case \"PATH\":\n          return u = this.attr(\"d\"), g.Path.isDataSupported(u) || (u = N.normalizePathData(u)), new g.Path(u);\n\n        case \"LINE\":\n          return h = parseFloat(this.attr(\"x1\")) || 0, d = parseFloat(this.attr(\"y1\")) || 0, f = parseFloat(this.attr(\"x2\")) || 0, m = parseFloat(this.attr(\"y2\")) || 0, new g.Line({\n            x: h,\n            y: d\n          }, {\n            x: f,\n            y: m\n          });\n      }\n\n      return this.getBBox();\n    }, e.findIntersection = function (t, e) {\n      var r = this.svg().node;\n      e = e || r;\n      var n = this.getBBox({\n        target: e\n      }),\n          a = n.center();\n\n      if (n.intersectionWithLineFromCenterToPoint(t)) {\n        var i,\n            s = this.tagName();\n\n        if (\"RECT\" === s) {\n          var o = new g.Rect(parseFloat(this.attr(\"x\") || 0), parseFloat(this.attr(\"y\") || 0), parseFloat(this.attr(\"width\")), parseFloat(this.attr(\"height\"))),\n              c = this.getTransformToElement(e),\n              l = N.decomposeMatrix(c),\n              u = r.createSVGTransform();\n          u.setRotate(-l.rotation, a.x, a.y);\n          var h = N.transformRect(o, u.matrix.multiply(c));\n          i = new g.Rect(h).intersectionWithLineFromCenterToPoint(t, l.rotation);\n        } else if (\"PATH\" === s || \"POLYGON\" === s || \"POLYLINE\" === s || \"CIRCLE\" === s || \"ELLIPSE\" === s) {\n          var f,\n              d,\n              m,\n              v,\n              p,\n              x = (\"PATH\" === s ? this : this.convertToPath()).sample(),\n              y = 1 / 0,\n              T = [];\n\n          for (f = 0; f < x.length; f++) {\n            d = x[f], m = (m = N.createSVGPoint(d.x, d.y)).matrixTransform(this.getTransformToElement(e)), (p = (d = new g.Point(m)).distance(a) + (v = 1.1 * d.distance(t))) < y ? (y = p, T = [{\n              sample: d,\n              refDistance: v\n            }]) : p < y + 1 && T.push({\n              sample: d,\n              refDistance: v\n            });\n          }\n\n          T.sort(function (t, e) {\n            return t.refDistance - e.refDistance;\n          }), T[0] && (i = T[0].sample);\n        }\n\n        return i;\n      }\n    }, e.setAttribute = function (t, e) {\n      var r = this.node;\n      if (null === e) return this.removeAttr(t), this;\n      var n = N.qualifyAttr(t);\n      return n.ns ? r.setAttributeNS(n.ns, t, e) : \"id\" === t ? r.id = e : r.setAttribute(t, e), this;\n    }, N.createSvgDocument = function (t) {\n      var e = '<svg xmlns=\"' + c.xmlns + '\" xmlns:xlink=\"' + c.xlink + '\" version=\"1.1\">' + (t || \"\") + \"</svg>\";\n      return N.parseXML(e, {\n        async: !1\n      }).documentElement;\n    }, N.idCounter = 0, N.uniqueId = function () {\n      return \"v-\" + ++N.idCounter;\n    }, N.toNode = function (t) {\n      return N.isV(t) ? t.node : t.nodeName && t || t[0];\n    }, N.ensureId = function (t) {\n      return (t = N.toNode(t)).id || (t.id = N.uniqueId());\n    }, N.sanitizeText = function (t) {\n      return (t || \"\").replace(/ /g, \" \");\n    }, N.isUndefined = function (t) {\n      return void 0 === t;\n    }, N.isString = function (t) {\n      return \"string\" == typeof t;\n    }, N.isObject = function (t) {\n      return t && \"object\" == typeof t;\n    }, N.isArray = Array.isArray, N.parseXML = function (t, e) {\n      var r;\n      e = e || {};\n\n      try {\n        var n = new DOMParser();\n        N.isUndefined(e.async) || (n.async = e.async), r = n.parseFromString(t, \"text/xml\");\n      } catch (t) {\n        r = void 0;\n      }\n\n      if (!r || r.getElementsByTagName(\"parsererror\").length) throw new Error(\"Invalid XML: \" + t);\n      return r;\n    }, N.qualifyAttr = function (t) {\n      if (-1 === t.indexOf(\":\")) return {\n        ns: null,\n        local: t\n      };\n      var e = t.split(\":\");\n      return {\n        ns: c[e[0]],\n        local: e[1]\n      };\n    }, N.transformRegex = /(\\w+)\\(([^,)]+),?([^)]+)?\\)/gi, N.transformSeparatorRegex = /[ ,]+/, N.transformationListRegex = /^(\\w+)\\((.*)\\)/, N.transformStringToMatrix = function (t) {\n      var e = N.createSVGMatrix(),\n          r = t && t.match(N.transformRegex);\n      if (!r) return e;\n\n      for (var n = 0, a = r.length; n < a; n++) {\n        var i = r[n].match(N.transformationListRegex);\n\n        if (i) {\n          var s,\n              o,\n              c,\n              l,\n              u,\n              h = N.createSVGMatrix(),\n              f = i[2].split(N.transformSeparatorRegex);\n\n          switch (i[1].toLowerCase()) {\n            case \"scale\":\n              s = parseFloat(f[0]), o = void 0 === f[1] ? s : parseFloat(f[1]), h = h.scaleNonUniform(s, o);\n              break;\n\n            case \"translate\":\n              c = parseFloat(f[0]), l = parseFloat(f[1]), h = h.translate(c, l);\n              break;\n\n            case \"rotate\":\n              u = parseFloat(f[0]), c = parseFloat(f[1]) || 0, l = parseFloat(f[2]) || 0, h = 0 !== c || 0 !== l ? h.translate(c, l).rotate(u).translate(-c, -l) : h.rotate(u);\n              break;\n\n            case \"skewx\":\n              u = parseFloat(f[0]), h = h.skewX(u);\n              break;\n\n            case \"skewy\":\n              u = parseFloat(f[0]), h = h.skewY(u);\n              break;\n\n            case \"matrix\":\n              h.a = parseFloat(f[0]), h.b = parseFloat(f[1]), h.c = parseFloat(f[2]), h.d = parseFloat(f[3]), h.e = parseFloat(f[4]), h.f = parseFloat(f[5]);\n              break;\n\n            default:\n              continue;\n          }\n\n          e = e.multiply(h);\n        }\n      }\n\n      return e;\n    }, N.matrixToTransformString = function (t) {\n      return t || (t = !0), \"matrix(\" + (void 0 !== t.a ? t.a : 1) + \",\" + (void 0 !== t.b ? t.b : 0) + \",\" + (void 0 !== t.c ? t.c : 0) + \",\" + (void 0 !== t.d ? t.d : 1) + \",\" + (void 0 !== t.e ? t.e : 0) + \",\" + (void 0 !== t.f ? t.f : 0) + \")\";\n    }, N.parseTransformString = function (t) {\n      var e, r, n;\n\n      if (t) {\n        var a = N.transformSeparatorRegex;\n\n        if (0 <= t.trim().indexOf(\"matrix\")) {\n          var i = N.transformStringToMatrix(t),\n              s = N.decomposeMatrix(i);\n          e = [s.translateX, s.translateY], n = [s.scaleX, s.scaleY], r = [s.rotation];\n          var o = [];\n          0 === e[0] && 0 === e[1] || o.push(\"translate(\" + e + \")\"), 1 === n[0] && 1 === n[1] || o.push(\"scale(\" + n + \")\"), 0 !== r[0] && o.push(\"rotate(\" + r + \")\"), t = o.join(\" \");\n        } else {\n          var c = t.match(/translate\\((.*?)\\)/);\n          c && (e = c[1].split(a));\n          var l = t.match(/rotate\\((.*?)\\)/);\n          l && (r = l[1].split(a));\n          var u = t.match(/scale\\((.*?)\\)/);\n          u && (n = u[1].split(a));\n        }\n      }\n\n      var h = n && n[0] ? parseFloat(n[0]) : 1;\n      return {\n        value: t,\n        translate: {\n          tx: e && e[0] ? parseInt(e[0], 10) : 0,\n          ty: e && e[1] ? parseInt(e[1], 10) : 0\n        },\n        rotate: {\n          angle: r && r[0] ? parseInt(r[0], 10) : 0,\n          cx: r && r[1] ? parseInt(r[1], 10) : void 0,\n          cy: r && r[2] ? parseInt(r[2], 10) : void 0\n        },\n        scale: {\n          sx: h,\n          sy: n && n[1] ? parseFloat(n[1]) : h\n        }\n      };\n    }, N.deltaTransformPoint = function (t, e) {\n      return {\n        x: e.x * t.a + e.y * t.c + 0,\n        y: e.x * t.b + e.y * t.d + 0\n      };\n    }, N.decomposeMatrix = function (t) {\n      var e = N.deltaTransformPoint(t, {\n        x: 0,\n        y: 1\n      }),\n          r = N.deltaTransformPoint(t, {\n        x: 1,\n        y: 0\n      }),\n          n = 180 / v * i(e.y, e.x) - 90,\n          a = 180 / v * i(r.y, r.x);\n      return {\n        translateX: t.e,\n        translateY: t.f,\n        scaleX: s(t.a * t.a + t.b * t.b),\n        scaleY: s(t.c * t.c + t.d * t.d),\n        skewX: n,\n        skewY: a,\n        rotation: n\n      };\n    }, N.matrixToScale = function (t) {\n      var e, r, n, a;\n      return t ? (e = N.isUndefined(t.a) ? 1 : t.a, a = N.isUndefined(t.d) ? 1 : t.d, r = t.b, n = t.c) : e = a = 1, {\n        sx: r ? s(e * e + r * r) : e,\n        sy: n ? s(n * n + a * a) : a\n      };\n    }, N.matrixToRotate = function (t) {\n      var e = {\n        x: 0,\n        y: 1\n      };\n      return t && (e = N.deltaTransformPoint(t, e)), {\n        angle: g.normalizeAngle(g.toDeg(i(e.y, e.x)) - 90)\n      };\n    }, N.matrixToTranslate = function (t) {\n      return {\n        tx: t && t.e || 0,\n        ty: t && t.f || 0\n      };\n    }, N.isV = function (t) {\n      return t instanceof N;\n    }, N.isVElement = N.isV, N.isSVGGraphicsElement = function (t) {\n      return !!t && (t = N.toNode(t)) instanceof SVGElement && \"function\" == typeof t.getScreenCTM;\n    };\n    var d = N(\"svg\").node;\n    return N.createSVGMatrix = function (t) {\n      var e = d.createSVGMatrix();\n\n      for (var r in t) {\n        e[r] = t[r];\n      }\n\n      return e;\n    }, N.createSVGTransform = function (t) {\n      return N.isUndefined(t) ? d.createSVGTransform() : (t instanceof SVGMatrix || (t = N.createSVGMatrix(t)), d.createSVGTransformFromMatrix(t));\n    }, N.createSVGPoint = function (t, e) {\n      var r = d.createSVGPoint();\n      return r.x = t, r.y = e, r;\n    }, N.transformRect = function (t, e) {\n      var r = d.createSVGPoint();\n      r.x = t.x, r.y = t.y;\n      var n = r.matrixTransform(e);\n      r.x = t.x + t.width, r.y = t.y;\n      var a = r.matrixTransform(e);\n      r.x = t.x + t.width, r.y = t.y + t.height;\n      var i = r.matrixTransform(e);\n      r.x = t.x, r.y = t.y + t.height;\n      var s = r.matrixTransform(e),\n          o = h(n.x, a.x, i.x, s.x),\n          c = f(n.x, a.x, i.x, s.x),\n          l = h(n.y, a.y, i.y, s.y),\n          u = f(n.y, a.y, i.y, s.y);\n      return new g.Rect(o, l, c - o, u - l);\n    }, N.transformPoint = function (t, e) {\n      return new g.Point(N.createSVGPoint(t.x, t.y).matrixTransform(e));\n    }, N.transformLine = function (t, e) {\n      return new g.Line(N.transformPoint(t.start, e), N.transformPoint(t.end, e));\n    }, N.transformPolyline = function (t, e) {\n      var r = t instanceof g.Polyline ? t.points : t;\n      N.isArray(r) || (r = []);\n\n      for (var n = [], a = 0, i = r.length; a < i; a++) {\n        n[a] = N.transformPoint(r[a], e);\n      }\n\n      return new g.Polyline(n);\n    }, N.styleToObject = function (t) {\n      for (var e = {}, r = t.split(\";\"), n = 0; n < r.length; n++) {\n        var a = r[n].split(\"=\");\n        e[a[0].trim()] = a[1].trim();\n      }\n\n      return e;\n    }, N.createSlicePathData = function (t, e, r, n) {\n      var a = 2 * v - 1e-6,\n          i = t,\n          s = e,\n          o = r,\n          c = n,\n          l = (c < o && (l = o, o = c, c = l), c - o),\n          u = l < v ? \"0\" : \"1\",\n          h = p(o),\n          f = x(o),\n          d = p(c),\n          m = x(c);\n      return a <= l ? i ? \"M0,\" + s + \"A\" + s + \",\" + s + \" 0 1,1 0,\" + -s + \"A\" + s + \",\" + s + \" 0 1,1 0,\" + s + \"M0,\" + i + \"A\" + i + \",\" + i + \" 0 1,0 0,\" + -i + \"A\" + i + \",\" + i + \" 0 1,0 0,\" + i + \"Z\" : \"M0,\" + s + \"A\" + s + \",\" + s + \" 0 1,1 0,\" + -s + \"A\" + s + \",\" + s + \" 0 1,1 0,\" + s + \"Z\" : i ? \"M\" + s * h + \",\" + s * f + \"A\" + s + \",\" + s + \" 0 \" + u + \",1 \" + s * d + \",\" + s * m + \"L\" + i * d + \",\" + i * m + \"A\" + i + \",\" + i + \" 0 \" + u + \",0 \" + i * h + \",\" + i * f + \"Z\" : \"M\" + s * h + \",\" + s * f + \"A\" + s + \",\" + s + \" 0 \" + u + \",1 \" + s * d + \",\" + s * m + \"L0,0Z\";\n    }, N.mergeAttrs = function (t, e) {\n      for (var r in e) {\n        \"class\" === r ? t[r] = t[r] ? t[r] + \" \" + e[r] : e[r] : \"style\" === r ? N.isObject(t[r]) && N.isObject(e[r]) ? t[r] = N.mergeAttrs(t[r], e[r]) : N.isObject(t[r]) ? t[r] = N.mergeAttrs(t[r], N.styleToObject(e[r])) : N.isObject(e[r]) ? t[r] = N.mergeAttrs(N.styleToObject(t[r]), e[r]) : t[r] = N.mergeAttrs(N.styleToObject(t[r]), N.styleToObject(e[r])) : t[r] = e[r];\n      }\n\n      return t;\n    }, N.annotateString = function (t, e, r) {\n      e = e || [];\n\n      for (var n, a, i, s = (r = r || {}).offset || 0, o = [], c = [], l = 0; l < t.length; l++) {\n        a = c[l] = t[l];\n\n        for (var u = 0; u < e.length; u++) {\n          var h = e[u],\n              f = h.start + s,\n              d = h.end + s;\n          f <= l && l < d && (N.isObject(a) ? a.attrs = N.mergeAttrs(N.mergeAttrs({}, a.attrs), h.attrs) : a = c[l] = {\n            t: t[l],\n            attrs: h.attrs\n          }, r.includeAnnotationIndices && (a.annotations || (a.annotations = [])).push(u));\n        }\n\n        (i = c[l - 1]) ? N.isObject(a) && N.isObject(i) ? JSON.stringify(a.attrs) === JSON.stringify(i.attrs) ? n.t += a.t : (o.push(n), n = a) : n = N.isObject(a) ? (o.push(n), a) : N.isObject(i) ? (o.push(n), a) : (n || \"\") + a : n = a;\n      }\n\n      return n && o.push(n), o;\n    }, N.findAnnotationsAtIndex = function (t, e) {\n      var r = [];\n      return t && t.forEach(function (t) {\n        t.start < e && e <= t.end && r.push(t);\n      }), r;\n    }, N.findAnnotationsBetweenIndexes = function (t, e, r) {\n      var n = [];\n      return t && t.forEach(function (t) {\n        (e >= t.start && e < t.end || r > t.start && r <= t.end || t.start >= e && t.end < r) && n.push(t);\n      }), n;\n    }, N.shiftAnnotations = function (t, e, r) {\n      return t && t.forEach(function (t) {\n        t.start < e && t.end >= e ? t.end += r : t.start >= e && (t.start += r, t.end += r);\n      }), t;\n    }, N.convertLineToPathData = function (t) {\n      return [\"M\", (t = N(t)).attr(\"x1\"), t.attr(\"y1\"), \"L\", t.attr(\"x2\"), t.attr(\"y2\")].join(\" \");\n    }, N.convertPolygonToPathData = function (t) {\n      var e = N.getPointsFromSvgNode(t);\n      return 0 === e.length ? null : N.svgPointsToPath(e) + \" Z\";\n    }, N.convertPolylineToPathData = function (t) {\n      var e = N.getPointsFromSvgNode(t);\n      return 0 === e.length ? null : N.svgPointsToPath(e);\n    }, N.svgPointsToPath = function (t) {\n      for (var e = 0, r = t.length; e < r; e++) {\n        t[e] = t[e].x + \" \" + t[e].y;\n      }\n\n      return \"M \" + t.join(\" L\");\n    }, N.getPointsFromSvgNode = function (t) {\n      var e = [],\n          r = (t = N.toNode(t)).points;\n      if (r) for (var n = 0, a = r.numberOfItems; n < a; n++) {\n        e.push(r.getItem(n));\n      }\n      return e;\n    }, N.KAPPA = .551784, N.convertCircleToPathData = function (t) {\n      t = N(t);\n      var e = parseFloat(t.attr(\"cx\")) || 0,\n          r = parseFloat(t.attr(\"cy\")) || 0,\n          n = parseFloat(t.attr(\"r\")),\n          a = n * N.KAPPA;\n      return [\"M\", e, r - n, \"C\", e + a, r - n, e + n, r - a, e + n, r, \"C\", e + n, r + a, e + a, r + n, e, r + n, \"C\", e - a, r + n, e - n, r + a, e - n, r, \"C\", e - n, r - a, e - a, r - n, e, r - n, \"Z\"].join(\" \");\n    }, N.convertEllipseToPathData = function (t) {\n      t = N(t);\n      var e = parseFloat(t.attr(\"cx\")) || 0,\n          r = parseFloat(t.attr(\"cy\")) || 0,\n          n = parseFloat(t.attr(\"rx\")),\n          a = parseFloat(t.attr(\"ry\")) || n,\n          i = n * N.KAPPA,\n          s = a * N.KAPPA;\n      return [\"M\", e, r - a, \"C\", e + i, r - a, e + n, r - s, e + n, r, \"C\", e + n, r + s, e + i, r + a, e, r + a, \"C\", e - i, r + a, e - n, r + s, e - n, r, \"C\", e - n, r - s, e - i, r - a, e, r - a, \"Z\"].join(\" \");\n    }, N.convertRectToPathData = function (t) {\n      return t = N(t), N.rectToPath({\n        x: parseFloat(t.attr(\"x\")) || 0,\n        y: parseFloat(t.attr(\"y\")) || 0,\n        width: parseFloat(t.attr(\"width\")) || 0,\n        height: parseFloat(t.attr(\"height\")) || 0,\n        rx: parseFloat(t.attr(\"rx\")) || 0,\n        ry: parseFloat(t.attr(\"ry\")) || 0\n      });\n    }, N.rectToPath = function (t) {\n      var e = t.x,\n          r = t.y,\n          n = t.width,\n          a = t.height,\n          i = h(t.rx || t[\"top-rx\"] || 0, n / 2),\n          s = h(t.rx || t[\"bottom-rx\"] || 0, n / 2),\n          o = h(t.ry || t[\"top-ry\"] || 0, a / 2),\n          c = h(t.ry || t[\"bottom-ry\"] || 0, a / 2);\n      return (i || s || o || c ? [\"M\", e, r + o, \"v\", a - o - c, \"a\", s, c, 0, 0, 0, s, c, \"h\", n - 2 * s, \"a\", s, c, 0, 0, 0, s, -c, \"v\", -(a - c - o), \"a\", i, o, 0, 0, 0, -i, -o, \"h\", -(n - 2 * i), \"a\", i, o, 0, 0, 0, -i, o, \"Z\"] : [\"M\", e, r, \"H\", e + n, \"V\", r + a, \"H\", e, \"V\", r, \"Z\"]).join(\" \");\n    }, N.normalizePathData = function () {\n      var t = \"\\t\\n\\x0B\\f\\r \\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\",\n          v = new RegExp(\"([a-z])[\" + t + \",]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[\" + t + \"]*,?[\" + t + \"]*)+)\", \"ig\"),\n          g = new RegExp(\"(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[\" + t + \"]*,?[\" + t + \"]*\", \"ig\"),\n          e = Math,\n          U = e.PI,\n          Y = e.sin,\n          X = e.cos,\n          Z = e.tan,\n          K = e.asin,\n          W = e.sqrt,\n          $ = e.abs;\n\n      function f(t, e, r, n, a, i) {\n        return [1 / 3 * t + 2 / 3 * r, 1 / 3 * e + 2 / 3 * n, 1 / 3 * a + 2 / 3 * r, 1 / 3 * i + 2 / 3 * n, a, i];\n      }\n\n      function d(t) {\n        if (Array.isArray(t) && Array.isArray(t && t[0]) || (t = function (t) {\n          if (!t) return null;\n          var i = {\n            a: 7,\n            c: 6,\n            h: 1,\n            l: 2,\n            m: 2,\n            q: 4,\n            s: 4,\n            t: 2,\n            v: 1,\n            z: 0\n          },\n              s = [];\n          return String(t).replace(v, function (t, e, r) {\n            var n = [],\n                a = e.toLowerCase();\n\n            for (r.replace(g, function (t, e) {\n              e && n.push(+e);\n            }), \"m\" === a && 2 < n.length && (s.push([e].concat(n.splice(0, 2))), a = \"l\", e = \"m\" === e ? \"l\" : \"L\"); n.length >= i[a] && (s.push([e].concat(n.splice(0, i[a]))), i[a]);) {\n              ;\n            }\n          }), s;\n        }(t)), !t || !t.length) return [[\"M\", 0, 0]];\n\n        for (var e, r = [], n = 0, a = 0, i = 0, s = 0, o = t.length, c = 0; c < o; c++) {\n          var l = [];\n          r.push(l);\n          var u,\n              h,\n              f = t[c];\n          if ((e = f[0]) != e.toUpperCase()) switch (l[0] = e.toUpperCase(), l[0]) {\n            case \"A\":\n              l[1] = f[1], l[2] = f[2], l[3] = f[3], l[4] = f[4], l[5] = f[5], l[6] = +f[6] + n, l[7] = +f[7] + a;\n              break;\n\n            case \"V\":\n              l[1] = +f[1] + a;\n              break;\n\n            case \"H\":\n              l[1] = +f[1] + n;\n              break;\n\n            case \"M\":\n              for (i = +f[1] + n, s = +f[2] + a, u = f.length, h = 1; h < u; h++) {\n                l[h] = +f[h] + (h % 2 ? n : a);\n              }\n\n              break;\n\n            default:\n              for (u = f.length, h = 1; h < u; h++) {\n                l[h] = +f[h] + (h % 2 ? n : a);\n              }\n\n          } else for (var d = f.length, m = 0; m < d; m++) {\n            l[m] = f[m];\n          }\n\n          switch (l[0]) {\n            case \"Z\":\n              n = +i, a = +s;\n              break;\n\n            case \"H\":\n              n = l[1];\n              break;\n\n            case \"V\":\n              a = l[1];\n              break;\n\n            case \"M\":\n              i = l[l.length - 2], s = l[l.length - 1], n = l[l.length - 2], a = l[l.length - 1];\n              break;\n\n            default:\n              n = l[l.length - 2], a = l[l.length - 1];\n          }\n        }\n\n        return r;\n      }\n\n      function r(t) {\n        var n = d(t),\n            e = {\n          x: 0,\n          y: 0,\n          bx: 0,\n          by: 0,\n          X: 0,\n          Y: 0,\n          qx: null,\n          qy: null\n        };\n\n        function r(t, e, r) {\n          var n, a;\n          if (!t) return [\"C\", e.x, e.y, e.x, e.y, e.x, e.y];\n\n          switch (t[0] in {\n            T: 1,\n            Q: 1\n          } || (e.qx = null, e.qy = null), t[0]) {\n            case \"M\":\n              e.X = t[1], e.Y = t[2];\n              break;\n\n            case \"A\":\n              t = [\"C\"].concat(function t(e, r, n, a, i, s, o, c, l, u) {\n                var h,\n                    f = 120 * U / 180,\n                    d = U / 180 * (+i || 0),\n                    m = [],\n                    v = function v(t, e, r) {\n                  return {\n                    x: t * X(r) - e * Y(r),\n                    y: t * Y(r) + e * X(r)\n                  };\n                };\n\n                if (u) A = u[0], S = u[1], P = u[2], w = u[3];else {\n                  e = (h = v(e, r, -d)).x, r = h.y;\n                  var g = (e - (c = (h = v(c, l, -d)).x)) / 2,\n                      p = (r - (l = h.y)) / 2,\n                      x = g * g / (n * n) + p * p / (a * a);\n                  1 < x && (n *= x = W(x), a *= x);\n                  var y = n * n,\n                      T = a * a,\n                      b = (s == o ? -1 : 1) * W($((y * T - y * p * p - T * g * g) / (y * p * p + T * g * g))),\n                      P = b * n * p / a + (e + c) / 2,\n                      w = b * -a * g / n + (r + l) / 2,\n                      A = K(((r - w) / a).toFixed(9)),\n                      S = K(((l - w) / a).toFixed(9));\n                  (A = e < P ? U - A : A) < 0 && (A = 2 * U + A), (S = c < P ? U - S : S) < 0 && (S = 2 * U + S), S < (o && A) && (A -= 2 * U), A < (!o && S) && (S -= 2 * U);\n                }\n                var F = S - A;\n\n                if ($(F) > f) {\n                  var C = S,\n                      E = c,\n                      N = l;\n                  m = t(c = P + n * X(S = A + f * (A < (o && S) ? 1 : -1)), l = w + a * Y(S), n, a, i, 0, o, E, N, [S, C, P, w]);\n                }\n\n                F = S - A;\n                var V = X(A),\n                    L = Y(A),\n                    M = X(S),\n                    G = Y(S),\n                    O = Z(F / 4),\n                    k = 4 / 3 * (n * O),\n                    I = 4 / 3 * (a * O),\n                    R = [e, r],\n                    j = [e + k * L, r - I * V],\n                    D = [c + k * G, l - I * M],\n                    B = [c, l];\n                if (j[0] = 2 * R[0] - j[0], j[1] = 2 * R[1] - j[1], u) return [j, D, B].concat(m);\n\n                for (var q = [], z = (m = [j, D, B].concat(m).join().split(\",\")).length, H = 0; H < z; H++) {\n                  q[H] = H % 2 ? v(m[H - 1], m[H], d).y : v(m[H], m[H + 1], d).x;\n                }\n\n                return q;\n              }.apply(0, [e.x, e.y].concat(t.slice(1))));\n              break;\n\n            case \"S\":\n              a = \"C\" === r || \"S\" === r ? (n = 2 * e.x - e.bx, 2 * e.y - e.by) : (n = e.x, e.y), t = [\"C\", n, a].concat(t.slice(1));\n              break;\n\n            case \"T\":\n              e.qy = \"Q\" === r || \"T\" === r ? (e.qx = 2 * e.x - e.qx, 2 * e.y - e.qy) : (e.qx = e.x, e.y), t = [\"C\"].concat(f(e.x, e.y, e.qx, e.qy, t[1], t[2]));\n              break;\n\n            case \"Q\":\n              e.qx = t[1], e.qy = t[2], t = [\"C\"].concat(f(e.x, e.y, t[1], t[2], t[3], t[4]));\n              break;\n\n            case \"H\":\n              t = [\"L\"].concat(t[1], e.y);\n              break;\n\n            case \"V\":\n              t = [\"L\"].concat(e.x, t[1]);\n          }\n\n          return t;\n        }\n\n        function a(t, e) {\n          if (7 < t[e].length) {\n            t[e].shift();\n\n            for (var r = t[e]; r.length;) {\n              i[e] = \"A\", t.splice(e++, 0, [\"C\"].concat(r.splice(0, 6)));\n            }\n\n            t.splice(e, 1), c = n.length;\n          }\n        }\n\n        for (var i = [], s = \"\", o = \"\", c = n.length, l = 0; l < c; l++) {\n          n[l] && (s = n[l][0]), \"C\" !== s && (i[l] = s, 0 < l && (o = i[l - 1])), n[l] = r(n[l], e, o), \"A\" !== i[l] && \"C\" === s && (i[l] = \"C\"), a(n, l);\n          var u = n[l],\n              h = u.length;\n          e.x = u[h - 2], e.y = u[h - 1], e.bx = parseFloat(u[h - 4]) || e.x, e.by = parseFloat(u[h - 3]) || e.y;\n        }\n\n        return n[0][0] && \"M\" === n[0][0] || n.unshift([\"M\", 0, 0]), n;\n      }\n\n      return function (t) {\n        return r(t).join(\",\").split(\",\").join(\" \");\n      };\n    }(), N.namespace = c, N;\n  }();\n\n  var joint = {\n    version: \"2.2.1\",\n    config: {\n      classNamePrefix: \"joint-\",\n      defaultTheme: \"default\"\n    },\n    dia: {},\n    ui: {},\n    layout: {},\n    shapes: {},\n    format: {},\n    connectors: {},\n    highlighters: {},\n    routers: {},\n    anchors: {},\n    connectionPoints: {},\n    connectionStrategies: {},\n    linkTools: {},\n    mvc: {\n      views: {}\n    },\n    setTheme: function setTheme(t, e) {\n      e = e || {}, joint.util.invoke(joint.mvc.views, \"setTheme\", t, e), joint.mvc.View.prototype.defaultTheme = t;\n    },\n    env: {\n      _results: {},\n      _tests: {\n        svgforeignobject: function svgforeignobject() {\n          return !!document.createElementNS && /SVGForeignObject/.test({}.toString.call(document.createElementNS(\"http://www.w3.org/2000/svg\", \"foreignObject\")));\n        }\n      },\n      addTest: function addTest(t, e) {\n        return joint.env._tests[t] = e;\n      },\n      test: function test(t) {\n        var e = joint.env._tests[t];\n        if (!e) throw new Error('Test not defined (\"' + t + '\"). Use `joint.env.addTest(name, fn) to add a new test.`');\n        var i = joint.env._results[t];\n        if (void 0 !== i) return i;\n\n        try {\n          i = e();\n        } catch (t) {\n          i = !1;\n        }\n\n        return joint.env._results[t] = i;\n      }\n    },\n    util: {\n      hashCode: function hashCode(t) {\n        var e = 0;\n        if (0 == t.length) return e;\n\n        for (var i = 0; i < t.length; i++) {\n          e = (e << 5) - e + t.charCodeAt(i), e &= e;\n        }\n\n        return e;\n      },\n      getByPath: function getByPath(t, e, i) {\n        for (var n, r = Array.isArray(e) ? e.slice() : e.split(i || \"/\"); r.length;) {\n          if (n = r.shift(), !(Object(t) === t && n in t)) return;\n          t = t[n];\n        }\n\n        return t;\n      },\n      setByPath: function setByPath(t, e, i, n) {\n        for (var r = Array.isArray(e) ? e : e.split(n || \"/\"), o = t, s = 0, a = r.length; s < a - 1; s++) {\n          o = o[r[s]] || (o[r[s]] = {});\n        }\n\n        return o[r[a - 1]] = i, t;\n      },\n      unsetByPath: function unsetByPath(t, e, i) {\n        i = i || \"/\";\n        var n = Array.isArray(e) ? e.slice() : e.split(i),\n            r = n.pop();\n\n        if (0 < n.length) {\n          var o = joint.util.getByPath(t, n, i);\n          o && delete o[r];\n        } else delete t[r];\n\n        return t;\n      },\n      flattenObject: function flattenObject(t, e, i) {\n        e = e || \"/\";\n        var n = {};\n\n        for (var r in t) {\n          if (t.hasOwnProperty(r)) {\n            var o = \"object\" == typeof t[r];\n\n            if (o && i && i(t[r]) && (o = !1), o) {\n              var s = this.flattenObject(t[r], e, i);\n\n              for (var a in s) {\n                s.hasOwnProperty(a) && (n[r + e + a] = s[a]);\n              }\n            } else n[r] = t[r];\n          }\n        }\n\n        return n;\n      },\n      uuid: function uuid() {\n        return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (t) {\n          var e = 16 * Math.random() | 0;\n          return (\"x\" === t ? e : 3 & e | 8).toString(16);\n        });\n      },\n      guid: function guid(t) {\n        return this.guid.id = this.guid.id || 1, t.id = void 0 === t.id ? \"j_\" + this.guid.id++ : t.id, t.id;\n      },\n      toKebabCase: function toKebabCase(t) {\n        return t.replace(/[A-Z]/g, \"-$&\").toLowerCase();\n      },\n      normalizeEvent: function normalizeEvent(t) {\n        var e = t,\n            i = t.originalEvent && t.originalEvent.changedTouches && t.originalEvent.changedTouches[0];\n\n        if (i) {\n          for (var n in t) {\n            void 0 === i[n] && (i[n] = t[n]);\n          }\n\n          e = i;\n        }\n\n        var r = e.target;\n\n        if (r) {\n          var o = r.correspondingUseElement;\n          o && (e.target = o);\n        }\n\n        return e;\n      },\n      nextFrame: function () {\n        var i;\n\n        if (\"undefined\" != typeof window && (i = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame), !i) {\n          var r = 0;\n\n          i = function i(t) {\n            var e = new Date().getTime(),\n                i = Math.max(0, 16 - (e - r)),\n                n = setTimeout(function () {\n              t(e + i);\n            }, i);\n            return r = e + i, n;\n          };\n        }\n\n        return function (t, e) {\n          return i(e ? t.bind(e) : t);\n        };\n      }(),\n      cancelFrame: function () {\n        var t,\n            e = \"undefined\" != typeof window;\n        return e && (t = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame), t = t || clearTimeout, e ? t.bind(window) : t;\n      }(),\n      shapePerimeterConnectionPoint: function shapePerimeterConnectionPoint(t, e, i, n) {\n        var r, o;\n\n        if (!i) {\n          var s = e.$(\".scalable\")[0],\n              a = e.$(\".rotatable\")[0];\n          s && s.firstChild ? i = s.firstChild : a && a.firstChild && (i = a.firstChild);\n        }\n\n        return i ? (o = V(i).findIntersection(n, t.paper.viewport)) || (r = V(i).getBBox({\n          target: t.paper.viewport\n        })) : o = (r = e.model.getBBox()).intersectionWithLineFromCenterToPoint(n), o || r.center();\n      },\n      isPercentage: function isPercentage(t) {\n        return joint.util.isString(t) && \"%\" === t.slice(-1);\n      },\n      parseCssNumeric: function parseCssNumeric(t, e) {\n        var i = parseFloat(t);\n        if (Number.isNaN(i)) return null;\n        var n,\n            r = {};\n        if (r.value = i, null == e) n = \"[A-Za-z]*\";else if (Array.isArray(e)) {\n          if (0 === e.length) return null;\n          n = e.join(\"|\");\n        } else joint.util.isString(e) && (n = e);\n        var o,\n            s = (o = new RegExp(\"(?:\\\\d+(?:\\\\.\\\\d+)*)(\" + n + \")$\").exec(t)) ? o[1] : null;\n        return null === s ? null : (r.unit = s, r);\n      },\n      breakText: function breakText(t, e, i, n) {\n        n = n || {}, i = i || {};\n        var r = e.width,\n            o = e.height,\n            s = n.svgDocument || V(\"svg\").node,\n            a = V(\"tspan\").node,\n            l = V(\"text\").attr(i).append(a).node,\n            h = document.createTextNode(\"\");\n        l.style.opacity = 0, l.style.display = \"block\", a.style.display = \"block\", a.appendChild(h), s.appendChild(l), n.svgDocument || document.body.appendChild(s);\n\n        for (var u, c, d = n.separator || \" \", f = n.eol || \"\\n\", g = t.split(d), p = [], m = [], v = 0, y = 0, b = g.length; v < b; v++) {\n          var w = g[v];\n          if (w) if (f && 0 <= w.indexOf(f)) {\n            if (1 < w.length) {\n              for (var x = w.split(f), k = 0, A = x.length - 1; k < A; k++) {\n                x.splice(2 * k + 1, 0, f);\n              }\n\n              Array.prototype.splice.apply(g, [v, 1].concat(x)), v--, b += x.length - 1;\n            } else y++;\n          } else {\n            if (h.data = m[y] ? m[y] + \" \" + w : w, a.getComputedTextLength() <= r) m[y] = h.data, u && (p[y++] = !0, u = 0);else {\n              if (!m[y] || u) {\n                var j = !!u;\n\n                if (u = w.length - 1, j || !u) {\n                  if (!u) {\n                    if (!m[y]) {\n                      m = [];\n                      break;\n                    }\n\n                    g.splice(v, 2, w + g[v + 1]), b--, p[y++] = !0, v--;\n                    continue;\n                  }\n\n                  g[v] = w.substring(0, u), g[v + 1] = w.substring(u) + g[v + 1];\n                } else g.splice(v, 1, w.substring(0, u), w.substring(u)), b++, y && !p[y - 1] && y--;\n\n                v--;\n                continue;\n              }\n\n              y++, v--;\n            }\n\n            if (void 0 !== o) {\n              var P;\n              if (void 0 === c) c = (P = \"auto\" === i.lineHeight ? {\n                value: 1.5,\n                unit: \"em\"\n              } : joint.util.parseCssNumeric(i.lineHeight, [\"em\"]) || {\n                value: 1,\n                unit: \"em\"\n              }).value, \"em\" === P.unit && (c *= l.getBBox().height);\n\n              if (c * m.length > o) {\n                var C = Math.floor(o / c) - 1;\n                m.splice(C + 1);\n                var E = n.ellipsis;\n                if (!E || C < 0) break;\n                \"string\" != typeof E && (E = \"…\");\n\n                var M,\n                    _,\n                    S = m[C],\n                    B = S.length;\n\n                do {\n                  if (_ = S[B], M = S.substring(0, B), _ ? _.match(d) && (M += _) : M += \"string\" == typeof d ? d : \" \", M += E, h.data = M, a.getComputedTextLength() <= r) {\n                    m[C] = M;\n                    break;\n                  }\n\n                  B--;\n                } while (0 <= B);\n\n                break;\n              }\n            }\n          }\n        }\n\n        return n.svgDocument ? s.removeChild(l) : document.body.removeChild(s), m.join(f);\n      },\n      sanitizeHTML: function sanitizeHTML(t) {\n        var e = $($.parseHTML(\"<div>\" + t + \"</div>\", null, !1));\n        return e.find(\"*\").each(function () {\n          var i = this;\n          $.each(i.attributes, function () {\n            var t = this.name,\n                e = this.value;\n            0 !== t.indexOf(\"on\") && 0 !== e.indexOf(\"javascript:\") || $(i).removeAttr(t);\n          });\n        }), e.html();\n      },\n      downloadBlob: function downloadBlob(t, e) {\n        if (window.navigator.msSaveBlob) window.navigator.msSaveBlob(t, e);else {\n          var i = window.URL.createObjectURL(t),\n              n = document.createElement(\"a\");\n          n.href = i, n.download = e, document.body.appendChild(n), n.click(), document.body.removeChild(n), window.URL.revokeObjectURL(i);\n        }\n      },\n      downloadDataUri: function downloadDataUri(t, e) {\n        var i = joint.util.dataUriToBlob(t);\n        joint.util.downloadBlob(i, e);\n      },\n      dataUriToBlob: function dataUriToBlob(t) {\n        t = t.replace(/\\s/g, \"\");\n        var e,\n            i = (t = decodeURIComponent(t)).indexOf(\",\"),\n            n = t.slice(0, i),\n            r = n.split(\":\")[1].split(\";\")[0],\n            o = t.slice(i + 1);\n        e = 0 <= n.indexOf(\"base64\") ? atob(o) : unescape(encodeURIComponent(o));\n\n        for (var s = new Uint8Array(e.length), a = 0; a < e.length; a++) {\n          s[a] = e.charCodeAt(a);\n        }\n\n        return new Blob([s], {\n          type: r\n        });\n      },\n      imageToDataUri: function imageToDataUri(r, t) {\n        if (!r || \"data:\" === r.substr(0, \"data:\".length)) return setTimeout(function () {\n          t(null, r);\n        }, 0);\n        var e = new XMLHttpRequest();\n        e.open(\"GET\", r, !0), e.addEventListener(\"error\", function () {\n          t(new Error(\"Failed to load image \" + r));\n        }), e.responseType = window.FileReader ? \"blob\" : \"arraybuffer\", e.addEventListener(\"load\", function () {\n          window.FileReader ? function (t, i) {\n            if (200 === t.status) {\n              var e = new FileReader();\n              e.onload = function (t) {\n                var e = t.target.result;\n                i(null, e);\n              }, e.onerror = function () {\n                i(new Error(\"Failed to load image \" + r));\n              }, e.readAsDataURL(t.response);\n            } else i(new Error(\"Failed to load image \" + r));\n          }(e, t) : function (t, e) {\n            if (200 === t.status) {\n              var i = new Uint8Array(t.response),\n                  n = r.split(\".\").pop() || \"png\";\n              e(null, \"data:image/\" + ({\n                svg: \"svg+xml\"\n              }[n] || n) + \";base64,\" + btoa(function (t) {\n                for (var e = [], i = 0; i < t.length; i += 32768) {\n                  e.push(String.fromCharCode.apply(null, t.subarray(i, i + 32768)));\n                }\n\n                return e.join(\"\");\n              }(i)));\n            } else e(new Error(\"Failed to load image \" + r));\n          }(e, t);\n        }), e.send();\n      },\n      getElementBBox: function getElementBBox(t) {\n        var e = $(t);\n        if (0 === e.length) throw new Error(\"Element not found\");\n        var i = e[0],\n            n = i.ownerDocument,\n            r = i.getBoundingClientRect(),\n            o = 0,\n            s = 0;\n\n        if (i.ownerSVGElement) {\n          var a = V(i),\n              l = a.getBBox({\n            target: a.svg()\n          });\n          o = r.width - l.width, s = r.height - l.height;\n        }\n\n        return {\n          x: r.left + window.pageXOffset - n.documentElement.offsetLeft + o / 2,\n          y: r.top + window.pageYOffset - n.documentElement.offsetTop + s / 2,\n          width: r.width - o,\n          height: r.height - s\n        };\n      },\n      sortElements: function sortElements(t, e) {\n        var i = $(t),\n            n = i.map(function () {\n          var t = this.parentNode,\n              e = t.insertBefore(document.createTextNode(\"\"), this.nextSibling);\n          return function () {\n            if (t === this) throw new Error(\"You can't sort elements if any one is a descendant of another.\");\n            t.insertBefore(this, e), t.removeChild(e);\n          };\n        });\n        return Array.prototype.sort.call(i, e).each(function (t) {\n          n[t].call(this);\n        });\n      },\n      setAttributesBySelector: function setAttributesBySelector(t, e) {\n        var n = $(t);\n        joint.util.forIn(e, function (t, e) {\n          var i = n.find(e).addBack().filter(e);\n          joint.util.has(t, \"class\") && (i.addClass(t.class), t = joint.util.omit(t, \"class\")), i.attr(t);\n        });\n      },\n      normalizeSides: function normalizeSides(t) {\n        if (Object(t) === t) return e = i = n = r = 0, isFinite(t.vertical) && (e = n = +t.vertical), isFinite(t.horizontal) && (i = r = +t.horizontal), isFinite(t.top) && (e = +t.top), isFinite(t.right) && (i = +t.right), isFinite(t.bottom) && (n = +t.bottom), isFinite(t.left) && (r = +t.left), {\n          top: e,\n          right: i,\n          bottom: n,\n          left: r\n        };\n        var e,\n            i,\n            n,\n            r,\n            o = 0;\n        return isFinite(t) && (o = +t), {\n          top: o,\n          right: o,\n          bottom: o,\n          left: o\n        };\n      },\n      timing: {\n        linear: function linear(t) {\n          return t;\n        },\n        quad: function quad(t) {\n          return t * t;\n        },\n        cubic: function cubic(t) {\n          return t * t * t;\n        },\n        inout: function inout(t) {\n          if (t <= 0) return 0;\n          if (1 <= t) return 1;\n          var e = t * t,\n              i = e * t;\n          return 4 * (t < .5 ? i : 3 * (t - e) + i - .75);\n        },\n        exponential: function exponential(t) {\n          return Math.pow(2, 10 * (t - 1));\n        },\n        bounce: function bounce(t) {\n          for (var e = 0, i = 1;; e += i, i /= 2) {\n            if ((7 - 4 * e) / 11 <= t) {\n              var n = (11 - 6 * e - 11 * t) / 4;\n              return -n * n + i * i;\n            }\n          }\n        },\n        reverse: function reverse(e) {\n          return function (t) {\n            return 1 - e(1 - t);\n          };\n        },\n        reflect: function reflect(e) {\n          return function (t) {\n            return .5 * (t < .5 ? e(2 * t) : 2 - e(2 - 2 * t));\n          };\n        },\n        clamp: function clamp(i, n, r) {\n          return n = n || 0, r = r || 1, function (t) {\n            var e = i(t);\n            return e < n ? n : r < e ? r : e;\n          };\n        },\n        back: function back(e) {\n          return e || (e = 1.70158), function (t) {\n            return t * t * ((e + 1) * t - e);\n          };\n        },\n        elastic: function elastic(e) {\n          return e || (e = 1.5), function (t) {\n            return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * e / 3 * t);\n          };\n        }\n      },\n      interpolate: {\n        number: function number(e, t) {\n          var i = t - e;\n          return function (t) {\n            return e + i * t;\n          };\n        },\n        object: function object(r, o) {\n          var s = Object.keys(r);\n          return function (t) {\n            var e,\n                i,\n                n = {};\n\n            for (e = s.length - 1; -1 != e; e--) {\n              n[i = s[e]] = r[i] + (o[i] - r[i]) * t;\n            }\n\n            return n;\n          };\n        },\n        hexColor: function hexColor(t, e) {\n          var i = parseInt(t.slice(1), 16),\n              n = parseInt(e.slice(1), 16),\n              r = 255 & i,\n              o = (255 & n) - r,\n              s = 65280 & i,\n              a = (65280 & n) - s,\n              l = 16711680 & i,\n              h = (16711680 & n) - l;\n          return function (t) {\n            return \"#\" + (1 << 24 | r + o * t & 255 | s + a * t & 65280 | l + h * t & 16711680).toString(16).slice(1);\n          };\n        },\n        unit: function unit(e, t) {\n          var i = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/,\n              n = i.exec(e),\n              r = i.exec(t),\n              o = r[1].indexOf(\".\"),\n              s = 0 < o ? r[1].length - o - 1 : 0;\n          e = +n[1];\n          var a = +r[1] - e,\n              l = n[2];\n          return function (t) {\n            return (e + a * t).toFixed(s) + l;\n          };\n        }\n      },\n      filter: {\n        outline: function outline(t) {\n          var e = Number.isFinite(t.margin) ? t.margin : 2,\n              i = Number.isFinite(t.width) ? t.width : 1;\n          return joint.util.template('<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology in=\"SourceAlpha\" result=\"morphedOuter\" operator=\"dilate\" radius=\"${outerRadius}\" /><feMorphology in=\"SourceAlpha\" result=\"morphedInner\" operator=\"dilate\" radius=\"${innerRadius}\" /><feComposite result=\"morphedOuterColored\" in=\"colored\" in2=\"morphedOuter\" operator=\"in\"/><feComposite operator=\"xor\" in=\"morphedOuterColored\" in2=\"morphedInner\" result=\"outline\"/><feMerge><feMergeNode in=\"outline\"/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>')({\n            color: t.color || \"blue\",\n            opacity: Number.isFinite(t.opacity) ? t.opacity : 1,\n            outerRadius: e + i,\n            innerRadius: e\n          });\n        },\n        highlight: function highlight(t) {\n          return joint.util.template('<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology result=\"morphed\" in=\"SourceGraphic\" operator=\"dilate\" radius=\"${width}\"/><feComposite result=\"composed\" in=\"colored\" in2=\"morphed\" operator=\"in\"/><feGaussianBlur result=\"blured\" in=\"composed\" stdDeviation=\"${blur}\"/><feBlend in=\"SourceGraphic\" in2=\"blured\" mode=\"normal\"/></filter>')({\n            color: t.color || \"red\",\n            width: Number.isFinite(t.width) ? t.width : 1,\n            blur: Number.isFinite(t.blur) ? t.blur : 0,\n            opacity: Number.isFinite(t.opacity) ? t.opacity : 1\n          });\n        },\n        blur: function blur(t) {\n          var e = Number.isFinite(t.x) ? t.x : 2;\n          return joint.util.template('<filter><feGaussianBlur stdDeviation=\"${stdDeviation}\"/></filter>')({\n            stdDeviation: Number.isFinite(t.y) ? [e, t.y] : e\n          });\n        },\n        dropShadow: function dropShadow(t) {\n          var e = \"SVGFEDropShadowElement\" in window ? '<filter><feDropShadow stdDeviation=\"${blur}\" dx=\"${dx}\" dy=\"${dy}\" flood-color=\"${color}\" flood-opacity=\"${opacity}\"/></filter>' : '<filter><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"${blur}\"/><feOffset dx=\"${dx}\" dy=\"${dy}\" result=\"offsetblur\"/><feFlood flood-color=\"${color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"${opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n          return joint.util.template(e)({\n            dx: t.dx || 0,\n            dy: t.dy || 0,\n            opacity: Number.isFinite(t.opacity) ? t.opacity : 1,\n            color: t.color || \"black\",\n            blur: Number.isFinite(t.blur) ? t.blur : 4\n          });\n        },\n        grayscale: function grayscale(t) {\n          var e = Number.isFinite(t.amount) ? t.amount : 1;\n          return joint.util.template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0\"/></filter>')({\n            a: .2126 + .7874 * (1 - e),\n            b: .7152 - .7152 * (1 - e),\n            c: .0722 - .0722 * (1 - e),\n            d: .2126 - .2126 * (1 - e),\n            e: .7152 + .2848 * (1 - e),\n            f: .0722 - .0722 * (1 - e),\n            g: .2126 - .2126 * (1 - e),\n            h: .0722 + .9278 * (1 - e)\n          });\n        },\n        sepia: function sepia(t) {\n          var e = Number.isFinite(t.amount) ? t.amount : 1;\n          return joint.util.template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0\"/></filter>')({\n            a: .393 + .607 * (1 - e),\n            b: .769 - .769 * (1 - e),\n            c: .189 - .189 * (1 - e),\n            d: .349 - .349 * (1 - e),\n            e: .686 + .314 * (1 - e),\n            f: .168 - .168 * (1 - e),\n            g: .272 - .272 * (1 - e),\n            h: .534 - .534 * (1 - e),\n            i: .131 + .869 * (1 - e)\n          });\n        },\n        saturate: function saturate(t) {\n          var e = Number.isFinite(t.amount) ? t.amount : 1;\n          return joint.util.template('<filter><feColorMatrix type=\"saturate\" values=\"${amount}\"/></filter>')({\n            amount: 1 - e\n          });\n        },\n        hueRotate: function hueRotate(t) {\n          return joint.util.template('<filter><feColorMatrix type=\"hueRotate\" values=\"${angle}\"/></filter>')({\n            angle: t.angle || 0\n          });\n        },\n        invert: function invert(t) {\n          var e = Number.isFinite(t.amount) ? t.amount : 1;\n          return joint.util.template('<filter><feComponentTransfer><feFuncR type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncG type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncB type=\"table\" tableValues=\"${amount} ${amount2}\"/></feComponentTransfer></filter>')({\n            amount: e,\n            amount2: 1 - e\n          });\n        },\n        brightness: function brightness(t) {\n          return joint.util.template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\"/><feFuncG type=\"linear\" slope=\"${amount}\"/><feFuncB type=\"linear\" slope=\"${amount}\"/></feComponentTransfer></filter>')({\n            amount: Number.isFinite(t.amount) ? t.amount : 1\n          });\n        },\n        contrast: function contrast(t) {\n          var e = Number.isFinite(t.amount) ? t.amount : 1;\n          return joint.util.template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncG type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncB type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/></feComponentTransfer></filter>')({\n            amount: e,\n            amount2: .5 - e / 2\n          });\n        }\n      },\n      format: {\n        number: function number(t, e, o) {\n          o = o || {\n            currency: [\"$\", \"\"],\n            decimal: \".\",\n            thousands: \",\",\n            grouping: [3]\n          };\n          var i = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i.exec(t),\n              n = i[1] || \" \",\n              r = i[2] || \">\",\n              s = i[3] || \"\",\n              a = i[4] || \"\",\n              l = i[5],\n              h = +i[6],\n              u = i[7],\n              c = i[8],\n              d = i[9],\n              f = 1,\n              g = \"\",\n              p = \"\",\n              m = !1;\n\n          switch (c && (c = +c.substring(1)), (l || \"0\" === n && \"=\" === r) && (l = n = \"0\", r = \"=\", u && (h -= Math.floor((h - 1) / 4))), d) {\n            case \"n\":\n              u = !0, d = \"g\";\n              break;\n\n            case \"%\":\n              f = 100, p = \"%\", d = \"f\";\n              break;\n\n            case \"p\":\n              f = 100, p = \"%\", d = \"r\";\n              break;\n\n            case \"b\":\n            case \"o\":\n            case \"x\":\n            case \"X\":\n              \"#\" === a && (g = \"0\" + d.toLowerCase());\n              break;\n\n            case \"c\":\n            case \"d\":\n              m = !0, c = 0;\n              break;\n\n            case \"s\":\n              f = -1, d = \"r\";\n          }\n\n          \"$\" === a && (g = o.currency[0], p = o.currency[1]), \"r\" != d || c || (d = \"g\"), null != c && (\"g\" == d ? c = Math.max(1, Math.min(21, c)) : \"e\" != d && \"f\" != d || (c = Math.max(0, Math.min(20, c))));\n          var v = l && u;\n          if (m && e % 1) return \"\";\n          var y = e < 0 || 0 === e && 1 / e < 0 ? (e = -e, \"-\") : s,\n              b = p;\n\n          if (f < 0) {\n            var w = this.prefix(e, c);\n            e = w.scale(e), b = w.symbol + p;\n          } else e *= f;\n\n          var x = (e = this.convert(d, e, c)).lastIndexOf(\".\"),\n              k = x < 0 ? e : e.substring(0, x),\n              A = x < 0 ? \"\" : o.decimal + e.substring(x + 1);\n\n          function j(t) {\n            for (var e = t.length, i = [], n = 0, r = o.grouping[0]; 0 < e && 0 < r;) {\n              i.push(t.substring(e -= r, e + r)), r = o.grouping[n = (n + 1) % o.grouping.length];\n            }\n\n            return i.reverse().join(o.thousands);\n          }\n\n          !l && u && o.grouping && (k = j(k));\n          var P = g.length + k.length + A.length + (v ? 0 : y.length),\n              C = P < h ? new Array(P = h - P + 1).join(n) : \"\";\n          return v && (k = j(C + k)), y += g, e = k + A, (\"<\" === r ? y + e + C : \">\" === r ? C + y + e : \"^\" === r ? C.substring(0, P >>= 1) + y + e + C.substring(P) : y + (v ? e : C + e)) + b;\n        },\n        string: function string(t, e) {\n          for (var i, n = \"{\", r = !1, o = []; -1 !== (i = t.indexOf(n));) {\n            var s, a, l;\n\n            if (s = t.slice(0, i), r) {\n              l = (a = s.split(\":\")).shift().split(\".\"), s = e;\n\n              for (var h = 0; h < l.length; h++) {\n                s = s[l[h]];\n              }\n\n              a.length && (s = this.number(a, s));\n            }\n\n            o.push(s), t = t.slice(i + 1), n = (r = !r) ? \"}\" : \"{\";\n          }\n\n          return o.push(t), o.join(\"\");\n        },\n        convert: function convert(t, e, i) {\n          switch (t) {\n            case \"b\":\n              return e.toString(2);\n\n            case \"c\":\n              return String.fromCharCode(e);\n\n            case \"o\":\n              return e.toString(8);\n\n            case \"x\":\n              return e.toString(16);\n\n            case \"X\":\n              return e.toString(16).toUpperCase();\n\n            case \"g\":\n              return e.toPrecision(i);\n\n            case \"e\":\n              return e.toExponential(i);\n\n            case \"f\":\n              return e.toFixed(i);\n\n            case \"r\":\n              return (e = this.round(e, this.precision(e, i))).toFixed(Math.max(0, Math.min(20, this.precision(e * (1 + 1e-15), i))));\n\n            default:\n              return e + \"\";\n          }\n        },\n        round: function round(t, e) {\n          return e ? Math.round(t * (e = Math.pow(10, e))) / e : Math.round(t);\n        },\n        precision: function precision(t, e) {\n          return e - (t ? Math.ceil(Math.log(t) / Math.LN10) : 1);\n        },\n        prefix: function prefix(t, e) {\n          var i = [\"y\", \"z\", \"a\", \"f\", \"p\", \"n\", \"µ\", \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"].map(function (t, e) {\n            var i = Math.pow(10, 3 * Math.abs(8 - e));\n            return {\n              scale: 8 < e ? function (t) {\n                return t / i;\n              } : function (t) {\n                return t * i;\n              },\n              symbol: t\n            };\n          }),\n              n = 0;\n          return t && (t < 0 && (t *= -1), e && (t = this.round(t, this.precision(t, e))), n = 1 + Math.floor(1e-12 + Math.log(t) / Math.LN10), n = Math.max(-24, Math.min(24, 3 * Math.floor((n <= 0 ? n + 1 : n - 1) / 3)))), i[8 + n / 3];\n        }\n      },\n      template: function template(t) {\n        var e = /<%= ([^ ]+) %>|\\$\\{ ?([^{} ]+) ?\\}|\\{\\{([^{} ]+)\\}\\}/g;\n        return function (n) {\n          return n = n || {}, t.replace(e, function (t) {\n            for (var e = Array.from(arguments).slice(1, 4).find(function (t) {\n              return !!t;\n            }).split(\".\"), i = n[e.shift()]; void 0 !== i && e.length;) {\n              i = i[e.shift()];\n            }\n\n            return void 0 !== i ? i : \"\";\n          });\n        };\n      },\n      toggleFullScreen: function toggleFullScreen(t) {\n        var e = window.top.document;\n\n        function i(t, e) {\n          for (var i = [\"webkit\", \"moz\", \"ms\", \"o\", \"\"], n = 0; n < i.length; n++) {\n            var r = i[n],\n                o = r ? r + e : e.substr(0, 1).toLowerCase() + e.substr(1);\n            if (void 0 !== t[o]) return joint.util.isFunction(t[o]) ? t[o]() : t[o];\n          }\n        }\n\n        t = t || e.body, i(e, \"FullscreenElement\") || i(e, \"FullScreenElement\") ? i(e, \"ExitFullscreen\") || i(e, \"CancelFullScreen\") : i(t, \"RequestFullscreen\") || i(t, \"RequestFullScreen\");\n      },\n      addClassNamePrefix: function addClassNamePrefix(t) {\n        return t ? t.toString().split(\" \").map(function (t) {\n          return t.substr(0, joint.config.classNamePrefix.length) !== joint.config.classNamePrefix && (t = joint.config.classNamePrefix + t), t;\n        }).join(\" \") : t;\n      },\n      removeClassNamePrefix: function removeClassNamePrefix(t) {\n        return t ? t.toString().split(\" \").map(function (t) {\n          return t.substr(0, joint.config.classNamePrefix.length) === joint.config.classNamePrefix && (t = t.substr(joint.config.classNamePrefix.length)), t;\n        }).join(\" \") : t;\n      },\n      wrapWith: function wrapWith(e, t, i) {\n        if (joint.util.isString(i)) {\n          if (!joint.util.wrappers[i]) throw new Error('Unknown wrapper: \"' + i + '\"');\n          i = joint.util.wrappers[i];\n        }\n\n        if (!joint.util.isFunction(i)) throw new Error(\"Wrapper must be a function.\");\n        this.toArray(t).forEach(function (t) {\n          e[t] = i(e[t]);\n        });\n      },\n      wrappers: {\n        cells: function cells(r) {\n          return function () {\n            var t = Array.from(arguments),\n                e = t.length,\n                i = 0 < e && t[0] || [],\n                n = 1 < e && t[e - 1] || {};\n            return Array.isArray(i) || (n instanceof joint.dia.Cell ? i = t : i instanceof joint.dia.Cell && (1 < t.length && t.pop(), i = t)), n instanceof joint.dia.Cell && (n = {}), r.call(this, i, n);\n          };\n        }\n      },\n      parseDOMJSON: function parseDOMJSON(t, e) {\n        for (var i = {}, n = {}, r = V.namespace.xmlns, o = e || r, s = document.createDocumentFragment(), a = [t, s, o]; 0 < a.length;) {\n          o = a.pop();\n\n          for (var l = a.pop(), h = a.pop(), u = 0, c = h.length; u < c; u++) {\n            var d = h[u];\n            if (!d.hasOwnProperty(\"tagName\")) throw new Error(\"json-dom-parser: missing tagName\");\n            var f = d.tagName;\n            d.hasOwnProperty(\"namespaceURI\") && (o = d.namespaceURI);\n            var g = document.createElementNS(o, f),\n                p = o === r,\n                m = p ? V : $,\n                v = d.attributes;\n            v && m(g).attr(v);\n            var y = d.style;\n\n            if (y && $(g).css(y), d.hasOwnProperty(\"className\")) {\n              var b = d.className;\n              p ? g.className.baseVal = b : g.className = b;\n            }\n\n            if (d.hasOwnProperty(\"textContent\") && (g.textContent = d.textContent), d.hasOwnProperty(\"selector\")) {\n              var w = d.selector;\n              if (i[w]) throw new Error(\"json-dom-parser: selector must be unique\");\n              m(i[w] = g).attr(\"joint-selector\", w);\n            }\n\n            if (d.hasOwnProperty(\"groupSelector\")) {\n              var x = d.groupSelector;\n              Array.isArray(x) || (x = [x]);\n\n              for (var k = 0, A = x.length; k < A; k++) {\n                var j = x[k],\n                    P = n[j];\n                P || (P = n[j] = []), P.push(g);\n              }\n            }\n\n            l.appendChild(g);\n            var C = d.children;\n            Array.isArray(C) && a.push(C, g, o);\n          }\n        }\n\n        return {\n          fragment: s,\n          selectors: i,\n          groupSelectors: n\n        };\n      },\n      mixin: _.assign,\n      supplement: _.defaults,\n      deepMixin: _.mixin,\n      deepSupplement: _.defaultsDeep,\n      assign: _.assign,\n      defaults: _.defaults,\n      defaultsDeep: _.defaultsDeep,\n      invoke: _.invokeMap || _.invoke,\n      sortedIndex: _.sortedIndexBy || _.sortedIndex,\n      uniq: _.uniqBy || _.uniq,\n      clone: _.clone,\n      cloneDeep: _.cloneDeep,\n      isEmpty: _.isEmpty,\n      isEqual: _.isEqual,\n      isFunction: _.isFunction,\n      isPlainObject: _.isPlainObject,\n      toArray: _.toArray,\n      debounce: _.debounce,\n      groupBy: _.groupBy,\n      sortBy: _.sortBy,\n      flattenDeep: _.flattenDeep,\n      without: _.without,\n      difference: _.difference,\n      intersection: _.intersection,\n      union: _.union,\n      has: _.has,\n      result: _.result,\n      omit: _.omit,\n      pick: _.pick,\n      bindAll: _.bindAll,\n      forIn: _.forIn,\n      camelCase: _.camelCase,\n      uniqueId: _.uniqueId,\n      merge: function merge() {\n        if (_.mergeWith) {\n          var t = Array.from(arguments),\n              e = t[t.length - 1],\n              n = this.isFunction(e) ? e : this.noop;\n          return t.push(function (t, e) {\n            var i = n(t, e);\n            return void 0 !== i ? i : Array.isArray(t) && !Array.isArray(e) ? e : void 0;\n          }), _.mergeWith.apply(this, t);\n        }\n\n        return _.merge.apply(this, arguments);\n      },\n      isBoolean: function isBoolean(t) {\n        var e = Object.prototype.toString;\n        return !0 === t || !1 === t || !!t && \"object\" == typeof t && \"[object Boolean]\" === e.call(t);\n      },\n      isObject: function isObject(t) {\n        return !!t && (\"object\" == typeof t || \"function\" == typeof t);\n      },\n      isNumber: function isNumber(t) {\n        var e = Object.prototype.toString;\n        return \"number\" == typeof t || !!t && \"object\" == typeof t && \"[object Number]\" === e.call(t);\n      },\n      isString: function isString(t) {\n        var e = Object.prototype.toString;\n        return \"string\" == typeof t || !!t && \"object\" == typeof t && \"[object String]\" === e.call(t);\n      },\n      noop: function noop() {}\n    }\n  };\n  joint.mvc.View = Backbone.View.extend({\n    options: {},\n    theme: null,\n    themeClassNamePrefix: joint.util.addClassNamePrefix(\"theme-\"),\n    requireSetThemeOverride: !1,\n    defaultTheme: joint.config.defaultTheme,\n    children: null,\n    childNodes: null,\n    constructor: function constructor(t) {\n      this.requireSetThemeOverride = t && !!t.theme, this.options = joint.util.assign({}, this.options, t), Backbone.View.call(this, t);\n    },\n    initialize: function initialize(t) {\n      joint.util.bindAll(this, \"setTheme\", \"onSetTheme\", \"remove\", \"onRemove\"), (joint.mvc.views[this.cid] = this).setTheme(this.options.theme || this.defaultTheme), this.init();\n    },\n    renderChildren: function renderChildren(t) {\n      if (t || (t = this.children), t) {\n        var e = V.namespace[this.svgElement ? \"xmlns\" : \"xhtml\"],\n            i = joint.util.parseDOMJSON(t, e);\n        this.vel.empty().append(i.fragment), this.childNodes = i.selectors;\n      }\n\n      return this;\n    },\n    findAttribute: function findAttribute(t, e) {\n      for (var i = e; i && 1 === i.nodeType;) {\n        var n = i.getAttribute(t);\n        if (n) return n;\n        if (i === this.el) return null;\n        i = i.parentNode;\n      }\n\n      return null;\n    },\n    _ensureElement: function _ensureElement() {\n      if (this.el) this.setElement(joint.util.result(this, \"el\"));else {\n        var t = joint.util.result(this, \"tagName\"),\n            e = joint.util.assign({}, joint.util.result(this, \"attributes\"));\n        this.id && (e.id = joint.util.result(this, \"id\")), this.setElement(this._createElement(t)), this._setAttributes(e);\n      }\n\n      this._ensureElClassName();\n    },\n    _setAttributes: function _setAttributes(t) {\n      this.svgElement ? this.vel.attr(t) : this.$el.attr(t);\n    },\n    _createElement: function _createElement(t) {\n      return this.svgElement ? document.createElementNS(V.namespace.xmlns, t) : document.createElement(t);\n    },\n    _setElement: function _setElement(t) {\n      this.$el = t instanceof Backbone.$ ? t : Backbone.$(t), this.el = this.$el[0], this.svgElement && (this.vel = V(this.el));\n    },\n    _ensureElClassName: function _ensureElClassName() {\n      var t = joint.util.result(this, \"className\");\n\n      if (t) {\n        var e = joint.util.addClassNamePrefix(t);\n        this.svgElement ? this.vel.removeClass(t).addClass(e) : this.$el.removeClass(t).addClass(e);\n      }\n    },\n    init: function init() {},\n    onRender: function onRender() {},\n    setTheme: function setTheme(t, e) {\n      return e = e || {}, this.theme && this.requireSetThemeOverride && !e.override || (this.removeThemeClassName(), this.addThemeClassName(t), this.onSetTheme(this.theme, t), this.theme = t), this;\n    },\n    addThemeClassName: function addThemeClassName(t) {\n      t = t || this.theme;\n      var e = this.themeClassNamePrefix + t;\n      return this.svgElement ? this.vel.addClass(e) : this.$el.addClass(e), this;\n    },\n    removeThemeClassName: function removeThemeClassName(t) {\n      t = t || this.theme;\n      var e = this.themeClassNamePrefix + t;\n      return this.svgElement ? this.vel.removeClass(e) : this.$el.removeClass(e), this;\n    },\n    onSetTheme: function onSetTheme(t, e) {},\n    remove: function remove() {\n      return this.onRemove(), this.undelegateDocumentEvents(), joint.mvc.views[this.cid] = null, Backbone.View.prototype.remove.apply(this, arguments), this;\n    },\n    onRemove: function onRemove() {},\n    getEventNamespace: function getEventNamespace() {\n      return \".joint-event-ns-\" + this.cid;\n    },\n    delegateElementEvents: function delegateElementEvents(t, e, i) {\n      if (!e) return this;\n      i || (i = {});\n      var n = this.getEventNamespace();\n\n      for (var r in e) {\n        var o = e[r];\n        \"function\" != typeof o && (o = this[o]), o && $(t).on(r + n, i, o.bind(this));\n      }\n\n      return this;\n    },\n    undelegateElementEvents: function undelegateElementEvents(t) {\n      return $(t).off(this.getEventNamespace()), this;\n    },\n    delegateDocumentEvents: function delegateDocumentEvents(t, e) {\n      return t || (t = joint.util.result(this, \"documentEvents\")), this.delegateElementEvents(document, t, e);\n    },\n    undelegateDocumentEvents: function undelegateDocumentEvents() {\n      return this.undelegateElementEvents(document);\n    },\n    eventData: function eventData(t, e) {\n      if (!t) throw new Error(\"eventData(): event object required.\");\n      var i = t.data,\n          n = \"__\" + this.cid + \"__\";\n      return void 0 === e ? i && i[n] || {} : (i || (i = t.data = {}), i[n] || (i[n] = {}), joint.util.assign(i[n], e), this);\n    },\n    stopPropagation: function stopPropagation(t) {\n      return this.eventData(t, {\n        propagationStopped: !0\n      }), this;\n    },\n    isPropagationStopped: function isPropagationStopped(t) {\n      return !!this.eventData(t).propagationStopped;\n    }\n  }, {\n    extend: function extend() {\n      var t = Array.from(arguments),\n          e = t[0] && joint.util.assign({}, t[0]) || {},\n          i = t[1] && joint.util.assign({}, t[1]) || {},\n          n = e.render || this.prototype && this.prototype.render || null;\n      return e.render = function () {\n        return \"function\" == typeof n && n.apply(this, arguments), this.render.__render__ === n && this.onRender(), this;\n      }, e.render.__render__ = n, Backbone.View.extend.call(this, e, i);\n    }\n  }), joint.dia.GraphCells = Backbone.Collection.extend({\n    cellNamespace: joint.shapes,\n    initialize: function initialize(t, e) {\n      e.cellNamespace && (this.cellNamespace = e.cellNamespace), this.graph = e.graph;\n    },\n    model: function model(t, e) {\n      var i = e.collection,\n          n = i.cellNamespace,\n          r = new (\"link\" === t.type ? joint.dia.Link : joint.util.getByPath(n, t.type, \".\") || joint.dia.Element)(t, e);\n      return e.dry || (r.graph = i.graph), r;\n    },\n    comparator: function comparator(t) {\n      return t.get(\"z\") || 0;\n    }\n  }), joint.dia.Graph = Backbone.Model.extend({\n    _batches: {},\n    initialize: function initialize(t, e) {\n      e = e || {};\n      var i = new joint.dia.GraphCells([], {\n        model: e.cellModel,\n        cellNamespace: e.cellNamespace,\n        graph: this\n      });\n      Backbone.Model.prototype.set.call(this, \"cells\", i), i.on(\"all\", this.trigger, this), this.on(\"change:z\", this._sortOnChangeZ, this), this._out = {}, this._in = {}, this._nodes = {}, this._edges = {}, i.on(\"add\", this._restructureOnAdd, this), i.on(\"remove\", this._restructureOnRemove, this), i.on(\"reset\", this._restructureOnReset, this), i.on(\"change:source\", this._restructureOnChangeSource, this), i.on(\"change:target\", this._restructureOnChangeTarget, this), i.on(\"remove\", this._removeCell, this);\n    },\n    _sortOnChangeZ: function _sortOnChangeZ() {\n      this.get(\"cells\").sort();\n    },\n    _restructureOnAdd: function _restructureOnAdd(t) {\n      if (t.isLink()) {\n        this._edges[t.id] = !0;\n        var e = t.source(),\n            i = t.target();\n        e.id && ((this._out[e.id] || (this._out[e.id] = {}))[t.id] = !0), i.id && ((this._in[i.id] || (this._in[i.id] = {}))[t.id] = !0);\n      } else this._nodes[t.id] = !0;\n    },\n    _restructureOnRemove: function _restructureOnRemove(t) {\n      if (t.isLink()) {\n        delete this._edges[t.id];\n        var e = t.source(),\n            i = t.target();\n        e.id && this._out[e.id] && this._out[e.id][t.id] && delete this._out[e.id][t.id], i.id && this._in[i.id] && this._in[i.id][t.id] && delete this._in[i.id][t.id];\n      } else delete this._nodes[t.id];\n    },\n    _restructureOnReset: function _restructureOnReset(t) {\n      t = t.models, this._out = {}, this._in = {}, this._nodes = {}, this._edges = {}, t.forEach(this._restructureOnAdd, this);\n    },\n    _restructureOnChangeSource: function _restructureOnChangeSource(t) {\n      var e = t.previous(\"source\");\n      e.id && this._out[e.id] && delete this._out[e.id][t.id];\n      var i = t.source();\n      i.id && ((this._out[i.id] || (this._out[i.id] = {}))[t.id] = !0);\n    },\n    _restructureOnChangeTarget: function _restructureOnChangeTarget(t) {\n      var e = t.previous(\"target\");\n      e.id && this._in[e.id] && delete this._in[e.id][t.id];\n      var i = t.get(\"target\");\n      i.id && ((this._in[i.id] || (this._in[i.id] = {}))[t.id] = !0);\n    },\n    getOutboundEdges: function getOutboundEdges(t) {\n      return this._out && this._out[t] || {};\n    },\n    getInboundEdges: function getInboundEdges(t) {\n      return this._in && this._in[t] || {};\n    },\n    toJSON: function toJSON() {\n      var t = Backbone.Model.prototype.toJSON.apply(this, arguments);\n      return t.cells = this.get(\"cells\").toJSON(), t;\n    },\n    fromJSON: function fromJSON(t, e) {\n      if (!t.cells) throw new Error(\"Graph JSON must contain cells array.\");\n      return this.set(t, e);\n    },\n    set: function set(t, e, i) {\n      var n;\n      return \"object\" == typeof t ? (n = t, i = e) : (n = {})[t] = e, n.hasOwnProperty(\"cells\") && (this.resetCells(n.cells, i), n = joint.util.omit(n, \"cells\")), Backbone.Model.prototype.set.call(this, n, i);\n    },\n    clear: function clear(t) {\n      t = joint.util.assign({}, t, {\n        clear: !0\n      });\n      var e = this.get(\"cells\");\n      if (0 === e.length) return this;\n      this.startBatch(\"clear\", t);\n\n      for (var i = e.sortBy(function (t) {\n        return t.isLink() ? 1 : 2;\n      }); i.shift().remove(t), 0 < i.length;) {\n        ;\n      }\n\n      return this.stopBatch(\"clear\"), this;\n    },\n    _prepareCell: function _prepareCell(t, e) {\n      var i;\n      if (t instanceof Backbone.Model ? (i = t.attributes, t.graph || e && e.dry || (t.graph = this)) : i = t, !joint.util.isString(i.type)) throw new TypeError(\"dia.Graph: cell type must be a string.\");\n      return t;\n    },\n    minZIndex: function minZIndex() {\n      var t = this.get(\"cells\").first();\n      return t && t.get(\"z\") || 0;\n    },\n    maxZIndex: function maxZIndex() {\n      var t = this.get(\"cells\").last();\n      return t && t.get(\"z\") || 0;\n    },\n    addCell: function addCell(t, e) {\n      return Array.isArray(t) ? this.addCells(t, e) : (t instanceof Backbone.Model ? t.has(\"z\") || t.set(\"z\", this.maxZIndex() + 1) : void 0 === t.z && (t.z = this.maxZIndex() + 1), this.get(\"cells\").add(this._prepareCell(t, e), e || {}), this);\n    },\n    addCells: function addCells(t, e) {\n      return t.length && (t = joint.util.flattenDeep(t), e.position = t.length, this.startBatch(\"add\"), t.forEach(function (t) {\n        e.position--, this.addCell(t, e);\n      }, this), this.stopBatch(\"add\")), this;\n    },\n    resetCells: function resetCells(t, e) {\n      var i = joint.util.toArray(t).map(function (t) {\n        return this._prepareCell(t, e);\n      }, this);\n      return this.get(\"cells\").reset(i, e), this;\n    },\n    removeCells: function removeCells(t, e) {\n      return t.length && (this.startBatch(\"remove\"), joint.util.invoke(t, \"remove\", e), this.stopBatch(\"remove\")), this;\n    },\n    _removeCell: function _removeCell(t, e, i) {\n      (i = i || {}).clear || (i.disconnectLinks ? this.disconnectLinks(t, i) : this.removeLinks(t, i)), this.get(\"cells\").remove(t, {\n        silent: !0\n      }), t.graph === this && (t.graph = null);\n    },\n    getCell: function getCell(t) {\n      return this.get(\"cells\").get(t);\n    },\n    getCells: function getCells() {\n      return this.get(\"cells\").toArray();\n    },\n    getElements: function getElements() {\n      return Object.keys(this._nodes).map(this.getCell, this);\n    },\n    getLinks: function getLinks() {\n      return Object.keys(this._edges).map(this.getCell, this);\n    },\n    getFirstCell: function getFirstCell() {\n      return this.get(\"cells\").first();\n    },\n    getLastCell: function getLastCell() {\n      return this.get(\"cells\").last();\n    },\n    getConnectedLinks: function getConnectedLinks(t, o) {\n      var e = (o = o || {}).inbound,\n          i = o.outbound;\n      void 0 === e && void 0 === i && (e = i = !0);\n      var s = [],\n          a = {};\n\n      if (i && joint.util.forIn(this.getOutboundEdges(t.id), function (t, e) {\n        a[e] || (s.push(this.getCell(e)), a[e] = !0);\n      }.bind(this)), e && joint.util.forIn(this.getInboundEdges(t.id), function (t, e) {\n        a[e] || (s.push(this.getCell(e)), a[e] = !0);\n      }.bind(this)), o.deep) {\n        var n = t.getEmbeddedCells({\n          deep: !0\n        }),\n            l = {};\n        n.forEach(function (t) {\n          t.isElement() && (l[t.id] = !0);\n        }), n.forEach(function (t) {\n          t.isLink() || (i && joint.util.forIn(this.getOutboundEdges(t.id), function (t, e) {\n            if (!a[e]) {\n              var i = this.getCell(e),\n                  n = i.source().id,\n                  r = i.target().id;\n              if (!o.includeEnclosed && n && l[n] && r && l[r]) return;\n              s.push(this.getCell(e)), a[e] = !0;\n            }\n          }.bind(this)), e && joint.util.forIn(this.getInboundEdges(t.id), function (t, e) {\n            if (!a[e]) {\n              var i = this.getCell(e),\n                  n = i.source().id,\n                  r = i.target().id;\n              if (!o.includeEnclosed && n && l[n] && r && l[r]) return;\n              s.push(this.getCell(e)), a[e] = !0;\n            }\n          }.bind(this)));\n        }, this);\n      }\n\n      return s;\n    },\n    getNeighbors: function getNeighbors(a, l) {\n      var h = (l = l || {}).inbound,\n          u = l.outbound;\n      void 0 === h && void 0 === u && (h = u = !0);\n      var t = this.getConnectedLinks(a, l).reduce(function (t, e) {\n        var i = e.source(),\n            n = e.target(),\n            r = e.hasLoop(l);\n\n        if (h && joint.util.has(i, \"id\") && !t[i.id]) {\n          var o = this.getCell(i.id);\n          !r && (!o || o === a || l.deep && o.isEmbeddedIn(a)) || (t[i.id] = o);\n        }\n\n        if (u && joint.util.has(n, \"id\") && !t[n.id]) {\n          var s = this.getCell(n.id);\n          !r && (!s || s === a || l.deep && s.isEmbeddedIn(a)) || (t[n.id] = s);\n        }\n\n        return t;\n      }.bind(this), {});\n      return joint.util.toArray(t);\n    },\n    getCommonAncestor: function getCommonAncestor() {\n      var t = Array.from(arguments).map(function (t) {\n        for (var e = [], i = t.get(\"parent\"); i;) {\n          e.push(i), i = this.getCell(i).get(\"parent\");\n        }\n\n        return e;\n      }, this);\n      t = t.sort(function (t, e) {\n        return t.length - e.length;\n      });\n      var e = joint.util.toArray(t.shift()).find(function (e) {\n        return t.every(function (t) {\n          return t.includes(e);\n        });\n      });\n      return this.getCell(e);\n    },\n    getSuccessors: function getSuccessors(e, t) {\n      t = t || {};\n      var i = [];\n      return this.search(e, function (t) {\n        t !== e && i.push(t);\n      }, joint.util.assign({}, t, {\n        outbound: !0\n      })), i;\n    },\n    cloneCells: function cloneCells(t) {\n      t = joint.util.uniq(t);\n      var s = joint.util.toArray(t).reduce(function (t, e) {\n        return t[e.id] = e.clone(), t;\n      }, {});\n      return joint.util.toArray(t).forEach(function (t) {\n        var e = s[t.id];\n\n        if (e.isLink()) {\n          var i = e.source(),\n              n = e.target();\n          i.id && s[i.id] && e.prop(\"source/id\", s[i.id].id), n.id && s[n.id] && e.prop(\"target/id\", s[n.id].id);\n        }\n\n        var r = t.get(\"parent\");\n        r && s[r] && e.set(\"parent\", s[r].id);\n        var o = joint.util.toArray(t.get(\"embeds\")).reduce(function (t, e) {\n          return s[e] && t.push(s[e].id), t;\n        }, []);\n        joint.util.isEmpty(o) || e.set(\"embeds\", o);\n      }), s;\n    },\n    cloneSubgraph: function cloneSubgraph(t, e) {\n      var i = this.getSubgraph(t, e);\n      return this.cloneCells(i);\n    },\n    getSubgraph: function getSubgraph(t, e) {\n      e = e || {};\n      var o = [],\n          s = {},\n          a = [],\n          i = [];\n      return joint.util.toArray(t).forEach(function (t) {\n        (s[t.id] || (o.push(t), (s[t.id] = t).isLink() ? i.push(t) : a.push(t)), e.deep) && t.getEmbeddedCells({\n          deep: !0\n        }).forEach(function (t) {\n          s[t.id] || (o.push(t), (s[t.id] = t).isLink() ? i.push(t) : a.push(t));\n        });\n      }), i.forEach(function (t) {\n        var e = t.source(),\n            i = t.target();\n\n        if (e.id && !s[e.id]) {\n          var n = this.getCell(e.id);\n          o.push(n), s[n.id] = n, a.push(n);\n        }\n\n        if (i.id && !s[i.id]) {\n          var r = this.getCell(i.id);\n          o.push(this.getCell(i.id)), s[r.id] = r, a.push(r);\n        }\n      }, this), a.forEach(function (t) {\n        this.getConnectedLinks(t, e).forEach(function (t) {\n          var e = t.source(),\n              i = t.target();\n          !s[t.id] && e.id && s[e.id] && i.id && s[i.id] && (o.push(t), s[t.id] = t);\n        });\n      }, this), o;\n    },\n    getPredecessors: function getPredecessors(e, t) {\n      t = t || {};\n      var i = [];\n      return this.search(e, function (t) {\n        t !== e && i.push(t);\n      }, joint.util.assign({}, t, {\n        inbound: !0\n      })), i;\n    },\n    search: function search(t, e, i) {\n      (i = i || {}).breadthFirst ? this.bfs(t, e, i) : this.dfs(t, e, i);\n    },\n    bfs: function bfs(t, e, i) {\n      i = i || {};\n      var n = {},\n          r = {},\n          o = [];\n\n      for (o.push(t), r[t.id] = 0; 0 < o.length;) {\n        var s = o.shift();\n\n        if (!n[s.id]) {\n          if (!(n[s.id] = !0) === e(s, r[s.id])) return;\n          this.getNeighbors(s, i).forEach(function (t) {\n            r[t.id] = r[s.id] + 1, o.push(t);\n          });\n        }\n      }\n    },\n    dfs: function dfs(t, e, i, n, r) {\n      i = i || {};\n      var o = n || {},\n          s = r || 0;\n      !1 !== e(t, s) && (o[t.id] = !0, this.getNeighbors(t, i).forEach(function (t) {\n        o[t.id] || this.dfs(t, e, i, o, s + 1);\n      }, this));\n    },\n    getSources: function getSources() {\n      var i = [];\n      return joint.util.forIn(this._nodes, function (t, e) {\n        this._in[e] && !joint.util.isEmpty(this._in[e]) || i.push(this.getCell(e));\n      }.bind(this)), i;\n    },\n    getSinks: function getSinks() {\n      var i = [];\n      return joint.util.forIn(this._nodes, function (t, e) {\n        this._out[e] && !joint.util.isEmpty(this._out[e]) || i.push(this.getCell(e));\n      }.bind(this)), i;\n    },\n    isSource: function isSource(t) {\n      return !this._in[t.id] || joint.util.isEmpty(this._in[t.id]);\n    },\n    isSink: function isSink(t) {\n      return !this._out[t.id] || joint.util.isEmpty(this._out[t.id]);\n    },\n    isSuccessor: function isSuccessor(e, i) {\n      var n = !1;\n      return this.search(e, function (t) {\n        if (t === i && t !== e) return !(n = !0);\n      }, {\n        outbound: !0\n      }), n;\n    },\n    isPredecessor: function isPredecessor(e, i) {\n      var n = !1;\n      return this.search(e, function (t) {\n        if (t === i && t !== e) return !(n = !0);\n      }, {\n        inbound: !0\n      }), n;\n    },\n    isNeighbor: function isNeighbor(t, n, e) {\n      var r = (e = e || {}).inbound,\n          o = e.outbound;\n      void 0 === r && void 0 === o && (r = o = !0);\n      var s = !1;\n      return this.getConnectedLinks(t, e).forEach(function (t) {\n        var e = t.source(),\n            i = t.target();\n        return r && joint.util.has(e, \"id\") && e.id === n.id ? !(s = !0) : o && joint.util.has(i, \"id\") && i.id === n.id ? !(s = !0) : void 0;\n      }), s;\n    },\n    disconnectLinks: function disconnectLinks(e, i) {\n      this.getConnectedLinks(e).forEach(function (t) {\n        t.set(t.source().id === e.id ? \"source\" : \"target\", {\n          x: 0,\n          y: 0\n        }, i);\n      });\n    },\n    removeLinks: function removeLinks(t, e) {\n      joint.util.invoke(this.getConnectedLinks(t), \"remove\", e);\n    },\n    findModelsFromPoint: function findModelsFromPoint(e) {\n      return this.getElements().filter(function (t) {\n        return t.getBBox().containsPoint(e);\n      });\n    },\n    findModelsInArea: function findModelsInArea(e, t) {\n      e = g.rect(e);\n      var i = (t = joint.util.defaults(t || {}, {\n        strict: !1\n      })).strict ? \"containsRect\" : \"intersect\";\n      return this.getElements().filter(function (t) {\n        return e[i](t.getBBox());\n      });\n    },\n    findModelsUnderElement: function findModelsUnderElement(e, t) {\n      t = joint.util.defaults(t || {}, {\n        searchBy: \"bbox\"\n      });\n      var i = e.getBBox();\n      return (\"bbox\" === t.searchBy ? this.findModelsInArea(i) : this.findModelsFromPoint(i[t.searchBy]())).filter(function (t) {\n        return e.id !== t.id && !t.isEmbeddedIn(e);\n      });\n    },\n    getBBox: function getBBox(t, e) {\n      return this.getCellsBBox(t || this.getElements(), e);\n    },\n    getCellsBBox: function getCellsBBox(t, r) {\n      return joint.util.toArray(t).reduce(function (t, e) {\n        if (e.isLink()) return t;\n        var i = e.getBBox(r),\n            n = e.angle();\n        return n && (i = i.bbox(n)), t ? t.union(i) : i;\n      }, null);\n    },\n    translate: function translate(t, e, i) {\n      var n = this.getCells().filter(function (t) {\n        return !t.isEmbedded();\n      });\n      return joint.util.invoke(n, \"translate\", t, e, i), this;\n    },\n    resize: function resize(t, e, i) {\n      return this.resizeCells(t, e, this.getCells(), i);\n    },\n    resizeCells: function resizeCells(t, e, i, n) {\n      var r = this.getCellsBBox(i);\n\n      if (r) {\n        var o = Math.max(t / r.width, 0),\n            s = Math.max(e / r.height, 0);\n        joint.util.invoke(i, \"scale\", o, s, r.origin(), n);\n      }\n\n      return this;\n    },\n    startBatch: function startBatch(t, e) {\n      return e = e || {}, this._batches[t] = (this._batches[t] || 0) + 1, this.trigger(\"batch:start\", joint.util.assign({}, e, {\n        batchName: t\n      }));\n    },\n    stopBatch: function stopBatch(t, e) {\n      return e = e || {}, this._batches[t] = (this._batches[t] || 0) - 1, this.trigger(\"batch:stop\", joint.util.assign({}, e, {\n        batchName: t\n      }));\n    },\n    hasActiveBatch: function hasActiveBatch(t) {\n      return 0 === arguments.length ? joint.util.toArray(this._batches).some(function (t) {\n        return 0 < t;\n      }) : Array.isArray(t) ? t.some(function (t) {\n        return !!this._batches[t];\n      }, this) : !!this._batches[t];\n    }\n  }, {\n    validations: {\n      multiLinks: function multiLinks(t, e) {\n        var n = e.source(),\n            r = e.target();\n\n        if (n.id && r.id) {\n          var i = e.getSourceElement();\n          if (i) if (1 < t.getConnectedLinks(i, {\n            outbound: !0\n          }).filter(function (t) {\n            var e = t.source(),\n                i = t.target();\n            return e && e.id === n.id && (!e.port || e.port === n.port) && i && i.id === r.id && (!i.port || i.port === r.port);\n          }).length) return !1;\n        }\n\n        return !0;\n      },\n      linkPinning: function linkPinning(t, e) {\n        return e.source().id && e.target().id;\n      }\n    }\n  }), joint.util.wrapWith(joint.dia.Graph.prototype, [\"resetCells\", \"addCells\", \"removeCells\"], \"cells\"), function (l, f, h, m, g) {\n    function t(o, s) {\n      return function (t, e) {\n        var i = g.isPercentage(t);\n        t = parseFloat(t), i && (t /= 100);\n        var n = {};\n\n        if (isFinite(t)) {\n          var r = i || 0 <= t && t <= 1 ? t * e[s] : Math.max(t + e[s], 0);\n          n[o] = r;\n        }\n\n        return n;\n      };\n    }\n\n    function e(s, a, l) {\n      return function (t, e) {\n        var i,\n            n = g.isPercentage(t);\n\n        if (t = parseFloat(t), n && (t /= 100), isFinite(t)) {\n          var r = e[l]();\n          i = n || 0 < t && t < 1 ? r[s] + e[a] * t : r[s] + t;\n        }\n\n        var o = h.Point();\n        return o[s] = i || 0, o;\n      };\n    }\n\n    function i(r, o, s) {\n      return function (t, e) {\n        var i;\n        i = \"middle\" === t ? e[o] / 2 : t === s ? e[o] : isFinite(t) ? -1 < t && t < 1 ? -e[o] * t : -t : g.isPercentage(t) ? e[o] * parseFloat(t) / 100 : 0;\n        var n = h.Point();\n        return n[r] = -(e[r] + i), n;\n      };\n    }\n\n    function r(f, t) {\n      var g = \"joint-shape\",\n          p = t && t.resetOffset;\n      return function (t, e, i) {\n        var n = m(i),\n            r = n.data(g);\n\n        if (!r || r.value !== t) {\n          var o = f(t);\n          r = {\n            value: t,\n            shape: o,\n            shapeBBox: o.bbox()\n          }, n.data(g, r);\n        }\n\n        var s = r.shape.clone(),\n            a = r.shapeBBox.clone(),\n            l = a.origin(),\n            h = e.origin();\n        a.x = h.x, a.y = h.y;\n        var u = e.maxRectScaleToFit(a, h),\n            c = 0 === a.width || 0 === e.width ? 1 : u.sx,\n            d = 0 === a.height || 0 === e.height ? 1 : u.sy;\n        return s.scale(c, d, l), p && s.translate(-l.x, -l.y), s;\n      };\n    }\n\n    function n(t) {\n      var n = r(function (t) {\n        return new h.Path(f.normalizePathData(t));\n      }, t);\n      return function (t, e, i) {\n        return {\n          d: n(t, e, i).serialize()\n        };\n      };\n    }\n\n    function o(t) {\n      var n = r(h.Polyline, t);\n      return function (t, e, i) {\n        return {\n          points: n(t, e, i).serialize()\n        };\n      };\n    }\n\n    function s(r, o) {\n      var s = new h.Point(1, 0);\n      return function (t) {\n        var e,\n            i,\n            n = this[r](t);\n        return n ? (i = o.rotate ? n.vector().vectorAngle(s) : 0, e = n.start) : (e = this.path.start, i = 0), 0 === i ? {\n          transform: \"translate(\" + e.x + \",\" + e.y + \")\"\n        } : {\n          transform: \"translate(\" + e.x + \",\" + e.y + \") rotate(\" + i + \")\"\n        };\n      };\n    }\n\n    function a(t, e, i) {\n      return void 0 !== i.text;\n    }\n\n    function u() {\n      return this instanceof l.dia.LinkView;\n    }\n\n    function c(t) {\n      var e = {},\n          i = t.stroke;\n      \"string\" == typeof i && (e.stroke = i, e.fill = i);\n      var n = t.strokeOpacity;\n      return void 0 === n && (n = t[\"stroke-opacity\"]), void 0 === n && (n = t.opacity), void 0 !== n && (e[\"stroke-opacity\"] = n, e[\"fill-opacity\"] = n), e;\n    }\n\n    var d,\n        p,\n        v = l.dia.attributes = {\n      xlinkHref: {\n        set: \"xlink:href\"\n      },\n      xlinkShow: {\n        set: \"xlink:show\"\n      },\n      xlinkRole: {\n        set: \"xlink:role\"\n      },\n      xlinkType: {\n        set: \"xlink:type\"\n      },\n      xlinkArcrole: {\n        set: \"xlink:arcrole\"\n      },\n      xlinkTitle: {\n        set: \"xlink:title\"\n      },\n      xlinkActuate: {\n        set: \"xlink:actuate\"\n      },\n      xmlSpace: {\n        set: \"xml:space\"\n      },\n      xmlBase: {\n        set: \"xml:base\"\n      },\n      xmlLang: {\n        set: \"xml:lang\"\n      },\n      preserveAspectRatio: {\n        set: \"preserveAspectRatio\"\n      },\n      requiredExtension: {\n        set: \"requiredExtension\"\n      },\n      requiredFeatures: {\n        set: \"requiredFeatures\"\n      },\n      systemLanguage: {\n        set: \"systemLanguage\"\n      },\n      externalResourcesRequired: {\n        set: \"externalResourceRequired\"\n      },\n      filter: {\n        qualify: g.isPlainObject,\n        set: function set(t) {\n          return \"url(#\" + this.paper.defineFilter(t) + \")\";\n        }\n      },\n      fill: {\n        qualify: g.isPlainObject,\n        set: function set(t) {\n          return \"url(#\" + this.paper.defineGradient(t) + \")\";\n        }\n      },\n      stroke: {\n        qualify: g.isPlainObject,\n        set: function set(t) {\n          return \"url(#\" + this.paper.defineGradient(t) + \")\";\n        }\n      },\n      sourceMarker: {\n        qualify: g.isPlainObject,\n        set: function set(t, e, i, n) {\n          return t = g.assign(c(n), t), {\n            \"marker-start\": \"url(#\" + this.paper.defineMarker(t) + \")\"\n          };\n        }\n      },\n      targetMarker: {\n        qualify: g.isPlainObject,\n        set: function set(t, e, i, n) {\n          return t = g.assign(c(n), {\n            transform: \"rotate(180)\"\n          }, t), {\n            \"marker-end\": \"url(#\" + this.paper.defineMarker(t) + \")\"\n          };\n        }\n      },\n      vertexMarker: {\n        qualify: g.isPlainObject,\n        set: function set(t, e, i, n) {\n          return t = g.assign(c(n), t), {\n            \"marker-mid\": \"url(#\" + this.paper.defineMarker(t) + \")\"\n          };\n        }\n      },\n      text: {\n        qualify: function qualify(t, e, i) {\n          return !i.textWrap || !g.isPlainObject(i.textWrap);\n        },\n        set: function set(t, e, i, n) {\n          var r = m(i),\n              o = \"joint-text\",\n              s = r.data(o),\n              a = g.pick(n, \"lineHeight\", \"annotations\", \"textPath\", \"x\", \"textVerticalAnchor\", \"eol\"),\n              l = a.fontSize = n[\"font-size\"] || n.fontSize,\n              h = JSON.stringify([t, a]);\n\n          if (void 0 === s || s !== h) {\n            l && i.setAttribute(\"font-size\", l);\n            var u = a.textPath;\n\n            if (g.isObject(u)) {\n              var c = u.selector;\n\n              if (\"string\" == typeof c) {\n                var d = this.findBySelector(c)[0];\n                d instanceof SVGPathElement && (a.textPath = g.assign({\n                  \"xlink:href\": \"#\" + d.id\n                }, u));\n              }\n            }\n\n            f(i).text(\"\" + t, a), r.data(o, h);\n          }\n        }\n      },\n      textWrap: {\n        qualify: g.isPlainObject,\n        set: function set(t, e, i, n) {\n          var r = t.width || 0;\n          g.isPercentage(r) ? e.width *= parseFloat(r) / 100 : r <= 0 ? e.width += r : e.width = r;\n          var o,\n              s = t.height || 0;\n          g.isPercentage(s) ? e.height *= parseFloat(s) / 100 : s <= 0 ? e.height += s : e.height = s;\n          var a = t.text;\n          void 0 === a && (a = n.text), o = void 0 !== a ? g.breakText(\"\" + a, e, {\n            \"font-weight\": n[\"font-weight\"] || n.fontWeight,\n            \"font-size\": n[\"font-size\"] || n.fontSize,\n            \"font-family\": n[\"font-family\"] || n.fontFamily,\n            lineHeight: n.lineHeight\n          }, {\n            svgDocument: this.paper.svg,\n            ellipsis: t.ellipsis\n          }) : \"\", l.dia.attributes.text.set.call(this, o, e, i, n);\n        }\n      },\n      title: {\n        qualify: function qualify(t, e) {\n          return e instanceof SVGElement;\n        },\n        set: function set(t, e, i) {\n          var n = m(i),\n              r = \"joint-title\",\n              o = n.data(r);\n\n          if (void 0 === o || o !== t) {\n            n.data(r, t);\n            var s = i.firstChild;\n            if (s && \"TITLE\" === s.tagName.toUpperCase()) s.textContent = t;else {\n              var a = document.createElementNS(i.namespaceURI, \"title\");\n              a.textContent = t, i.insertBefore(a, s);\n            }\n          }\n        }\n      },\n      lineHeight: {\n        qualify: a\n      },\n      textVerticalAnchor: {\n        qualify: a\n      },\n      textPath: {\n        qualify: a\n      },\n      annotations: {\n        qualify: a\n      },\n      port: {\n        set: function set(t) {\n          return null === t || void 0 === t.id ? t : t.id;\n        }\n      },\n      style: {\n        qualify: g.isPlainObject,\n        set: function set(t, e, i) {\n          m(i).css(t);\n        }\n      },\n      html: {\n        set: function set(t, e, i) {\n          m(i).html(t + \"\");\n        }\n      },\n      ref: {},\n      refX: {\n        position: e(\"x\", \"width\", \"origin\")\n      },\n      refY: {\n        position: e(\"y\", \"height\", \"origin\")\n      },\n      refDx: {\n        position: e(\"x\", \"width\", \"corner\")\n      },\n      refDy: {\n        position: e(\"y\", \"height\", \"corner\")\n      },\n      refWidth: {\n        set: t(\"width\", \"width\")\n      },\n      refHeight: {\n        set: t(\"height\", \"height\")\n      },\n      refRx: {\n        set: t(\"rx\", \"width\")\n      },\n      refRy: {\n        set: t(\"ry\", \"height\")\n      },\n      refRInscribed: {\n        set: (d = t(\"r\", \"width\"), p = t(\"r\", \"height\"), function (t, e) {\n          return (e.height > e.width ? d : p)(t, e);\n        })\n      },\n      refRCircumscribed: {\n        set: function set(t, e) {\n          var i = g.isPercentage(t);\n          t = parseFloat(t), i && (t /= 100);\n          var n,\n              r = Math.sqrt(e.height * e.height + e.width * e.width);\n          return isFinite(t) && (n = i || 0 <= t && t <= 1 ? t * r : Math.max(t + r, 0)), {\n            r: n\n          };\n        }\n      },\n      refCx: {\n        set: t(\"cx\", \"width\")\n      },\n      refCy: {\n        set: t(\"cy\", \"height\")\n      },\n      xAlignment: {\n        offset: i(\"x\", \"width\", \"right\")\n      },\n      yAlignment: {\n        offset: i(\"y\", \"height\", \"bottom\")\n      },\n      resetOffset: {\n        offset: function offset(t, e) {\n          return t ? {\n            x: -e.x,\n            y: -e.y\n          } : {\n            x: 0,\n            y: 0\n          };\n        }\n      },\n      refDResetOffset: {\n        set: n({\n          resetOffset: !0\n        })\n      },\n      refDKeepOffset: {\n        set: n({\n          resetOffset: !1\n        })\n      },\n      refPointsResetOffset: {\n        set: o({\n          resetOffset: !0\n        })\n      },\n      refPointsKeepOffset: {\n        set: o({\n          resetOffset: !1\n        })\n      },\n      connection: {\n        qualify: u,\n        set: function set() {\n          return {\n            d: this.getSerializedConnection()\n          };\n        }\n      },\n      atConnectionLengthKeepGradient: {\n        qualify: u,\n        set: s(\"getTangentAtLength\", {\n          rotate: !0\n        })\n      },\n      atConnectionLengthIgnoreGradient: {\n        qualify: u,\n        set: s(\"getTangentAtLength\", {\n          rotate: !1\n        })\n      },\n      atConnectionRatioKeepGradient: {\n        qualify: u,\n        set: s(\"getTangentAtRatio\", {\n          rotate: !0\n        })\n      },\n      atConnectionRatioIgnoreGradient: {\n        qualify: u,\n        set: s(\"getTangentAtRatio\", {\n          rotate: !1\n        })\n      }\n    };\n    v.refR = v.refRInscribed, v.refD = v.refDResetOffset, v.refPoints = v.refPointsResetOffset, v.atConnectionLength = v.atConnectionLengthKeepGradient, v.atConnectionRatio = v.atConnectionRatioKeepGradient, v.refX2 = v.refX, v.refY2 = v.refY, v.refWidth2 = v.refWidth, v.refHeight2 = v.refHeight, v[\"ref-x\"] = v.refX, v[\"ref-y\"] = v.refY, v[\"ref-dy\"] = v.refDy, v[\"ref-dx\"] = v.refDx, v[\"ref-width\"] = v.refWidth, v[\"ref-height\"] = v.refHeight, v[\"x-alignment\"] = v.xAlignment, v[\"y-alignment\"] = v.yAlignment;\n  }(joint, V, g, $, joint.util), function (a, l) {\n    var h = a.mvc.View.extend({\n      name: null,\n      tagName: \"g\",\n      className: \"tool\",\n      svgElement: !0,\n      _visible: !0,\n      init: function init() {\n        var t = this.name;\n        t && this.vel.attr(\"data-tool-name\", t);\n      },\n      configure: function configure(t, e) {\n        return this.relatedView = t, this.paper = t.paper, this.parentView = e, this.simulateRelatedView(this.el), this;\n      },\n      simulateRelatedView: function simulateRelatedView(t) {\n        t && t.setAttribute(\"model-id\", this.relatedView.model.id);\n      },\n      getName: function getName() {\n        return this.name;\n      },\n      show: function show() {\n        this.el.style.display = \"\", this._visible = !0;\n      },\n      hide: function hide() {\n        this.el.style.display = \"none\", this._visible = !1;\n      },\n      isVisible: function isVisible() {\n        return !!this._visible;\n      },\n      focus: function focus() {\n        var t = this.options.focusOpacity;\n        isFinite(t) && (this.el.style.opacity = t), this.parentView.focusTool(this);\n      },\n      blur: function blur() {\n        this.el.style.opacity = \"\", this.parentView.blurTool(this);\n      },\n      update: function update() {}\n    }),\n        t = a.mvc.View.extend({\n      tagName: \"g\",\n      className: \"tools\",\n      svgElement: !0,\n      tools: null,\n      options: {\n        tools: null,\n        relatedView: null,\n        name: null,\n        component: !1\n      },\n      configure: function configure(t) {\n        var e = (t = l.assign(this.options, t)).tools;\n        if (!Array.isArray(e)) return this;\n        var i = t.relatedView;\n        if (!(i instanceof a.dia.CellView)) return this;\n\n        for (var n = this.tools = [], r = 0, o = e.length; r < o; r++) {\n          var s = e[r];\n          s instanceof h && (s.configure(i, this), s.render(), this.vel.append(s.el), n.push(s));\n        }\n\n        return this;\n      },\n      getName: function getName() {\n        return this.options.name;\n      },\n      update: function update(t) {\n        t || (t = {});\n        var e = this.tools;\n\n        if (e) {\n          for (var i = 0, n = e.length; i < n; i++) {\n            var r = e[i];\n            t.tool !== r.cid && r.isVisible() && r.update();\n          }\n\n          return this;\n        }\n      },\n      focusTool: function focusTool(t) {\n        var e = this.tools;\n        if (!e) return this;\n\n        for (var i = 0, n = e.length; i < n; i++) {\n          var r = e[i];\n          t === r ? r.show() : r.hide();\n        }\n\n        return this;\n      },\n      blurTool: function blurTool(t) {\n        var e = this.tools;\n        if (!e) return this;\n\n        for (var i = 0, n = e.length; i < n; i++) {\n          var r = e[i];\n          r === t || r.isVisible() || (r.show(), r.update());\n        }\n\n        return this;\n      },\n      hide: function hide() {\n        return this.focusTool(null);\n      },\n      show: function show() {\n        return this.blurTool(null);\n      },\n      onRemove: function onRemove() {\n        var t = this.tools;\n        if (!t) return this;\n\n        for (var e = 0, i = t.length; e < i; e++) {\n          t[e].remove();\n        }\n\n        this.tools = null;\n      },\n      mount: function mount() {\n        var t = this.options,\n            e = t.relatedView;\n        e && (t.component ? e.el : e.paper.tools).appendChild(this.el);\n        return this;\n      }\n    });\n    a.dia.ToolsView = t, a.dia.ToolView = h;\n  }(joint, joint.util), joint.dia.Cell = Backbone.Model.extend({\n    constructor: function constructor(t, e) {\n      var i,\n          n = t || {};\n      this.cid = joint.util.uniqueId(\"c\"), this.attributes = {}, e && e.collection && (this.collection = e.collection), e && e.parse && (n = this.parse(n, e) || {}), (i = joint.util.result(this, \"defaults\")) && (n = joint.util.merge({}, i, n)), this.set(n, e), this.changed = {}, this.initialize.apply(this, arguments);\n    },\n    translate: function translate(t, e, i) {\n      throw new Error(\"Must define a translate() method.\");\n    },\n    toJSON: function toJSON() {\n      var e = this.constructor.prototype.defaults.attrs || {},\n          t = this.attributes.attrs,\n          o = {};\n      joint.util.forIn(t, function (t, n) {\n        var r = e[n];\n        joint.util.forIn(t, function (t, i) {\n          joint.util.isObject(t) && !Array.isArray(t) ? joint.util.forIn(t, function (t, e) {\n            r && r[i] && joint.util.isEqual(r[i][e], t) || (o[n] = o[n] || {}, (o[n][i] || (o[n][i] = {}))[e] = t);\n          }) : r && joint.util.isEqual(r[i], t) || (o[n] = o[n] || {}, o[n][i] = t);\n        });\n      });\n      var i = joint.util.cloneDeep(joint.util.omit(this.attributes, \"attrs\"));\n      return i.attrs = o, i;\n    },\n    initialize: function initialize(t) {\n      t && t.id || this.set(\"id\", joint.util.uuid(), {\n        silent: !0\n      }), this._transitionIds = {}, this.processPorts(), this.on(\"change:attrs\", this.processPorts, this);\n    },\n    processPorts: function processPorts() {\n      var t = this.ports,\n          i = {};\n      joint.util.forIn(this.get(\"attrs\"), function (t, e) {\n        t && t.port && (void 0 !== t.port.id ? i[t.port.id] = t.port : i[t.port] = {\n          id: t.port\n        });\n      });\n      var n = {};\n      (joint.util.forIn(t, function (t, e) {\n        i[e] || (n[e] = !0);\n      }), this.graph && !joint.util.isEmpty(n)) && (this.graph.getConnectedLinks(this, {\n        inbound: !0\n      }).forEach(function (t) {\n        n[t.get(\"target\").port] && t.remove();\n      }), this.graph.getConnectedLinks(this, {\n        outbound: !0\n      }).forEach(function (t) {\n        n[t.get(\"source\").port] && t.remove();\n      }));\n      this.ports = i;\n    },\n    remove: function remove(t) {\n      t = t || {};\n      var e = this.graph;\n      if (!e) return this.collection && this.collection.remove(this, t), this;\n      e.startBatch(\"remove\");\n      var i = this.getParentCell();\n      i && i.unembed(this);\n\n      for (var n = this.getEmbeddedCells(), r = 0, o = n.length; r < o; r++) {\n        var s = n[r];\n        s && s.remove(t);\n      }\n\n      return this.trigger(\"remove\", this, e.attributes.cells, t), e.stopBatch(\"remove\"), this;\n    },\n    toFront: function toFront(i) {\n      var t = this.graph;\n\n      if (t) {\n        i = i || {};\n        var e,\n            n = t.maxZIndex();\n        i.deep ? (e = this.getEmbeddedCells({\n          deep: !0,\n          breadthFirst: !0\n        })).unshift(this) : e = [this], n = n - e.length + 1;\n        var r = t.get(\"cells\"),\n            o = r.indexOf(this) !== r.length - e.length;\n        o || (o = e.some(function (t, e) {\n          return t.get(\"z\") !== n + e;\n        })), o && (this.startBatch(\"to-front\"), n += e.length, e.forEach(function (t, e) {\n          t.set(\"z\", n + e, i);\n        }), this.stopBatch(\"to-front\"));\n      }\n\n      return this;\n    },\n    toBack: function toBack(i) {\n      var t = this.graph;\n\n      if (t) {\n        i = i || {};\n        var e,\n            n = t.minZIndex();\n        i.deep ? (e = this.getEmbeddedCells({\n          deep: !0,\n          breadthFirst: !0\n        })).unshift(this) : e = [this];\n        var r = 0 !== t.get(\"cells\").indexOf(this);\n        r || (r = e.some(function (t, e) {\n          return t.get(\"z\") !== n + e;\n        })), r && (this.startBatch(\"to-back\"), n -= e.length, e.forEach(function (t, e) {\n          t.set(\"z\", n + e, i);\n        }), this.stopBatch(\"to-back\"));\n      }\n\n      return this;\n    },\n    parent: function parent(t, e) {\n      return void 0 === t ? this.get(\"parent\") : this.set(\"parent\", t, e);\n    },\n    embed: function embed(t, e) {\n      if (this === t || this.isEmbeddedIn(t)) throw new Error(\"Recursive embedding not allowed.\");\n      this.startBatch(\"embed\");\n      var i = joint.util.assign([], this.get(\"embeds\"));\n      return i[t.isLink() ? \"unshift\" : \"push\"](t.id), t.parent(this.id, e), this.set(\"embeds\", joint.util.uniq(i), e), this.stopBatch(\"embed\"), this;\n    },\n    unembed: function unembed(t, e) {\n      return this.startBatch(\"unembed\"), t.unset(\"parent\", e), this.set(\"embeds\", joint.util.without(this.get(\"embeds\"), t.id), e), this.stopBatch(\"unembed\"), this;\n    },\n    getParentCell: function getParentCell() {\n      var t = this.parent(),\n          e = this.graph;\n      return t && e && e.getCell(t) || null;\n    },\n    getAncestors: function getAncestors() {\n      var t = [];\n      if (!this.graph) return t;\n\n      for (var e = this.getParentCell(); e;) {\n        t.push(e), e = e.getParentCell();\n      }\n\n      return t;\n    },\n    getEmbeddedCells: function getEmbeddedCells(e) {\n      if (e = e || {}, this.graph) {\n        var i;\n        if (e.deep) {\n          if (e.breadthFirst) {\n            i = [];\n\n            for (var t = this.getEmbeddedCells(); 0 < t.length;) {\n              var n = t.shift();\n              i.push(n), t.push.apply(t, n.getEmbeddedCells());\n            }\n          } else (i = this.getEmbeddedCells()).forEach(function (t) {\n            i.push.apply(i, t.getEmbeddedCells(e));\n          });\n        } else i = joint.util.toArray(this.get(\"embeds\")).map(this.graph.getCell, this.graph);\n        return i;\n      }\n\n      return [];\n    },\n    isEmbeddedIn: function isEmbeddedIn(t, e) {\n      var i = joint.util.isString(t) ? t : t.id,\n          n = this.parent();\n\n      if (e = joint.util.defaults({\n        deep: !0\n      }, e), this.graph && e.deep) {\n        for (; n;) {\n          if (n === i) return !0;\n          n = this.graph.getCell(n).parent();\n        }\n\n        return !1;\n      }\n\n      return n === i;\n    },\n    isEmbedded: function isEmbedded() {\n      return !!this.parent();\n    },\n    clone: function clone(t) {\n      if ((t = t || {}).deep) return joint.util.toArray(joint.dia.Graph.prototype.cloneCells.call(null, [this].concat(this.getEmbeddedCells({\n        deep: !0\n      }))));\n      var e = Backbone.Model.prototype.clone.apply(this, arguments);\n      return e.set(\"id\", joint.util.uuid()), e.unset(\"embeds\"), e.unset(\"parent\"), e;\n    },\n    prop: function prop(t, e, i) {\n      var n = joint.util.isString(t);\n\n      if (n || Array.isArray(t)) {\n        if (1 < arguments.length) {\n          var r,\n              o,\n              s = (o = n ? (r = t).split(\"/\") : (r = t.join(\"/\"), t.slice()))[0],\n              a = o.length;\n          if ((i = i || {}).propertyPath = r, i.propertyValue = e, i.propertyPathArray = o, 1 === a) return this.set(s, e, i);\n\n          for (var l = {}, h = l, u = s, c = 1; c < a; c++) {\n            var d = o[c],\n                f = Number.isFinite(n ? Number(d) : d);\n            h = h[u] = f ? [] : {}, u = d;\n          }\n\n          l = joint.util.setByPath(l, o, e, \"/\");\n          var g = joint.util.merge({}, this.attributes);\n          i.rewrite && joint.util.unsetByPath(g, r, \"/\");\n          var p = joint.util.merge(g, l);\n          return this.set(s, p[s], i);\n        }\n\n        return joint.util.getByPath(this.attributes, t, \"/\");\n      }\n\n      return this.set(joint.util.merge({}, this.attributes, t), e);\n    },\n    removeProp: function removeProp(t, e) {\n      (e = e || {}).dirty = !0;\n      var i = Array.isArray(t) ? t : t.split(\"/\");\n      if (1 === i.length) return this.unset(t, e);\n      var n = i[0],\n          r = i.slice(1),\n          o = joint.util.cloneDeep(this.get(n));\n      return joint.util.unsetByPath(o, r, \"/\"), this.set(n, o, e);\n    },\n    attr: function attr(t, e, i) {\n      var n = Array.from(arguments);\n      return 0 === n.length ? this.get(\"attrs\") : (Array.isArray(t) ? n[0] = [\"attrs\"].concat(t) : joint.util.isString(t) ? n[0] = \"attrs/\" + t : n[0] = {\n        attrs: t\n      }, this.prop.apply(this, n));\n    },\n    removeAttr: function removeAttr(t, e) {\n      return Array.isArray(t) ? this.removeProp([\"attrs\"].concat(t)) : this.removeProp(\"attrs/\" + t, e);\n    },\n    transition: function transition(r, e, o, i) {\n      i = i || \"/\";\n      var t = {\n        duration: 100,\n        delay: 10,\n        timingFunction: joint.util.timing.linear,\n        valueFunction: joint.util.interpolate.number\n      };\n      o = joint.util.assign(t, o);\n\n      var s,\n          a = 0,\n          l = function (t) {\n        var e, i, n;\n        (i = (t -= a = a || t) / o.duration) < 1 ? this._transitionIds[r] = e = joint.util.nextFrame(l) : (i = 1, delete this._transitionIds[r]), n = s(o.timingFunction(i)), o.transitionId = e, this.prop(r, n, o), e || this.trigger(\"transition:end\", this, r);\n      }.bind(this),\n          n = function (t) {\n        this.stopTransitions(r), s = o.valueFunction(joint.util.getByPath(this.attributes, r, i), e), this._transitionIds[r] = joint.util.nextFrame(t), this.trigger(\"transition:start\", this, r);\n      }.bind(this);\n\n      return setTimeout(n, o.delay, l);\n    },\n    getTransitions: function getTransitions() {\n      return Object.keys(this._transitionIds);\n    },\n    stopTransitions: function stopTransitions(t, e) {\n      e = e || \"/\";\n      var i = t && t.split(e);\n      return Object.keys(this._transitionIds).filter(i && function (t) {\n        return joint.util.isEqual(i, t.split(e).slice(0, i.length));\n      }).forEach(function (t) {\n        joint.util.cancelFrame(this._transitionIds[t]), delete this._transitionIds[t], this.trigger(\"transition:end\", this, t);\n      }, this), this;\n    },\n    addTo: function addTo(t, e) {\n      return t.addCell(this, e), this;\n    },\n    findView: function findView(t) {\n      return t.findViewByModel(this);\n    },\n    isElement: function isElement() {\n      return !1;\n    },\n    isLink: function isLink() {\n      return !1;\n    },\n    startBatch: function startBatch(t, e) {\n      return this.graph && this.graph.startBatch(t, joint.util.assign({}, e, {\n        cell: this\n      })), this;\n    },\n    stopBatch: function stopBatch(t, e) {\n      return this.graph && this.graph.stopBatch(t, joint.util.assign({}, e, {\n        cell: this\n      })), this;\n    }\n  }, {\n    getAttributeDefinition: function getAttributeDefinition(t) {\n      var e = this.attributes,\n          i = joint.dia.attributes;\n      return e && e[t] || i[t];\n    },\n    define: function define(t, e, i, n) {\n      i = joint.util.assign({\n        defaults: joint.util.defaultsDeep({\n          type: t\n        }, e, this.prototype.defaults)\n      }, i);\n      var r = this.extend(i, n);\n      return joint.util.setByPath(joint.shapes, t, r, \".\"), r;\n    }\n  }), joint.dia.CellView = joint.mvc.View.extend({\n    tagName: \"g\",\n    svgElement: !0,\n    selector: \"root\",\n    className: function className() {\n      var n = [\"cell\"],\n          t = this.model.get(\"type\");\n      return t && t.toLowerCase().split(\".\").forEach(function (t, e, i) {\n        n.push(\"type-\" + i.slice(0, e + 1).join(\"-\"));\n      }), n.join(\" \");\n    },\n    attributes: function attributes() {\n      return {\n        \"model-id\": this.model.id\n      };\n    },\n    constructor: function constructor(t) {\n      t.id = t.id || joint.util.guid(this), joint.mvc.View.call(this, t);\n    },\n    init: function init() {\n      joint.util.bindAll(this, \"remove\", \"update\"), this.$el.data(\"view\", this), this.$el.attr(\"data-type\", this.model.get(\"type\")), this.listenTo(this.model, \"change:attrs\", this.onChangeAttrs);\n    },\n    parseDOMJSON: function parseDOMJSON(t, e) {\n      var i = joint.util.parseDOMJSON(t),\n          n = i.selectors,\n          r = i.groupSelectors;\n\n      for (var o in r) {\n        if (n[o]) throw new Error(\"dia.CellView: ambigious group selector\");\n        n[o] = r[o];\n      }\n\n      if (e) {\n        var s = this.selector;\n        if (n[s]) throw new Error(\"dia.CellView: ambiguous root selector.\");\n        n[s] = e;\n      }\n\n      return {\n        fragment: i.fragment,\n        selectors: n\n      };\n    },\n    onChangeAttrs: function onChangeAttrs(t, e, i) {\n      return i.dirty ? this.render() : this.update(t, e, i);\n    },\n    can: function can(t) {\n      var e = joint.util.isFunction(this.options.interactive) ? this.options.interactive(this) : this.options.interactive;\n      return joint.util.isObject(e) && !1 !== e[t] || joint.util.isBoolean(e) && !1 !== e;\n    },\n    findBySelector: function findBySelector(t, e, i) {\n      if (e || (e = this.el), i || (i = this.selectors), !t || \".\" === t) return [e];\n\n      if (i) {\n        var n = i[t];\n        if (n) return Array.isArray(n) ? n : [n];\n      }\n\n      return $(e).find(t).toArray();\n    },\n    notify: function notify(t) {\n      if (this.paper) {\n        var e = Array.prototype.slice.call(arguments, 1);\n        this.trigger.apply(this, [t].concat(e)), this.paper.trigger.apply(this.paper, [t, this].concat(e));\n      }\n    },\n    getStrokeBBox: function getStrokeBBox(t) {\n      var e = !!t;\n      t = t || this.el;\n      var i,\n          n = V(t).getBBox({\n        target: this.paper.viewport\n      });\n      return i = e ? V(t).attr(\"stroke-width\") : this.model.attr(\"rect/stroke-width\") || this.model.attr(\"circle/stroke-width\") || this.model.attr(\"ellipse/stroke-width\") || this.model.attr(\"path/stroke-width\"), i = parseFloat(i) || 0, g.rect(n).moveAndExpand({\n        x: -i / 2,\n        y: -i / 2,\n        width: i,\n        height: i\n      });\n    },\n    getBBox: function getBBox() {\n      return this.vel.getBBox({\n        target: this.paper.svg\n      });\n    },\n    highlight: function highlight(t, e) {\n      return t = t && this.$(t)[0] || this.el, (e = e || {}).partial = t !== this.el, this.notify(\"cell:highlight\", t, e), this;\n    },\n    unhighlight: function unhighlight(t, e) {\n      return t = t && this.$(t)[0] || this.el, (e = e || {}).partial = t != this.el, this.notify(\"cell:unhighlight\", t, e), this;\n    },\n    findMagnet: function findMagnet(t) {\n      var e = this.$(t),\n          i = this.$el;\n      0 === e.length && (e = i);\n\n      do {\n        var n = e.attr(\"magnet\");\n        if ((n || e.is(i)) && \"false\" !== n) return e[0];\n        e = e.parent();\n      } while (0 < e.length);\n    },\n    getSelector: function getSelector(t, e) {\n      var i;\n      if (t === this.el) return \"string\" == typeof e && (i = \"> \" + e), i;\n\n      if (t) {\n        var n = V(t).index() + 1;\n        i = t.tagName + \":nth-child(\" + n + \")\", e && (i += \" > \" + e), i = this.getSelector(t.parentNode, i);\n      }\n\n      return i;\n    },\n    getLinkEnd: function getLinkEnd(t, e, i, n, r) {\n      var o = this.model,\n          s = o.id,\n          a = this.findAttribute(\"port\", t),\n          l = t.getAttribute(\"joint-selector\"),\n          h = {\n        id: s\n      };\n      null != l && (h.magnet = l), null != a ? (h.port = a, o.hasPort(a) || l || (h.selector = this.getSelector(t))) : null == l && this.el !== t && (h.selector = this.getSelector(t));\n      var u = this.paper,\n          c = u.options.connectionStrategy;\n\n      if (\"function\" == typeof c) {\n        var d = c.call(u, h, this, t, new g.Point(e, i), n, r);\n        d && (h = d);\n      }\n\n      return h;\n    },\n    getMagnetFromLinkEnd: function getMagnetFromLinkEnd(t) {\n      var e = this.el,\n          i = t.port,\n          n = t.magnet;\n      return null != i && this.model.hasPort(i) ? this.findPortNode(i, n) || e : (n || (n = t.selector), n || null == i || (n = '[port=\"' + i + '\"]'), this.findBySelector(n, e, this.selectors)[0]);\n    },\n    getAttributeDefinition: function getAttributeDefinition(t) {\n      return this.model.constructor.getAttributeDefinition(t);\n    },\n    setNodeAttributes: function setNodeAttributes(t, e) {\n      joint.util.isEmpty(e) || (t instanceof SVGElement ? V(t).attr(e) : $(t).attr(e));\n    },\n    processNodeAttributes: function processNodeAttributes(t, e) {\n      var i,\n          n,\n          r,\n          o,\n          s,\n          a,\n          l,\n          h,\n          u,\n          c = [];\n\n      for (i in e) {\n        e.hasOwnProperty(i) && (n = e[i], !(r = this.getAttributeDefinition(i)) || joint.util.isFunction(r.qualify) && !r.qualify.call(this, n, t, e) ? (a || (a = {}), a[joint.util.toKebabCase(i)] = n) : (joint.util.isString(r.set) && (a || (a = {}), a[r.set] = n), null !== n && c.push(i, r)));\n      }\n\n      for (o = 0, s = c.length; o < s; o += 2) {\n        i = c[o], r = c[o + 1], n = e[i], joint.util.isFunction(r.set) && (l || (l = {}), l[i] = n), joint.util.isFunction(r.position) && (h || (h = {}), h[i] = n), joint.util.isFunction(r.offset) && (u || (u = {}), u[i] = n);\n      }\n\n      return {\n        raw: e,\n        normal: a,\n        set: l,\n        position: h,\n        offset: u\n      };\n    },\n    updateRelativeAttributes: function updateRelativeAttributes(t, e, i, n) {\n      var r, o;\n      n || (n = {});\n      var s = e.raw || {},\n          a = e.normal || {},\n          l = e.set,\n          h = e.position,\n          u = e.offset;\n\n      for (r in l) {\n        o = l[r];\n        var c = this.getAttributeDefinition(r).set.call(this, o, i.clone(), t, s);\n        joint.util.isObject(c) ? joint.util.assign(a, c) : void 0 !== c && (a[r] = c);\n      }\n\n      if (t instanceof HTMLElement) this.setNodeAttributes(t, a);else {\n        var d,\n            f,\n            p,\n            m = a.transform,\n            v = V.transformStringToMatrix(m),\n            y = g.Point(v.e, v.f);\n\n        if (m && (a = joint.util.omit(a, \"transform\"), v.e = v.f = 0), h || u) {\n          var b = this.getNodeScale(t, n.scalableNode);\n          d = b.sx, f = b.sy;\n        }\n\n        var w = !1;\n\n        for (r in h) {\n          o = h[r], (p = this.getAttributeDefinition(r).position.call(this, o, i.clone(), t, s)) && (y.offset(g.Point(p).scale(d, f)), w || (w = !0));\n        }\n\n        this.setNodeAttributes(t, a);\n        var x = !1;\n\n        if (u) {\n          var k = t.getBoundingClientRect();\n\n          if (0 < k.width && 0 < k.height) {\n            var A = V.transformRect(t.getBBox(), v).scale(1 / d, 1 / f);\n\n            for (r in u) {\n              o = u[r], (p = this.getAttributeDefinition(r).offset.call(this, o, A, t, s)) && (y.offset(g.Point(p).scale(d, f)), x || (x = !0));\n            }\n          }\n        }\n\n        (void 0 !== m || w || x) && (y.round(1), v.e = y.x, v.f = y.y, t.setAttribute(\"transform\", V.matrixToTransformString(v)));\n      }\n    },\n    getNodeScale: function getNodeScale(t, e) {\n      var i, n;\n\n      if (e && e.contains(t)) {\n        var r = e.scale();\n        i = 1 / r.sx, n = 1 / r.sy;\n      } else n = i = 1;\n\n      return {\n        sx: i,\n        sy: n\n      };\n    },\n    findNodesAttributes: function findNodesAttributes(t, e, i, n) {\n      var r,\n          o,\n          s,\n          a,\n          l = joint.util,\n          h = {},\n          u = [];\n\n      for (var c in t) {\n        if (t.hasOwnProperty(c)) {\n          var d = i[c] = this.findBySelector(c, e, n);\n\n          for (r = 0, o = d.length; r < o; r++) {\n            var f = d[r];\n            a = V.ensureId(f), s = t[c];\n            var g = n && n[c] === f,\n                p = h[a];\n\n            if (p) {\n              p.array || (u.push(a), p.array = !0, p.attributes = [p.attributes], p.selectedLength = [p.selectedLength]);\n              var m = p.attributes,\n                  v = p.selectedLength;\n              if (g) m.unshift(s), v.unshift(-1);else {\n                var y = l.sortedIndex(v, o);\n                m.splice(y, 0, s), v.splice(y, 0, o);\n              }\n            } else h[a] = {\n              attributes: s,\n              selectedLength: g ? -1 : o,\n              node: f,\n              array: !1\n            };\n          }\n        }\n      }\n\n      for (r = 0, o = u.length; r < o; r++) {\n        (s = h[a = u[r]]).attributes = l.merge.apply(l, [{}].concat(s.attributes.reverse()));\n      }\n\n      return h;\n    },\n    getEventTarget: function getEventTarget(t) {\n      var e = t.type;\n      return \"touchmove\" === e || \"touchend\" === e ? document.elementFromPoint(t.clientX, t.clientY) : t.target;\n    },\n    updateDOMSubtreeAttributes: function updateDOMSubtreeAttributes(t, e, i) {\n      i || (i = {}), i.rootBBox || (i.rootBBox = g.Rect()), i.selectors || (i.selectors = this.selectors);\n      var n,\n          r,\n          o,\n          s,\n          a,\n          l = {},\n          h = {},\n          u = [],\n          c = i.roAttributes,\n          d = this.findNodesAttributes(c || e, t, l, i.selectors),\n          f = c ? this.findNodesAttributes(e, t, l, i.selectors) : d;\n\n      for (var p in d) {\n        if (o = (s = d[p]).attributes, r = s.node, (a = this.processNodeAttributes(r, o)).set || a.position || a.offset) {\n          var m,\n              v = f[p] && f[p].attributes,\n              y = v && void 0 === o.ref ? v.ref : o.ref;\n\n          if (y) {\n            if (!(m = (l[y] || this.findBySelector(y, t, i.selectors))[0])) throw new Error('dia.ElementView: \"' + y + '\" reference does not exist.');\n          } else m = null;\n\n          n = {\n            node: r,\n            refNode: m,\n            processedAttributes: a,\n            allAttributes: v\n          };\n          var b = u.findIndex(function (t) {\n            return t.refNode === r;\n          });\n          -1 < b ? u.splice(b, 0, n) : u.push(n);\n        } else this.setNodeAttributes(r, a.normal);\n      }\n\n      for (var w = 0, x = u.length; w < x; w++) {\n        n = u[w], r = n.node;\n        var k = (m = n.refNode) ? V.ensureId(m) : \"\",\n            A = h[k];\n        A || (A = h[k] = m ? V(m).getBBox({\n          target: i.rotatableNode || t\n        }) : i.rootBBox), c ? (a = this.processNodeAttributes(r, n.allAttributes), this.mergeProcessedAttributes(a, n.processedAttributes)) : a = n.processedAttributes, this.updateRelativeAttributes(r, a, A, i);\n      }\n    },\n    mergeProcessedAttributes: function mergeProcessedAttributes(t, e) {\n      t.set || (t.set = {}), t.position || (t.position = {}), t.offset || (t.offset = {}), joint.util.assign(t.set, e.set), joint.util.assign(t.position, e.position), joint.util.assign(t.offset, e.offset);\n      var i = t.normal && t.normal.transform;\n      void 0 !== i && e.normal && (e.normal.transform = i), t.normal = e.normal;\n    },\n    onRemove: function onRemove() {\n      this.removeTools();\n    },\n    _toolsView: null,\n    hasTools: function hasTools(t) {\n      var e = this._toolsView;\n      return !!e && (!t || e.getName() === t);\n    },\n    addTools: function addTools(t) {\n      return this.removeTools(), t instanceof joint.dia.ToolsView && ((this._toolsView = t).configure({\n        relatedView: this\n      }), t.listenTo(this.paper, \"tools:event\", this.onToolEvent.bind(this)), t.mount()), this;\n    },\n    updateTools: function updateTools(t) {\n      var e = this._toolsView;\n      return e && e.update(t), this;\n    },\n    removeTools: function removeTools() {\n      var t = this._toolsView;\n      return t && (t.remove(), this._toolsView = null), this;\n    },\n    hideTools: function hideTools() {\n      var t = this._toolsView;\n      return t && t.hide(), this;\n    },\n    showTools: function showTools() {\n      var t = this._toolsView;\n      return t && t.show(), this;\n    },\n    onToolEvent: function onToolEvent(t) {\n      switch (t) {\n        case \"remove\":\n          this.removeTools();\n          break;\n\n        case \"hide\":\n          this.hideTools();\n          break;\n\n        case \"show\":\n          this.showTools();\n      }\n    },\n    pointerdblclick: function pointerdblclick(t, e, i) {\n      this.notify(\"cell:pointerdblclick\", t, e, i);\n    },\n    pointerclick: function pointerclick(t, e, i) {\n      this.notify(\"cell:pointerclick\", t, e, i);\n    },\n    contextmenu: function contextmenu(t, e, i) {\n      this.notify(\"cell:contextmenu\", t, e, i);\n    },\n    pointerdown: function pointerdown(t, e, i) {\n      this.model.graph && (this.model.startBatch(\"pointer\"), this._graph = this.model.graph), this.notify(\"cell:pointerdown\", t, e, i);\n    },\n    pointermove: function pointermove(t, e, i) {\n      this.notify(\"cell:pointermove\", t, e, i);\n    },\n    pointerup: function pointerup(t, e, i) {\n      this.notify(\"cell:pointerup\", t, e, i), this._graph && (this._graph.stopBatch(\"pointer\", {\n        cell: this.model\n      }), delete this._graph);\n    },\n    mouseover: function mouseover(t) {\n      this.notify(\"cell:mouseover\", t);\n    },\n    mouseout: function mouseout(t) {\n      this.notify(\"cell:mouseout\", t);\n    },\n    mouseenter: function mouseenter(t) {\n      this.notify(\"cell:mouseenter\", t);\n    },\n    mouseleave: function mouseleave(t) {\n      this.notify(\"cell:mouseleave\", t);\n    },\n    mousewheel: function mousewheel(t, e, i, n) {\n      this.notify(\"cell:mousewheel\", t, e, i, n);\n    },\n    onevent: function onevent(t, e, i, n) {\n      this.notify(e, t, i, n);\n    },\n    onmagnet: function onmagnet() {},\n    magnetpointerdblclick: function magnetpointerdblclick() {},\n    magnetcontextmenu: function magnetcontextmenu() {},\n    setInteractivity: function setInteractivity(t) {\n      this.options.interactive = t;\n    }\n  }, {\n    dispatchToolsEvent: function dispatchToolsEvent(t, e) {\n      \"string\" == typeof e && t instanceof joint.dia.Paper && t.trigger(\"tools:event\", e);\n    }\n  }), joint.dia.Element = joint.dia.Cell.extend({\n    defaults: {\n      position: {\n        x: 0,\n        y: 0\n      },\n      size: {\n        width: 1,\n        height: 1\n      },\n      angle: 0\n    },\n    initialize: function initialize() {\n      this._initializePorts(), joint.dia.Cell.prototype.initialize.apply(this, arguments);\n    },\n    _initializePorts: function _initializePorts() {},\n    isElement: function isElement() {\n      return !0;\n    },\n    position: function position(t, e, i) {\n      var n = joint.util.isNumber(e);\n\n      if ((i = (n ? i : t) || {}).parentRelative) {\n        if (!this.graph) throw new Error(\"Element must be part of a graph.\");\n        var r = this.getParentCell(),\n            o = r && !r.isLink() ? r.get(\"position\") : {\n          x: 0,\n          y: 0\n        };\n      }\n\n      if (n) {\n        if (i.parentRelative && (t += o.x, e += o.y), i.deep) {\n          var s = this.get(\"position\");\n          this.translate(t - s.x, e - s.y, i);\n        } else this.set(\"position\", {\n          x: t,\n          y: e\n        }, i);\n\n        return this;\n      }\n\n      var a = g.point(this.get(\"position\"));\n      return i.parentRelative ? a.difference(o) : a;\n    },\n    translate: function translate(t, e, i) {\n      if (e = e || 0, 0 === (t = t || 0) && 0 === e) return this;\n      (i = i || {}).translateBy = i.translateBy || this.id;\n      var n = this.get(\"position\") || {\n        x: 0,\n        y: 0\n      };\n\n      if (i.restrictedArea && i.translateBy === this.id) {\n        var r = this.getBBox({\n          deep: !0\n        }),\n            o = i.restrictedArea,\n            s = n.x - r.x,\n            a = n.y - r.y,\n            l = Math.max(o.x + s, Math.min(o.x + o.width + s - r.width, n.x + t)),\n            h = Math.max(o.y + a, Math.min(o.y + o.height + a - r.height, n.y + e));\n        t = l - n.x, e = h - n.y;\n      }\n\n      var u = {\n        x: n.x + t,\n        y: n.y + e\n      };\n      return i.tx = t, i.ty = e, i.transition ? (joint.util.isObject(i.transition) || (i.transition = {}), this.transition(\"position\", u, joint.util.assign({}, i.transition, {\n        valueFunction: joint.util.interpolate.object\n      }))) : this.set(\"position\", u, i), joint.util.invoke(this.getEmbeddedCells(), \"translate\", t, e, i), this;\n    },\n    size: function size(t, e, i) {\n      var n = this.get(\"size\");\n      return void 0 === t ? {\n        width: n.width,\n        height: n.height\n      } : (joint.util.isObject(t) && (i = e, e = joint.util.isNumber(t.height) ? t.height : n.height, t = joint.util.isNumber(t.width) ? t.width : n.width), this.resize(t, e, i));\n    },\n    resize: function resize(t, e, i) {\n      if (i = i || {}, this.startBatch(\"resize\", i), i.direction) {\n        var n = this.get(\"size\");\n\n        switch (i.direction) {\n          case \"left\":\n          case \"right\":\n            e = n.height;\n            break;\n\n          case \"top\":\n          case \"bottom\":\n            t = n.width;\n        }\n\n        var r = g.normalizeAngle(this.get(\"angle\") || 0),\n            o = {\n          \"top-right\": 0,\n          right: 0,\n          \"top-left\": 1,\n          top: 1,\n          \"bottom-left\": 2,\n          left: 2,\n          \"bottom-right\": 3,\n          bottom: 3\n        }[i.direction];\n        i.absolute && (o += Math.floor((r + 45) / 90), o %= 4);\n        var s = this.getBBox(),\n            a = s[[\"bottomLeft\", \"corner\", \"topRight\", \"origin\"][o]](),\n            l = g.point(a).rotate(s.center(), -r),\n            h = Math.sqrt(t * t + e * e) / 2,\n            u = o * Math.PI / 2;\n        u += Math.atan(o % 2 == 0 ? e / t : t / e), u -= g.toRad(r);\n        var c = g.point.fromPolar(h, u, l),\n            d = g.point(c).offset(t / -2, e / -2);\n        this.set(\"size\", {\n          width: t,\n          height: e\n        }, i), this.position(d.x, d.y, i);\n      } else this.set(\"size\", {\n        width: t,\n        height: e\n      }, i);\n\n      return this.stopBatch(\"resize\", i), this;\n    },\n    scale: function scale(t, e, i, n) {\n      var r = this.getBBox().scale(t, e, i);\n      return this.startBatch(\"scale\", n), this.position(r.x, r.y, n), this.resize(r.width, r.height, n), this.stopBatch(\"scale\"), this;\n    },\n    fitEmbeds: function fitEmbeds(t) {\n      if (t = t || {}, !this.graph) throw new Error(\"Element must be part of a graph.\");\n      var e = this.getEmbeddedCells();\n\n      if (0 < e.length) {\n        this.startBatch(\"fit-embeds\", t), t.deep && joint.util.invoke(e, \"fitEmbeds\", t);\n        var i = this.graph.getCellsBBox(e),\n            n = joint.util.normalizeSides(t.padding);\n        i.moveAndExpand({\n          x: -n.left,\n          y: -n.top,\n          width: n.right + n.left,\n          height: n.bottom + n.top\n        }), this.set({\n          position: {\n            x: i.x,\n            y: i.y\n          },\n          size: {\n            width: i.width,\n            height: i.height\n          }\n        }, t), this.stopBatch(\"fit-embeds\");\n      }\n\n      return this;\n    },\n    rotate: function rotate(t, e, i, n) {\n      if (i) {\n        var r = this.getBBox().center(),\n            o = this.get(\"size\"),\n            s = this.get(\"position\");\n        r.rotate(i, this.get(\"angle\") - t);\n        var a = r.x - o.width / 2 - s.x,\n            l = r.y - o.height / 2 - s.y;\n        this.startBatch(\"rotate\", {\n          angle: t,\n          absolute: e,\n          origin: i\n        }), this.position(s.x + a, s.y + l, n), this.rotate(t, e, null, n), this.stopBatch(\"rotate\");\n      } else this.set(\"angle\", e ? t : (this.get(\"angle\") + t) % 360, n);\n\n      return this;\n    },\n    angle: function angle() {\n      return g.normalizeAngle(this.get(\"angle\") || 0);\n    },\n    getBBox: function getBBox(t) {\n      if ((t = t || {}).deep && this.graph) {\n        var e = this.getEmbeddedCells({\n          deep: !0,\n          breadthFirst: !0\n        });\n        return e.push(this), this.graph.getCellsBBox(e);\n      }\n\n      var i = this.get(\"position\"),\n          n = this.get(\"size\");\n      return new g.Rect(i.x, i.y, n.width, n.height);\n    }\n  }), joint.dia.ElementView = joint.dia.CellView.extend({\n    _removePorts: function _removePorts() {},\n    _renderPorts: function _renderPorts() {},\n    className: function className() {\n      var t = joint.dia.CellView.prototype.className.apply(this).split(\" \");\n      return t.push(\"element\"), t.join(\" \");\n    },\n    metrics: null,\n    initialize: function initialize() {\n      joint.dia.CellView.prototype.initialize.apply(this, arguments);\n      var t = this.model;\n      this.listenTo(t, \"change:position\", this.translate), this.listenTo(t, \"change:size\", this.resize), this.listenTo(t, \"change:angle\", this.rotate), this.listenTo(t, \"change:markup\", this.render), this._initializePorts(), this.metrics = {};\n    },\n    _initializePorts: function _initializePorts() {},\n    update: function update(t, e) {\n      this.metrics = {}, this._removePorts();\n      var i = this.model,\n          n = i.attr();\n      this.updateDOMSubtreeAttributes(this.el, n, {\n        rootBBox: new g.Rect(i.size()),\n        selectors: this.selectors,\n        scalableNode: this.scalableNode,\n        rotatableNode: this.rotatableNode,\n        roAttributes: e === n ? null : e\n      }), this._renderPorts();\n    },\n    rotatableSelector: \"rotatable\",\n    scalableSelector: \"scalable\",\n    scalableNode: null,\n    rotatableNode: null,\n    renderMarkup: function renderMarkup() {\n      var t = this.model,\n          e = t.get(\"markup\") || t.markup;\n      if (!e) throw new Error(\"dia.ElementView: markup required\");\n      if (Array.isArray(e)) return this.renderJSONMarkup(e);\n      if (\"string\" == typeof e) return this.renderStringMarkup(e);\n      throw new Error(\"dia.ElementView: invalid markup\");\n    },\n    renderJSONMarkup: function renderJSONMarkup(t) {\n      var e = this.parseDOMJSON(t, this.el),\n          i = this.selectors = e.selectors;\n      this.rotatableNode = V(i[this.rotatableSelector]) || null, this.scalableNode = V(i[this.scalableSelector]) || null, this.vel.append(e.fragment);\n    },\n    renderStringMarkup: function renderStringMarkup(t) {\n      var e = this.vel;\n      e.append(V(t)), this.rotatableNode = e.findOne(\".rotatable\"), this.scalableNode = e.findOne(\".scalable\"), (this.selectors = {})[this.selector] = this.el;\n    },\n    render: function render() {\n      return this.vel.empty(), this.renderMarkup(), this.scalableNode && this.update(), this.resize(), this.rotatableNode ? (this.rotate(), this.translate()) : this.updateTransformation(), this;\n    },\n    resize: function resize() {\n      if (this.scalableNode) return this.sgResize.apply(this, arguments);\n      this.model.attributes.angle && this.rotate(), this.update();\n    },\n    translate: function translate() {\n      if (this.rotatableNode) return this.rgTranslate();\n      this.updateTransformation();\n    },\n    rotate: function rotate() {\n      if (this.rotatableNode) return this.rgRotate();\n      this.updateTransformation();\n    },\n    updateTransformation: function updateTransformation() {\n      var t = this.getTranslateString(),\n          e = this.getRotateString();\n      e && (t += \" \" + e), this.vel.attr(\"transform\", t);\n    },\n    getTranslateString: function getTranslateString() {\n      var t = this.model.attributes.position;\n      return \"translate(\" + t.x + \",\" + t.y + \")\";\n    },\n    getRotateString: function getRotateString() {\n      var t = this.model.attributes,\n          e = t.angle;\n      if (!e) return null;\n      var i = t.size;\n      return \"rotate(\" + e + \",\" + i.width / 2 + \",\" + i.height / 2 + \")\";\n    },\n    getBBox: function getBBox(t) {\n      var e;\n\n      if (t && t.useModelGeometry) {\n        var i = this.model;\n        e = i.getBBox().bbox(i.angle());\n      } else e = this.getNodeBBox(this.el);\n\n      return this.paper.localToPaperRect(e);\n    },\n    nodeCache: function nodeCache(t) {\n      var e = this.metrics;\n      if (!e) return {};\n      var i = V.ensureId(t),\n          n = e[i];\n      return n || (n = e[i] = {}), n;\n    },\n    getNodeData: function getNodeData(t) {\n      var e = this.nodeCache(t);\n      return e.data || (e.data = {}), e.data;\n    },\n    getNodeBBox: function getNodeBBox(t) {\n      var e = this.getNodeBoundingRect(t),\n          i = this.getNodeMatrix(t),\n          n = this.getRootTranslateMatrix(),\n          r = this.getRootRotateMatrix();\n      return V.transformRect(e, n.multiply(r).multiply(i));\n    },\n    getNodeBoundingRect: function getNodeBoundingRect(t) {\n      var e = this.nodeCache(t);\n      return void 0 === e.boundingRect && (e.boundingRect = V(t).getBBox()), new g.Rect(e.boundingRect);\n    },\n    getNodeUnrotatedBBox: function getNodeUnrotatedBBox(t) {\n      var e = this.getNodeBoundingRect(t),\n          i = this.getNodeMatrix(t),\n          n = this.getRootTranslateMatrix();\n      return V.transformRect(e, n.multiply(i));\n    },\n    getNodeShape: function getNodeShape(t) {\n      var e = this.nodeCache(t);\n      return void 0 === e.geometryShape && (e.geometryShape = V(t).toGeometryShape()), e.geometryShape.clone();\n    },\n    getNodeMatrix: function getNodeMatrix(t) {\n      var e = this.nodeCache(t);\n\n      if (void 0 === e.magnetMatrix) {\n        var i = this.rotatableNode || this.el;\n        e.magnetMatrix = V(t).getTransformToElement(i);\n      }\n\n      return V.createSVGMatrix(e.magnetMatrix);\n    },\n    getRootTranslateMatrix: function getRootTranslateMatrix() {\n      var t = this.model.position();\n      return V.createSVGMatrix().translate(t.x, t.y);\n    },\n    getRootRotateMatrix: function getRootRotateMatrix() {\n      var t = V.createSVGMatrix(),\n          e = this.model,\n          i = e.angle();\n\n      if (i) {\n        var n = e.getBBox(),\n            r = n.width / 2,\n            o = n.height / 2;\n        t = t.translate(r, o).rotate(i).translate(-r, -o);\n      }\n\n      return t;\n    },\n    rgRotate: function rgRotate() {\n      this.rotatableNode.attr(\"transform\", this.getRotateString());\n    },\n    rgTranslate: function rgTranslate() {\n      this.vel.attr(\"transform\", this.getTranslateString());\n    },\n    sgResize: function sgResize(t, e, i) {\n      var n = this.model,\n          r = n.get(\"angle\") || 0,\n          o = n.get(\"size\") || {\n        width: 1,\n        height: 1\n      },\n          s = this.scalableNode,\n          a = !1;\n      0 < s.node.getElementsByTagName(\"path\").length && (a = !0);\n      var l = s.getBBox({\n        recursive: a\n      }),\n          h = o.width / (l.width || 1),\n          u = o.height / (l.height || 1);\n      s.attr(\"transform\", \"scale(\" + h + \",\" + u + \")\");\n      var c = this.rotatableNode,\n          d = c && c.attr(\"transform\");\n\n      if (d) {\n        c.attr(\"transform\", d + \" rotate(\" + -r + \",\" + o.width / 2 + \",\" + o.height / 2 + \")\");\n        var f = s.getBBox({\n          target: this.paper.viewport\n        });\n        n.set(\"position\", {\n          x: f.x,\n          y: f.y\n        }, i), this.rotate();\n      }\n\n      this.update();\n    },\n    prepareEmbedding: function prepareEmbedding(t) {\n      t || (t = {});\n      var e = t.model || this.model,\n          i = (t.paper || this.paper).model;\n      e.startBatch(\"to-front\"), e.toFront({\n        deep: !0,\n        ui: !0\n      });\n      var n = i.getElements().reduce(function (t, e) {\n        return Math.max(t, e.attributes.z || 0);\n      }, 0);\n      i.getConnectedLinks(e, {\n        deep: !0,\n        includeEnclosed: !0\n      }).forEach(function (t) {\n        t.attributes.z <= n && t.set(\"z\", n + 1, {\n          ui: !0\n        });\n      }), e.stopBatch(\"to-front\");\n      var r = e.parent();\n      r && i.getCell(r).unembed(e, {\n        ui: !0\n      });\n    },\n    processEmbedding: function processEmbedding(t) {\n      t || (t = {});\n      var e = t.model || this.model,\n          i = t.paper || this.paper,\n          n = i.options,\n          r = [];\n      joint.util.isFunction(n.findParentBy) ? r = joint.util.toArray(n.findParentBy.call(i.model, this)).filter(function (t) {\n        return t instanceof joint.dia.Cell && this.model.id !== t.id && !t.isEmbeddedIn(this.model);\n      }.bind(this)) : r = i.model.findModelsUnderElement(e, {\n        searchBy: n.findParentBy\n      });\n      n.frontParentOnly && (r = r.slice(-1));\n\n      for (var o = null, s = t.candidateEmbedView, a = r.length - 1; 0 <= a; a--) {\n        var l = r[a];\n\n        if (s && s.model.id == l.id) {\n          o = s;\n          break;\n        }\n\n        var h = l.findView(i);\n\n        if (n.validateEmbedding.call(i, this, h)) {\n          o = h;\n          break;\n        }\n      }\n\n      o && o != s && (this.clearEmbedding(t), t.candidateEmbedView = o.highlight(null, {\n        embedding: !0\n      })), !o && s && this.clearEmbedding(t);\n    },\n    clearEmbedding: function clearEmbedding(t) {\n      t || (t = {});\n      var e = t.candidateEmbedView;\n      e && (e.unhighlight(null, {\n        embedding: !0\n      }), t.candidateEmbedView = null);\n    },\n    finalizeEmbedding: function finalizeEmbedding(t) {\n      t || (t = {});\n      var e = t.candidateEmbedView,\n          i = t.model || this.model,\n          n = t.paper || this.paper;\n      e && (e.model.embed(i, {\n        ui: !0\n      }), e.unhighlight(null, {\n        embedding: !0\n      }), t.candidateEmbedView = null), joint.util.invoke(n.model.getConnectedLinks(i, {\n        deep: !0\n      }), \"reparent\", {\n        ui: !0\n      });\n    },\n    getDelegatedView: function getDelegatedView() {\n      for (var t = this, e = t.model, i = t.paper; t && !e.isLink();) {\n        if (!e.isEmbedded() || t.can(\"stopDelegation\")) return t;\n        e = e.getParentCell(), t = i.findViewByModel(e);\n      }\n\n      return null;\n    },\n    pointerdblclick: function pointerdblclick(t, e, i) {\n      joint.dia.CellView.prototype.pointerdblclick.apply(this, arguments), this.notify(\"element:pointerdblclick\", t, e, i);\n    },\n    pointerclick: function pointerclick(t, e, i) {\n      joint.dia.CellView.prototype.pointerclick.apply(this, arguments), this.notify(\"element:pointerclick\", t, e, i);\n    },\n    contextmenu: function contextmenu(t, e, i) {\n      joint.dia.CellView.prototype.contextmenu.apply(this, arguments), this.notify(\"element:contextmenu\", t, e, i);\n    },\n    pointerdown: function pointerdown(t, e, i) {\n      this.isPropagationStopped(t) || (joint.dia.CellView.prototype.pointerdown.apply(this, arguments), this.notify(\"element:pointerdown\", t, e, i), this.dragStart(t, e, i));\n    },\n    pointermove: function pointermove(t, e, i) {\n      var n = this.eventData(t);\n\n      switch (n.action) {\n        case \"magnet\":\n          this.dragMagnet(t, e, i);\n          break;\n\n        case \"move\":\n          (n.delegatedView || this).drag(t, e, i);\n\n        default:\n          joint.dia.CellView.prototype.pointermove.apply(this, arguments), this.notify(\"element:pointermove\", t, e, i);\n      }\n\n      this.eventData(t, n);\n    },\n    pointerup: function pointerup(t, e, i) {\n      var n = this.eventData(t);\n\n      switch (n.action) {\n        case \"magnet\":\n          this.dragMagnetEnd(t, e, i);\n          break;\n\n        case \"move\":\n          (n.delegatedView || this).dragEnd(t, e, i);\n\n        default:\n          this.notify(\"element:pointerup\", t, e, i), joint.dia.CellView.prototype.pointerup.apply(this, arguments);\n      }\n\n      var r = n.targetMagnet;\n      r && this.magnetpointerclick(t, r, e, i);\n    },\n    mouseover: function mouseover(t) {\n      joint.dia.CellView.prototype.mouseover.apply(this, arguments), this.notify(\"element:mouseover\", t);\n    },\n    mouseout: function mouseout(t) {\n      joint.dia.CellView.prototype.mouseout.apply(this, arguments), this.notify(\"element:mouseout\", t);\n    },\n    mouseenter: function mouseenter(t) {\n      joint.dia.CellView.prototype.mouseenter.apply(this, arguments), this.notify(\"element:mouseenter\", t);\n    },\n    mouseleave: function mouseleave(t) {\n      joint.dia.CellView.prototype.mouseleave.apply(this, arguments), this.notify(\"element:mouseleave\", t);\n    },\n    mousewheel: function mousewheel(t, e, i, n) {\n      joint.dia.CellView.prototype.mousewheel.apply(this, arguments), this.notify(\"element:mousewheel\", t, e, i, n);\n    },\n    onmagnet: function onmagnet(t, e, i) {\n      this.dragMagnetStart(t, e, i);\n    },\n    magnetpointerdblclick: function magnetpointerdblclick(t, e, i, n) {\n      this.notify(\"element:magnet:pointerdblclick\", t, e, i, n);\n    },\n    magnetcontextmenu: function magnetcontextmenu(t, e, i, n) {\n      this.notify(\"element:magnet:contextmenu\", t, e, i, n);\n    },\n    dragStart: function dragStart(t, e, i) {\n      var n = this.getDelegatedView();\n      n && n.can(\"elementMove\") && (this.eventData(t, {\n        action: \"move\",\n        delegatedView: n\n      }), n.eventData(t, {\n        x: e,\n        y: i,\n        restrictedArea: this.paper.getRestrictedArea(n)\n      }));\n    },\n    dragMagnetStart: function dragMagnetStart(t, e, i) {\n      if (this.can(\"addLinkFromMagnet\")) {\n        var n = t.currentTarget,\n            r = this.paper;\n        this.eventData(t, {\n          targetMagnet: n\n        }), t.stopPropagation(), r.options.validateMagnet(this, n) ? (r.options.magnetThreshold <= 0 && this.dragLinkStart(t, n, e, i), this.eventData(t, {\n          action: \"magnet\"\n        }), this.stopPropagation(t)) : this.pointerdown(t, e, i), r.delegateDragEvents(this, t.data);\n      }\n    },\n    dragLinkStart: function dragLinkStart(t, e, i, n) {\n      this.model.startBatch(\"add-link\");\n      var r = this.addLinkFromMagnet(e, i, n);\n      joint.dia.CellView.prototype.pointerdown.apply(r, arguments), r.notify(\"link:pointerdown\", t, i, n), r.eventData(t, r.startArrowheadMove(\"target\", {\n        whenNotAllowed: \"remove\"\n      })), this.eventData(t, {\n        linkView: r\n      });\n    },\n    addLinkFromMagnet: function addLinkFromMagnet(t, e, i) {\n      var n = this.paper,\n          r = n.model,\n          o = n.getDefaultLink(this, t);\n      return o.set({\n        source: this.getLinkEnd(t, e, i, o, \"source\"),\n        target: {\n          x: e,\n          y: i\n        }\n      }).addTo(r, {\n        async: !1,\n        ui: !0\n      }), o.findView(n);\n    },\n    drag: function drag(t, e, i) {\n      var n = this.paper,\n          r = n.options.gridSize,\n          o = this.model,\n          s = o.position(),\n          a = this.eventData(t),\n          l = g.snapToGrid(s.x, r) - s.x + g.snapToGrid(e - a.x, r),\n          h = g.snapToGrid(s.y, r) - s.y + g.snapToGrid(i - a.y, r);\n      o.translate(l, h, {\n        restrictedArea: a.restrictedArea,\n        ui: !0\n      });\n      var u = !!a.embedding;\n      n.options.embeddingMode && (u || (this.prepareEmbedding(a), u = !0), this.processEmbedding(a)), this.eventData(t, {\n        x: g.snapToGrid(e, r),\n        y: g.snapToGrid(i, r),\n        embedding: u\n      });\n    },\n    dragMagnet: function dragMagnet(t, e, i) {\n      var n = this.eventData(t),\n          r = n.linkView;\n      if (r) r.pointermove(t, e, i);else {\n        var o = this.paper,\n            s = o.options.magnetThreshold,\n            a = this.getEventTarget(t),\n            l = n.targetMagnet;\n\n        if (\"onleave\" === s) {\n          if (l === a || V(l).contains(a)) return;\n        } else if (o.eventData(t).mousemoved <= s) return;\n\n        this.dragLinkStart(t, l, e, i);\n      }\n    },\n    dragEnd: function dragEnd(t, e, i) {\n      var n = this.eventData(t);\n      n.embedding && this.finalizeEmbedding(n);\n    },\n    dragMagnetEnd: function dragMagnetEnd(t, e, i) {\n      var n = this.eventData(t).linkView;\n      n && (n.pointerup(t, e, i), this.model.stopBatch(\"add-link\"));\n    },\n    magnetpointerclick: function magnetpointerclick(t, e, i, n) {\n      var r = this.paper;\n      r.eventData(t).mousemoved > r.options.clickThreshold || this.notify(\"element:magnet:pointerclick\", t, e, i, n);\n    }\n  }), joint.dia.Link = joint.dia.Cell.extend({\n    markup: ['<path class=\"connection\" stroke=\"black\" d=\"M 0 0 0 0\"/>', '<path class=\"marker-source\" fill=\"black\" stroke=\"black\" d=\"M 0 0 0 0\"/>', '<path class=\"marker-target\" fill=\"black\" stroke=\"black\" d=\"M 0 0 0 0\"/>', '<path class=\"connection-wrap\" d=\"M 0 0 0 0\"/>', '<g class=\"labels\"/>', '<g class=\"marker-vertices\"/>', '<g class=\"marker-arrowheads\"/>', '<g class=\"link-tools\"/>'].join(\"\"),\n    toolMarkup: ['<g class=\"link-tool\">', '<g class=\"tool-remove\" event=\"remove\">', '<circle r=\"11\" />', '<path transform=\"scale(.8) translate(-16, -16)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\" />', \"<title>Remove link.</title>\", \"</g>\", '<g class=\"tool-options\" event=\"link:options\">', '<circle r=\"11\" transform=\"translate(25)\"/>', '<path fill=\"white\" transform=\"scale(.55) translate(29, -16)\" d=\"M31.229,17.736c0.064-0.571,0.104-1.148,0.104-1.736s-0.04-1.166-0.104-1.737l-4.377-1.557c-0.218-0.716-0.504-1.401-0.851-2.05l1.993-4.192c-0.725-0.91-1.549-1.734-2.458-2.459l-4.193,1.994c-0.647-0.347-1.334-0.632-2.049-0.849l-1.558-4.378C17.165,0.708,16.588,0.667,16,0.667s-1.166,0.041-1.737,0.105L12.707,5.15c-0.716,0.217-1.401,0.502-2.05,0.849L6.464,4.005C5.554,4.73,4.73,5.554,4.005,6.464l1.994,4.192c-0.347,0.648-0.632,1.334-0.849,2.05l-4.378,1.557C0.708,14.834,0.667,15.412,0.667,16s0.041,1.165,0.105,1.736l4.378,1.558c0.217,0.715,0.502,1.401,0.849,2.049l-1.994,4.193c0.725,0.909,1.549,1.733,2.459,2.458l4.192-1.993c0.648,0.347,1.334,0.633,2.05,0.851l1.557,4.377c0.571,0.064,1.148,0.104,1.737,0.104c0.588,0,1.165-0.04,1.736-0.104l1.558-4.377c0.715-0.218,1.399-0.504,2.049-0.851l4.193,1.993c0.909-0.725,1.733-1.549,2.458-2.458l-1.993-4.193c0.347-0.647,0.633-1.334,0.851-2.049L31.229,17.736zM16,20.871c-2.69,0-4.872-2.182-4.872-4.871c0-2.69,2.182-4.872,4.872-4.872c2.689,0,4.871,2.182,4.871,4.872C20.871,18.689,18.689,20.871,16,20.871z\"/>', \"<title>Link options.</title>\", \"</g>\", \"</g>\"].join(\"\"),\n    doubleToolMarkup: void 0,\n    vertexMarkup: ['<g class=\"marker-vertex-group\" transform=\"translate(<%= x %>, <%= y %>)\">', '<circle class=\"marker-vertex\" idx=\"<%= idx %>\" r=\"10\" />', '<path class=\"marker-vertex-remove-area\" idx=\"<%= idx %>\" d=\"M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z\" transform=\"translate(5, -33)\"/>', '<path class=\"marker-vertex-remove\" idx=\"<%= idx %>\" transform=\"scale(.8) translate(9.5, -37)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\">', \"<title>Remove vertex.</title>\", \"</path>\", \"</g>\"].join(\"\"),\n    arrowheadMarkup: ['<g class=\"marker-arrowhead-group marker-arrowhead-group-<%= end %>\">', '<path class=\"marker-arrowhead\" end=\"<%= end %>\" d=\"M 26 0 L 0 13 L 26 26 z\" />', \"</g>\"].join(\"\"),\n    defaultLabel: void 0,\n    labelMarkup: void 0,\n    _builtins: {\n      defaultLabel: {\n        markup: [{\n          tagName: \"rect\",\n          selector: \"rect\"\n        }, {\n          tagName: \"text\",\n          selector: \"text\"\n        }],\n        attrs: {\n          text: {\n            fill: \"#000000\",\n            fontSize: 14,\n            textAnchor: \"middle\",\n            yAlignment: \"middle\",\n            pointerEvents: \"none\"\n          },\n          rect: {\n            ref: \"text\",\n            fill: \"#ffffff\",\n            rx: 3,\n            ry: 3,\n            refWidth: 1,\n            refHeight: 1,\n            refX: 0,\n            refY: 0\n          }\n        },\n        position: {\n          distance: .5\n        }\n      }\n    },\n    defaults: {\n      type: \"link\",\n      source: {},\n      target: {}\n    },\n    isLink: function isLink() {\n      return !0;\n    },\n    disconnect: function disconnect(t) {\n      return this.set({\n        source: {\n          x: 0,\n          y: 0\n        },\n        target: {\n          x: 0,\n          y: 0\n        }\n      }, t);\n    },\n    source: function source(t, e, i) {\n      return void 0 === t ? joint.util.clone(this.get(\"source\")) : (r = t instanceof joint.dia.Cell ? ((n = joint.util.clone(e) || {}).id = t.id, i) : t instanceof g.Point ? ((n = joint.util.clone(e) || {}).x = t.x, n.y = t.y, i) : (n = t, e), this.set(\"source\", n, r));\n      var n, r;\n    },\n    target: function target(t, e, i) {\n      return void 0 === t ? joint.util.clone(this.get(\"target\")) : (r = t instanceof joint.dia.Cell ? ((n = joint.util.clone(e) || {}).id = t.id, i) : t instanceof g.Point ? ((n = joint.util.clone(e) || {}).x = t.x, n.y = t.y, i) : (n = t, e), this.set(\"target\", n, r));\n      var n, r;\n    },\n    router: function router(t, e, i) {\n      if (void 0 === t) {\n        var n = this.get(\"router\");\n        return n ? \"object\" == typeof n ? joint.util.clone(n) : n : this.get(\"manhattan\") ? {\n          name: \"orthogonal\"\n        } : null;\n      }\n\n      var r = \"object\" == typeof t || \"function\" == typeof t,\n          o = r ? t : {\n        name: t,\n        args: e\n      },\n          s = r ? e : i;\n      return this.set(\"router\", o, s);\n    },\n    connector: function connector(t, e, i) {\n      if (void 0 === t) {\n        var n = this.get(\"connector\");\n        return n ? \"object\" == typeof n ? joint.util.clone(n) : n : this.get(\"smooth\") ? {\n          name: \"smooth\"\n        } : null;\n      }\n\n      var r = \"object\" == typeof t || \"function\" == typeof t,\n          o = r ? t : {\n        name: t,\n        args: e\n      },\n          s = r ? e : i;\n      return this.set(\"connector\", o, s);\n    },\n    label: function label(t, e, i) {\n      var n = this.labels();\n      return (t = isFinite(t) && null !== t ? 0 | t : 0) < 0 && (t = n.length + t), arguments.length <= 1 ? this.prop([\"labels\", t]) : this.prop([\"labels\", t], e, i);\n    },\n    labels: function labels(t, e) {\n      return 0 === arguments.length ? (t = this.get(\"labels\"), Array.isArray(t) ? t.slice() : []) : (Array.isArray(t) || (t = []), this.set(\"labels\", t, e));\n    },\n    insertLabel: function insertLabel(t, e, i) {\n      if (!e) throw new Error(\"dia.Link: no label provided\");\n      var n = this.labels(),\n          r = n.length;\n      return (t = isFinite(t) && null !== t ? 0 | t : r) < 0 && (t = r + t + 1), n.splice(t, 0, e), this.labels(n, i);\n    },\n    appendLabel: function appendLabel(t, e) {\n      return this.insertLabel(-1, t, e);\n    },\n    removeLabel: function removeLabel(t, e) {\n      var i = this.labels();\n      return t = isFinite(t) && null !== t ? 0 | t : -1, i.splice(t, 1), this.labels(i, e);\n    },\n    vertex: function vertex(t, e, i) {\n      var n = this.vertices();\n      return (t = isFinite(t) && null !== t ? 0 | t : 0) < 0 && (t = n.length + t), arguments.length <= 1 ? this.prop([\"vertices\", t]) : this.prop([\"vertices\", t], e, i);\n    },\n    vertices: function vertices(t, e) {\n      return 0 === arguments.length ? (t = this.get(\"vertices\"), Array.isArray(t) ? t.slice() : []) : (Array.isArray(t) || (t = []), this.set(\"vertices\", t, e));\n    },\n    insertVertex: function insertVertex(t, e, i) {\n      if (!e) throw new Error(\"dia.Link: no vertex provided\");\n      var n = this.vertices(),\n          r = n.length;\n      return (t = isFinite(t) && null !== t ? 0 | t : r) < 0 && (t = r + t + 1), n.splice(t, 0, e), this.vertices(n, i);\n    },\n    removeVertex: function removeVertex(t, e) {\n      var i = this.vertices();\n      return t = isFinite(t) && null !== t ? 0 | t : -1, i.splice(t, 1), this.vertices(i, e);\n    },\n    translate: function translate(e, i, t) {\n      return (t = t || {}).translateBy = t.translateBy || this.id, t.tx = e, t.ty = i, this.applyToPoints(function (t) {\n        return {\n          x: (t.x || 0) + e,\n          y: (t.y || 0) + i\n        };\n      }, t);\n    },\n    scale: function scale(e, i, n, t) {\n      return this.applyToPoints(function (t) {\n        return g.point(t).scale(e, i, n).toJSON();\n      }, t);\n    },\n    applyToPoints: function applyToPoints(t, e) {\n      if (!joint.util.isFunction(t)) throw new TypeError(\"dia.Link: applyToPoints expects its first parameter to be a function.\");\n      var i = {},\n          n = this.source();\n      n.id || (i.source = t(n));\n      var r = this.target();\n      r.id || (i.target = t(r));\n      var o = this.vertices();\n      return 0 < o.length && (i.vertices = o.map(t)), this.set(i, e);\n    },\n    reparent: function reparent(t) {\n      var e;\n\n      if (this.graph) {\n        var i = this.getSourceElement(),\n            n = this.getTargetElement(),\n            r = this.getParentCell();\n        i && n && (e = i === n || i.isEmbeddedIn(n) ? n : n.isEmbeddedIn(i) ? i : this.graph.getCommonAncestor(i, n)), !r || e && e.id === r.id || r.unembed(this, t), e && e.embed(this, t);\n      }\n\n      return e;\n    },\n    hasLoop: function hasLoop(t) {\n      t = t || {};\n      var e = this.source().id,\n          i = this.target().id;\n      if (!e || !i) return !1;\n      var n = e === i;\n\n      if (!n && t.deep && this.graph) {\n        var r = this.getSourceElement(),\n            o = this.getTargetElement();\n        n = r.isEmbeddedIn(o) || o.isEmbeddedIn(r);\n      }\n\n      return n;\n    },\n    getSourceElement: function getSourceElement() {\n      var t = this.source(),\n          e = this.graph;\n      return t && t.id && e && e.getCell(t.id) || null;\n    },\n    getTargetElement: function getTargetElement() {\n      var t = this.target(),\n          e = this.graph;\n      return t && t.id && e && e.getCell(t.id) || null;\n    },\n    getRelationshipAncestor: function getRelationshipAncestor() {\n      var t;\n\n      if (this.graph) {\n        var e = [this, this.getSourceElement(), this.getTargetElement()].filter(function (t) {\n          return !!t;\n        });\n        t = this.graph.getCommonAncestor.apply(this.graph, e);\n      }\n\n      return t || null;\n    },\n    isRelationshipEmbeddedIn: function isRelationshipEmbeddedIn(t) {\n      var e = joint.util.isString(t) || joint.util.isNumber(t) ? t : t.id,\n          i = this.getRelationshipAncestor();\n      return !!i && (i.id === e || i.isEmbeddedIn(e));\n    },\n    _getDefaultLabel: function _getDefaultLabel() {\n      var t = this.get(\"defaultLabel\") || this.defaultLabel || {},\n          e = {};\n      return e.markup = t.markup || this.get(\"labelMarkup\") || this.labelMarkup, e.position = t.position, e.attrs = t.attrs, e.size = t.size, e;\n    }\n  }, {\n    endsEqual: function endsEqual(t, e) {\n      var i = t.port === e.port || !t.port && !e.port;\n      return t.id === e.id && i;\n    }\n  }), joint.dia.LinkView = joint.dia.CellView.extend({\n    className: function className() {\n      var t = joint.dia.CellView.prototype.className.apply(this).split(\" \");\n      return t.push(\"link\"), t.join(\" \");\n    },\n    options: {\n      shortLinkLength: 105,\n      doubleLinkTools: !1,\n      longLinkLength: 155,\n      linkToolsOffset: 40,\n      doubleLinkToolsOffset: 65,\n      sampleInterval: 50\n    },\n    _labelCache: null,\n    _labelSelectors: null,\n    _markerCache: null,\n    _V: null,\n    _dragData: null,\n    metrics: null,\n    decimalsRounding: 2,\n    initialize: function initialize(t) {\n      joint.dia.CellView.prototype.initialize.apply(this, arguments), \"function\" != typeof this.constructor.prototype.watchSource && (this.constructor.prototype.watchSource = this.createWatcher(\"source\"), this.constructor.prototype.watchTarget = this.createWatcher(\"target\")), this._labelCache = {}, this._labelSelectors = {}, this._markerCache = {}, this._V = {}, this.metrics = {}, this.startListening();\n    },\n    startListening: function startListening() {\n      var t = this.model;\n      this.listenTo(t, \"change:markup\", this.render), this.listenTo(t, \"change:smooth change:manhattan change:router change:connector\", this.update), this.listenTo(t, \"change:toolMarkup\", this.onToolsChange), this.listenTo(t, \"change:labels change:labelMarkup\", this.onLabelsChange), this.listenTo(t, \"change:vertices change:vertexMarkup\", this.onVerticesChange), this.listenTo(t, \"change:source\", this.onSourceChange), this.listenTo(t, \"change:target\", this.onTargetChange);\n    },\n    onSourceChange: function onSourceChange(t, e, i) {\n      this.watchSource(t, e);\n      var n = this.model;\n      i.translateBy && n.get(\"target\").id && e.id || this.update(n, null, i);\n    },\n    onTargetChange: function onTargetChange(t, e, i) {\n      this.watchTarget(t, e);\n      var n = this.model;\n      (!i.translateBy || n.get(\"source\").id && !e.id && joint.util.isEmpty(n.get(\"vertices\"))) && this.update(n, null, i);\n    },\n    onVerticesChange: function onVerticesChange(t, e, i) {\n      this.renderVertexMarkers(), i.translateBy && i.translateBy !== this.model.id && !this.model.hasLoop() || this.update(t, null, i);\n    },\n    onToolsChange: function onToolsChange() {\n      this.renderTools().updateToolsPosition();\n    },\n    onLabelsChange: function onLabelsChange(t, e, i) {\n      var n = !0,\n          r = this.model.previous(\"labels\");\n\n      if (r && \"propertyPathArray\" in i && \"propertyValue\" in i) {\n        var o = i.propertyPathArray || [],\n            s = o.length;\n        if (1 < s) !!r[o[1]] && (2 === s ? n = \"markup\" in Object(i.propertyValue) : \"markup\" !== o[2] && (n = !1));\n      }\n\n      n ? this.renderLabels() : this.updateLabels(), this.updateLabelPositions();\n    },\n    render: function render() {\n      this.vel.empty(), this._V = {}, this.renderMarkup(), this.renderLabels();\n      var t = this.model;\n      return this.watchSource(t, t.source()).watchTarget(t, t.target()).update(), this;\n    },\n    renderMarkup: function renderMarkup() {\n      var t = this.model,\n          e = t.get(\"markup\") || t.markup;\n      if (!e) throw new Error(\"dia.LinkView: markup required\");\n      if (Array.isArray(e)) return this.renderJSONMarkup(e);\n      if (\"string\" == typeof e) return this.renderStringMarkup(e);\n      throw new Error(\"dia.LinkView: invalid markup\");\n    },\n    renderJSONMarkup: function renderJSONMarkup(t) {\n      var e = this.parseDOMJSON(t, this.el);\n      this.selectors = e.selectors, this.vel.append(e.fragment);\n    },\n    renderStringMarkup: function renderStringMarkup(t) {\n      var e = V(t);\n      Array.isArray(e) || (e = [e]);\n\n      for (var i = this._V, n = 0, r = e.length; n < r; n++) {\n        var o = e[n],\n            s = o.attr(\"class\");\n        s && (s = joint.util.removeClassNamePrefix(s), i[$.camelCase(s)] = o);\n      }\n\n      this.renderTools(), this.renderVertexMarkers(), this.renderArrowheadMarkers(), this.vel.append(e);\n    },\n    _getLabelMarkup: function _getLabelMarkup(t) {\n      if (t) {\n        if (Array.isArray(t)) return this.parseDOMJSON(t, null);\n        if (\"string\" == typeof t) return this._getLabelStringMarkup(t);\n        throw new Error(\"dia.linkView: invalid label markup\");\n      }\n    },\n    _getLabelStringMarkup: function _getLabelStringMarkup(t) {\n      var e = V(t),\n          i = document.createDocumentFragment();\n      if (Array.isArray(e)) for (var n = 0, r = e.length; n < r; n++) {\n        var o = e[n].node;\n        i.appendChild(o);\n      } else i.appendChild(e.node);\n      return {\n        fragment: i,\n        selectors: {}\n      };\n    },\n    _normalizeLabelMarkup: function _normalizeLabelMarkup(t) {\n      if (t) {\n        var e,\n            i = t.fragment;\n        if (!(t.fragment instanceof DocumentFragment && t.fragment.hasChildNodes())) throw new Error(\"dia.LinkView: invalid label markup.\");\n        var n = i.childNodes;\n        return (e = 1 < n.length || \"G\" !== n[0].nodeName.toUpperCase() ? V(\"g\").append(i) : V(n[0])).addClass(\"label\"), {\n          node: e.node,\n          selectors: t.selectors\n        };\n      }\n    },\n    renderLabels: function renderLabels() {\n      var t = this._V,\n          e = t.labels,\n          i = this._labelCache = {},\n          n = this._labelSelectors = {},\n          r = this.model,\n          o = r.attributes.labels || [],\n          s = o.length;\n      if (0 === s) return e && e.remove(), this;\n      e ? e.empty() : e = t.labels = V(\"g\").addClass(\"labels\");\n\n      for (var a = e.node, l = 0; l < s; l++) {\n        var h,\n            u,\n            c = o[l],\n            d = this._normalizeLabelMarkup(this._getLabelMarkup(c.markup));\n\n        if (d) h = d.node, u = d.selectors;else {\n          var f = r._builtins.defaultLabel,\n              g = this._normalizeLabelMarkup(this._getLabelMarkup(f.markup)),\n              p = r._getDefaultLabel(),\n              m = this._normalizeLabelMarkup(this._getLabelMarkup(p.markup)) || g;\n\n          h = m.node, u = m.selectors;\n        }\n        h.setAttribute(\"label-idx\", l), a.appendChild(h), i[l] = h;\n        var v = this.selector;\n        if (u[v]) throw new Error(\"dia.LinkView: ambiguous label root selector.\");\n        u[v] = h, n[l] = u;\n      }\n\n      return a.parentNode || this.el.appendChild(a), this.updateLabels(), this;\n    },\n    _mergeLabelAttrs: function _mergeLabelAttrs(t, e, i, n) {\n      return null === e ? null : void 0 !== e ? t ? joint.util.merge({}, i, e) : joint.util.merge({}, n, i, e) : null === i ? null : void 0 !== i ? t ? i : joint.util.merge({}, n, i) : t ? void 0 : n;\n    },\n    updateLabels: function updateLabels() {\n      if (!this._V.labels) return this;\n\n      for (var t = this.model, e = t.get(\"labels\") || [], i = this.can(\"labelMove\"), n = t._builtins.defaultLabel.attrs, r = t._getDefaultLabel(), o = r.markup, s = r.attrs, a = 0, l = e.length; a < l; a++) {\n        var h = this._labelCache[a];\n        h.setAttribute(\"cursor\", i ? \"move\" : \"default\");\n\n        var u = this._labelSelectors[a],\n            c = e[a],\n            d = c.markup,\n            f = c.attrs,\n            p = this._mergeLabelAttrs(d || o, f, s, n);\n\n        this.updateDOMSubtreeAttributes(h, p, {\n          rootBBox: new g.Rect(c.size),\n          selectors: u\n        });\n      }\n\n      return this;\n    },\n    renderTools: function renderTools() {\n      if (!this._V.linkTools) return this;\n      var t,\n          e = $(this._V.linkTools.node).empty(),\n          i = joint.util.template(this.model.get(\"toolMarkup\") || this.model.toolMarkup),\n          n = V(i());\n      (e.append(n.node), this._toolCache = n, this.options.doubleLinkTools) && (t = this.model.get(\"doubleToolMarkup\") || this.model.doubleToolMarkup ? (i = joint.util.template(this.model.get(\"doubleToolMarkup\") || this.model.doubleToolMarkup), V(i())) : n.clone(), e.append(t.node), this._tool2Cache = t);\n      return this;\n    },\n    renderVertexMarkers: function renderVertexMarkers() {\n      if (!this._V.markerVertices) return this;\n      var i = $(this._V.markerVertices.node).empty(),\n          n = joint.util.template(this.model.get(\"vertexMarkup\") || this.model.vertexMarkup);\n      return this.model.vertices().forEach(function (t, e) {\n        i.append(V(n(joint.util.assign({\n          idx: e\n        }, t))).node);\n      }), this;\n    },\n    renderArrowheadMarkers: function renderArrowheadMarkers() {\n      if (!this._V.markerArrowheads) return this;\n      var t = $(this._V.markerArrowheads.node);\n      t.empty();\n      var e = joint.util.template(this.model.get(\"arrowheadMarkup\") || this.model.arrowheadMarkup);\n      return this._V.sourceArrowhead = V(e({\n        end: \"source\"\n      })), this._V.targetArrowhead = V(e({\n        end: \"target\"\n      })), t.append(this._V.sourceArrowhead.node, this._V.targetArrowhead.node), this;\n    },\n    update: function update(t, e, i) {\n      return i || (i = {}), this.updateConnection(i), this.updateDOMSubtreeAttributes(this.el, this.model.attr(), {\n        selectors: this.selectors\n      }), this.updateDefaultConnectionPath(), this.updateLabelPositions(), this.updateToolsPosition(), this.updateArrowheadMarkers(), this.updateTools(i), this.options.perpendicular = null, this.updatePostponed = !1, this;\n    },\n    removeRedundantLinearVertices: function removeRedundantLinearVertices(t) {\n      for (var e = this.model, i = e.vertices(), n = [], r = i.length, o = 0, s = 0; s < r; s++) {\n        var a = new g.Point(i[s]).round(),\n            l = new g.Point(n[o - 1] || this.sourceAnchor).round();\n\n        if (!l.equals(a)) {\n          var h = new g.Point(i[s + 1] || this.targetAnchor).round();\n          if (!l.equals(h)) 0 !== new g.Line(l, h).pointOffset(a) && (n.push(i[s]), o++);\n        }\n      }\n\n      return r === o ? 0 : (e.vertices(n, t), r - o);\n    },\n    updateDefaultConnectionPath: function updateDefaultConnectionPath() {\n      var t = this._V;\n      t.connection && t.connection.attr(\"d\", this.getSerializedConnection()), t.connectionWrap && t.connectionWrap.attr(\"d\", this.getSerializedConnection()), t.markerSource && t.markerTarget && this._translateAndAutoOrientArrows(t.markerSource, t.markerTarget);\n    },\n    getEndView: function getEndView(t) {\n      switch (t) {\n        case \"source\":\n          return this.sourceView || null;\n\n        case \"target\":\n          return this.targetView || null;\n\n        default:\n          throw new Error(\"dia.LinkView: type parameter required.\");\n      }\n    },\n    getEndAnchor: function getEndAnchor(t) {\n      switch (t) {\n        case \"source\":\n          return new g.Point(this.sourceAnchor);\n\n        case \"target\":\n          return new g.Point(this.targetAnchor);\n\n        default:\n          throw new Error(\"dia.LinkView: type parameter required.\");\n      }\n    },\n    getEndMagnet: function getEndMagnet(t) {\n      switch (t) {\n        case \"source\":\n          var e = this.sourceView;\n          if (!e) break;\n          return this.sourceMagnet || e.el;\n\n        case \"target\":\n          var i = this.targetView;\n          if (!i) break;\n          return this.targetMagnet || i.el;\n\n        default:\n          throw new Error(\"dia.LinkView: type parameter required.\");\n      }\n\n      return null;\n    },\n    updateConnection: function updateConnection(t) {\n      t = t || {};\n      var e,\n          i,\n          n = this.model;\n\n      if (t.translateBy && n.isRelationshipEmbeddedIn(t.translateBy)) {\n        var r = t.tx || 0,\n            o = t.ty || 0;\n        e = new g.Polyline(this.route).translate(r, o).points, this._translateConnectionPoints(r, o), (i = this.path).translate(r, o);\n      } else {\n        var s = n.vertices(),\n            a = this.findAnchors(s),\n            l = this.sourceAnchor = a.source,\n            h = this.targetAnchor = a.target;\n        e = this.findRoute(s, t);\n        var u = this.findConnectionPoints(e, l, h),\n            c = this.sourcePoint = u.source,\n            d = this.targetPoint = u.target,\n            f = this.findMarkerPoints(e, c, d);\n        i = this.findPath(e, f.source || c, f.target || d);\n      }\n\n      this.route = e, this.path = i, this.metrics = {};\n    },\n    findMarkerPoints: function findMarkerPoints(t, e, i) {\n      var n,\n          r,\n          o = t[0],\n          s = t[t.length - 1],\n          a = this._markerCache;\n      return this._V.markerSource && (a.sourceBBox = a.sourceBBox || this._V.markerSource.getBBox(), n = g.point(e).move(o || i, a.sourceBBox.width * this._V.markerSource.scale().sx * -1).round()), this._V.markerTarget && (a.targetBBox = a.targetBBox || this._V.markerTarget.getBBox(), r = g.point(i).move(s || e, a.targetBBox.width * this._V.markerTarget.scale().sx * -1).round()), a.sourcePoint = n || e.clone(), a.targetPoint = r || i.clone(), {\n        source: n,\n        target: r\n      };\n    },\n    findAnchors: function findAnchors(t) {\n      var e,\n          i,\n          n,\n          r,\n          o,\n          s = this.model,\n          a = t[0],\n          l = t[t.length - 1],\n          h = s.get(\"source\"),\n          u = s.get(\"target\"),\n          c = this.sourceView,\n          d = this.targetView;\n      c ? (e = this.sourceMagnet || c.el, r = a ? new g.Point(a) : d ? this.targetMagnet || d.el : new g.Point(u), n = this.getAnchor(h.anchor, c, e, r, \"source\")) : n = new g.Point(h);\n\n      if (d) {\n        i = this.targetMagnet || d.el;\n        var f = new g.Point(l || n);\n        o = this.getAnchor(u.anchor, d, i, f, \"target\");\n      } else o = new g.Point(u);\n\n      return {\n        source: n,\n        target: o\n      };\n    },\n    findConnectionPoints: function findConnectionPoints(t, e, i) {\n      var n,\n          r,\n          o,\n          s,\n          a = t[0],\n          l = t[t.length - 1],\n          h = this.model,\n          u = h.get(\"source\"),\n          c = h.get(\"target\"),\n          d = this.sourceView,\n          f = this.targetView,\n          p = this.paper.options;\n\n      if (d) {\n        n = this.sourceMagnet || d.el;\n        var m = u.connectionPoint || p.defaultConnectionPoint,\n            v = a || i,\n            y = new g.Line(v, e);\n        o = this.getConnectionPoint(m, d, n, y, \"source\");\n      } else o = e;\n\n      if (f) {\n        r = this.targetMagnet || f.el;\n        var b = c.connectionPoint || p.defaultConnectionPoint,\n            w = l || e,\n            x = new g.Line(w, i);\n        s = this.getConnectionPoint(b, f, r, x, \"target\");\n      } else s = i;\n\n      return {\n        source: o,\n        target: s\n      };\n    },\n    getAnchor: function getAnchor(t, e, i, n, r) {\n      if (!t) {\n        var o = this.paper.options;\n        t = o.perpendicularLinks || this.options.perpendicular ? {\n          name: \"perpendicular\"\n        } : o.defaultAnchor;\n      }\n\n      if (!t) throw new Error(\"Anchor required.\");\n      var s;\n      if (\"function\" == typeof t) s = t;else {\n        var a = t.name;\n        if (\"function\" != typeof (s = joint.anchors[a])) throw new Error(\"Unknown anchor: \" + a);\n      }\n      var l = s.call(this, e, i, n, t.args || {}, r, this);\n      return l ? l.round(this.decimalsRounding) : new g.Point();\n    },\n    getConnectionPoint: function getConnectionPoint(t, e, i, n, r) {\n      var o,\n          s,\n          a = n.end,\n          l = this.paper.options;\n\n      if (\"function\" == typeof l.linkConnectionPoint) {\n        var h = i === e.el ? void 0 : i;\n        if (o = l.linkConnectionPoint(this, e, h, n.start, r)) return o;\n      }\n\n      if (!t) return a;\n      if (\"function\" == typeof t) s = t;else {\n        var u = t.name;\n        if (\"function\" != typeof (s = joint.connectionPoints[u])) throw new Error(\"Unknown connection point: \" + u);\n      }\n      return (o = s.call(this, n, e, i, t.args || {}, r, this)) ? o.round(this.decimalsRounding) : a;\n    },\n    _translateConnectionPoints: function _translateConnectionPoints(t, e) {\n      var i = this._markerCache;\n      i.sourcePoint.offset(t, e), i.targetPoint.offset(t, e), this.sourcePoint.offset(t, e), this.targetPoint.offset(t, e), this.sourceAnchor.offset(t, e), this.targetAnchor.offset(t, e);\n    },\n    _normalizeLabelPosition: function _normalizeLabelPosition(t) {\n      return \"number\" == typeof t ? {\n        distance: t,\n        offset: null,\n        args: null\n      } : t;\n    },\n    updateLabelPositions: function updateLabelPositions() {\n      if (!this._V.labels) return this;\n      if (!this.path) return this;\n      var t = this.model,\n          e = t.get(\"labels\") || [];\n      if (!e.length) return this;\n\n      for (var i = t._builtins.defaultLabel.position, n = t._getDefaultLabel(), r = this._normalizeLabelPosition(n.position), o = joint.util.merge({}, i, r), s = 0, a = e.length; s < a; s++) {\n        var l = e[s],\n            h = this._normalizeLabelPosition(l.position),\n            u = joint.util.merge({}, o, h),\n            c = this.getLabelCoordinates(u);\n\n        this._labelCache[s].setAttribute(\"transform\", \"translate(\" + c.x + \", \" + c.y + \")\");\n      }\n\n      return this;\n    },\n    updateToolsPosition: function updateToolsPosition() {\n      if (!this._V.linkTools) return this;\n      var t = \"\",\n          e = this.options.linkToolsOffset,\n          i = this.getConnectionLength();\n\n      if (!Number.isNaN(i)) {\n        i < this.options.shortLinkLength && (t = \"scale(.5)\", e /= 2);\n        var n = this.getPointAtLength(e);\n\n        if (this._toolCache.attr(\"transform\", \"translate(\" + n.x + \", \" + n.y + \") \" + t), this.options.doubleLinkTools && i >= this.options.longLinkLength) {\n          var r = this.options.doubleLinkToolsOffset || e;\n          n = this.getPointAtLength(i - r), this._tool2Cache.attr(\"transform\", \"translate(\" + n.x + \", \" + n.y + \") \" + t), this._tool2Cache.attr(\"visibility\", \"visible\");\n        } else this.options.doubleLinkTools && this._tool2Cache.attr(\"visibility\", \"hidden\");\n      }\n\n      return this;\n    },\n    updateArrowheadMarkers: function updateArrowheadMarkers() {\n      if (!this._V.markerArrowheads) return this;\n      if (\"none\" === $.css(this._V.markerArrowheads.node, \"display\")) return this;\n      var t = this.getConnectionLength() < this.options.shortLinkLength ? .5 : 1;\n      return this._V.sourceArrowhead.scale(t), this._V.targetArrowhead.scale(t), this._translateAndAutoOrientArrows(this._V.sourceArrowhead, this._V.targetArrowhead), this;\n    },\n    createWatcher: function createWatcher(r) {\n      var o = function o(t, e) {\n        this.onEndModelChange(r, t, e);\n      };\n\n      return function (t, e) {\n        e = e || {};\n        var i = null,\n            n = t.previous(r) || {};\n        return n.id && this.stopListening(this.paper.getModelById(n.id), \"change\", o), e.id && (i = this.paper.getModelById(e.id), this.listenTo(i, \"change\", o)), o.call(this, i, {\n          cacheOnly: !0\n        }), this;\n      };\n    },\n    onEndModelChange: function onEndModelChange(t, e, i) {\n      var n = !i.cacheOnly,\n          r = this.model,\n          o = r.get(t) || {};\n\n      if (e) {\n        var s = this.constructor.makeSelector(o),\n            a = \"source\" == t ? \"target\" : \"source\",\n            l = r.get(a) || {},\n            h = o.id,\n            u = l.id,\n            c = u && this.constructor.makeSelector(l);\n        if (i.handleBy === this.cid && h === u && s == c) this[t + \"View\"] = this[a + \"View\"], this[t + \"Magnet\"] = this[a + \"Magnet\"];else if (i.translateBy) ;else {\n          var d = this.paper.model.getCell(h);\n          if (!d) throw new Error(\"LinkView: invalid \" + t + \" cell.\");\n          var f = d.findView(this.paper);\n\n          if (f) {\n            var g = f.getMagnetFromLinkEnd(o);\n            g === f.el && (g = null), this[t + \"View\"] = f, this[t + \"Magnet\"] = g;\n          } else this[t + \"View\"] = this[t + \"Magnet\"] = null;\n        }\n\n        if (i.handleBy === this.cid && i.translateBy && r.isEmbeddedIn(e) && !joint.util.isEmpty(r.get(\"vertices\")) && (n = !1), !this.updatePostponed && u) {\n          var p = this.paper.getModelById(u);\n          o.id === l.id && (i.translateBy && !joint.util.isEmpty(r.get(\"vertices\")) && r.isEmbeddedIn(i.translateBy) ? n = !1 : i.handleBy = this.cid), n && (i.handleBy === this.cid || i.translateBy && p.isEmbeddedIn(i.translateBy)) && (n = !(this.updatePostponed = !0));\n        }\n      } else this[t + \"View\"] = this[t + \"Magnet\"] = null;\n\n      n && this.update(r, null, i);\n    },\n    _translateAndAutoOrientArrows: function _translateAndAutoOrientArrows(t, e) {\n      var i = joint.util.toArray(this.route);\n      t && t.translateAndAutoOrient(this.sourcePoint, i[0] || this.targetPoint, this.paper.viewport), e && e.translateAndAutoOrient(this.targetPoint, i[i.length - 1] || this.sourcePoint, this.paper.viewport);\n    },\n    _getDefaultLabelPositionArgs: function _getDefaultLabelPositionArgs() {\n      return (this.model._getDefaultLabel().position || {}).args;\n    },\n    _getLabelPositionArgs: function _getLabelPositionArgs(t) {\n      return (this.model.label(t).position || {}).args;\n    },\n    _mergeLabelPositionArgs: function _mergeLabelPositionArgs(t, e) {\n      return null === t ? null : void 0 === t ? null === e ? null : e : joint.util.merge({}, e, t);\n    },\n    addLabel: function addLabel(t, e, i) {\n      var n = \"number\" != typeof t,\n          r = n ? t.x : t,\n          o = n ? t.y : e,\n          s = n ? e : i,\n          a = this._getDefaultLabelPositionArgs(),\n          l = s,\n          h = this._mergeLabelPositionArgs(l, a),\n          u = {\n        position: this.getLabelPosition(r, o, h)\n      };\n\n      return this.model.insertLabel(-1, u, s), -1;\n    },\n    addVertex: function addVertex(t, e, i) {\n      var n = \"number\" != typeof t,\n          r = n ? t.x : t,\n          o = n ? t.y : e,\n          s = n ? e : i,\n          a = {\n        x: r,\n        y: o\n      },\n          l = this.getVertexIndex(r, o);\n      return this.model.insertVertex(l, a, s), l;\n    },\n    sendToken: function sendToken(t, e, i) {\n      var n, r, o;\n      o = joint.util.isObject(e) ? (n = e.duration, r = \"reverse\" === e.direction, e.connection) : (n = e, r = !1, null);\n      var s = {\n        dur: (n = n || 1e3) + \"ms\",\n        repeatCount: 1,\n        calcMode: \"linear\",\n        fill: \"freeze\"\n      };\n      r && (s.keyPoints = \"1;0\", s.keyTimes = \"0;1\");\n      var a,\n          l,\n          h,\n          u = V(t);\n      if (\"string\" == typeof o) a = this.findBySelector(o, this.el, this.selectors)[0];else {\n        var c = this._V;\n        a = c.connection ? c.connection.node : this.el.querySelector(\"path\");\n      }\n      if (!(a instanceof SVGPathElement)) throw new Error(\"dia.LinkView: token animation requires a valid connection path.\");\n      u.appendTo(this.paper.viewport).animateAlongPath(s, a), setTimeout((l = u, h = i, function () {\n        l.remove(), \"function\" == typeof h && h();\n      }), n);\n    },\n    findRoute: function findRoute(t) {\n      t || (t = []);\n      var e = joint.routers,\n          i = this.model.router(),\n          n = this.paper.options.defaultRouter;\n\n      if (!i) {\n        if (!n) return t.map(g.Point, g);\n        i = n;\n      }\n\n      var r = joint.util.isFunction(i) ? i : e[i.name];\n      if (!joint.util.isFunction(r)) throw new Error('dia.LinkView: unknown router: \"' + i.name + '\".');\n      var o = i.args || {},\n          s = r.call(this, t, o, this);\n      return s || t.map(g.Point, g);\n    },\n    findPath: function findPath(t, e, i) {\n      var n = joint.connectors,\n          r = this.model.connector(),\n          o = this.paper.options.defaultConnector;\n      r || (r = o || {});\n      var s = joint.util.isFunction(r) ? r : n[r.name];\n      if (!joint.util.isFunction(s)) throw new Error('dia.LinkView: unknown connector: \"' + r.name + '\".');\n      var a = joint.util.clone(r.args || {});\n      a.raw = !0;\n      var l = s.call(this, e, i, t, a, this);\n      return \"string\" == typeof l && (l = new g.Path(V.normalizePathData(l))), l;\n    },\n    getConnection: function getConnection() {\n      var t = this.path;\n      return t ? t.clone() : null;\n    },\n    getSerializedConnection: function getSerializedConnection() {\n      var t = this.path;\n      if (!t) return null;\n      var e = this.metrics;\n      if (e.hasOwnProperty(\"data\")) return e.data;\n      var i = t.serialize();\n      return e.data = i;\n    },\n    getConnectionSubdivisions: function getConnectionSubdivisions() {\n      var t = this.path;\n      if (!t) return null;\n      var e = this.metrics;\n      if (e.hasOwnProperty(\"segmentSubdivisions\")) return e.segmentSubdivisions;\n      var i = t.getSegmentSubdivisions();\n      return e.segmentSubdivisions = i;\n    },\n    getConnectionLength: function getConnectionLength() {\n      var t = this.path;\n      if (!t) return 0;\n      var e = this.metrics;\n      if (e.hasOwnProperty(\"length\")) return e.length;\n      var i = t.length({\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n      return e.length = i;\n    },\n    getPointAtLength: function getPointAtLength(t) {\n      var e = this.path;\n      return e ? e.pointAtLength(t, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      }) : null;\n    },\n    getPointAtRatio: function getPointAtRatio(t) {\n      var e = this.path;\n      return e ? e.pointAt(t, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      }) : null;\n    },\n    getTangentAtLength: function getTangentAtLength(t) {\n      var e = this.path;\n      return e ? e.tangentAtLength(t, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      }) : null;\n    },\n    getTangentAtRatio: function getTangentAtRatio(t) {\n      var e = this.path;\n      return e ? e.tangentAt(t, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      }) : null;\n    },\n    getClosestPoint: function getClosestPoint(t) {\n      var e = this.path;\n      return e ? e.closestPoint(t, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      }) : null;\n    },\n    getClosestPointLength: function getClosestPointLength(t) {\n      var e = this.path;\n      return e ? e.closestPointLength(t, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      }) : null;\n    },\n    getClosestPointRatio: function getClosestPointRatio(t) {\n      var e = this.path;\n      return e ? e.closestPointNormalizedLength(t, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      }) : null;\n    },\n    getLabelPosition: function getLabelPosition(t, e, i) {\n      var n = {},\n          r = i || {};\n      i && (n.args = i);\n      var o,\n          s,\n          a = !r.absoluteDistance,\n          l = r.absoluteDistance && r.reverseDistance,\n          h = r.absoluteOffset,\n          u = this.path,\n          c = {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      },\n          d = new g.Point(t, e),\n          f = u.closestPointT(d, c),\n          p = u.lengthAtT(f, c);\n      if (a && (p = p / this.getConnectionLength() || 0), l && (p = -1 * (this.getConnectionLength() - p) || 1), n.distance = p, h || (o = u.tangentAtT(f)), o) s = o.pointOffset(d);else {\n        var m = u.pointAtT(f),\n            v = d.difference(m);\n        s = {\n          x: v.x,\n          y: v.y\n        };\n      }\n      return n.offset = s, n;\n    },\n    getLabelCoordinates: function getLabelCoordinates(t) {\n      var e;\n      if (\"number\" == typeof t) e = t;else {\n        if (\"number\" != typeof t.distance) throw new Error(\"dia.LinkView: invalid label position distance.\");\n        e = t.distance;\n      }\n      var i = 0 < e && e <= 1,\n          n = 0,\n          r = {\n        x: 0,\n        y: 0\n      };\n\n      if (t.offset) {\n        var o = t.offset;\n        \"number\" == typeof o && (n = o), o.x && (r.x = o.x), o.y && (r.y = o.y);\n      }\n\n      var s,\n          a = 0 !== r.x || 0 !== r.y || 0 === n,\n          l = this.path,\n          h = {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      },\n          u = i ? e * this.getConnectionLength() : e;\n      if (a) (s = l.pointAtLength(u, h)).offset(r);else {\n        var c = l.tangentAtLength(u, h);\n        s = c ? (c.rotate(c.start, -90), c.setLength(n), c.end) : l.start;\n      }\n      return s;\n    },\n    getVertexIndex: function getVertexIndex(t, e) {\n      for (var i = this.model.vertices(), n = this.getClosestPointLength(new g.Point(t, e)), r = 0, o = i.length; r < o; r++) {\n        var s = i[r];\n        if (n < this.getClosestPointLength(s)) break;\n      }\n\n      return r;\n    },\n    pointerdblclick: function pointerdblclick(t, e, i) {\n      joint.dia.CellView.prototype.pointerdblclick.apply(this, arguments), this.notify(\"link:pointerdblclick\", t, e, i);\n    },\n    pointerclick: function pointerclick(t, e, i) {\n      joint.dia.CellView.prototype.pointerclick.apply(this, arguments), this.notify(\"link:pointerclick\", t, e, i);\n    },\n    contextmenu: function contextmenu(t, e, i) {\n      joint.dia.CellView.prototype.contextmenu.apply(this, arguments), this.notify(\"link:contextmenu\", t, e, i);\n    },\n    pointerdown: function pointerdown(t, e, i) {\n      switch (joint.dia.CellView.prototype.pointerdown.apply(this, arguments), this.notify(\"link:pointerdown\", t, e, i), t.target.getAttribute(\"class\")) {\n        case \"marker-vertex\":\n          return void this.dragVertexStart(t, e, i);\n\n        case \"marker-vertex-remove\":\n        case \"marker-vertex-remove-area\":\n          return void this.dragVertexRemoveStart(t, e, i);\n\n        case \"marker-arrowhead\":\n          return void this.dragArrowheadStart(t, e, i);\n\n        case \"connection\":\n        case \"connection-wrap\":\n          return void this.dragConnectionStart(t, e, i);\n\n        case \"marker-source\":\n        case \"marker-target\":\n          return;\n      }\n\n      this.dragStart(t, e, i);\n    },\n    pointermove: function pointermove(t, e, i) {\n      var n = this._dragData;\n\n      switch (n && this.eventData(t, n), this.eventData(t).action) {\n        case \"vertex-move\":\n          this.dragVertex(t, e, i);\n          break;\n\n        case \"label-move\":\n          this.dragLabel(t, e, i);\n          break;\n\n        case \"arrowhead-move\":\n          this.dragArrowhead(t, e, i);\n          break;\n\n        case \"move\":\n          this.drag(t, e, i);\n      }\n\n      n && joint.util.assign(n, this.eventData(t)), joint.dia.CellView.prototype.pointermove.apply(this, arguments), this.notify(\"link:pointermove\", t, e, i);\n    },\n    pointerup: function pointerup(t, e, i) {\n      var n = this._dragData;\n\n      switch (n && (this.eventData(t, n), this._dragData = null), this.eventData(t).action) {\n        case \"vertex-move\":\n          this.dragVertexEnd(t, e, i);\n          break;\n\n        case \"label-move\":\n          this.dragLabelEnd(t, e, i);\n          break;\n\n        case \"arrowhead-move\":\n          this.dragArrowheadEnd(t, e, i);\n          break;\n\n        case \"move\":\n          this.dragEnd(t, e, i);\n      }\n\n      this.notify(\"link:pointerup\", t, e, i), joint.dia.CellView.prototype.pointerup.apply(this, arguments);\n    },\n    mouseover: function mouseover(t) {\n      joint.dia.CellView.prototype.mouseover.apply(this, arguments), this.notify(\"link:mouseover\", t);\n    },\n    mouseout: function mouseout(t) {\n      joint.dia.CellView.prototype.mouseout.apply(this, arguments), this.notify(\"link:mouseout\", t);\n    },\n    mouseenter: function mouseenter(t) {\n      joint.dia.CellView.prototype.mouseenter.apply(this, arguments), this.notify(\"link:mouseenter\", t);\n    },\n    mouseleave: function mouseleave(t) {\n      joint.dia.CellView.prototype.mouseleave.apply(this, arguments), this.notify(\"link:mouseleave\", t);\n    },\n    mousewheel: function mousewheel(t, e, i, n) {\n      joint.dia.CellView.prototype.mousewheel.apply(this, arguments), this.notify(\"link:mousewheel\", t, e, i, n);\n    },\n    onevent: function onevent(t, e, i, n) {\n      if (V(t.target).findParentByClass(\"link-tool\", this.el)) {\n        if (t.stopPropagation(), this.can(\"useLinkTools\")) {\n          if (\"remove\" === e) return void this.model.remove({\n            ui: !0\n          });\n          this.notify(e, t, i, n);\n        }\n\n        joint.dia.CellView.prototype.pointerdown.apply(this, arguments), this.notify(\"link:pointerdown\", t, i, n);\n      } else joint.dia.CellView.prototype.onevent.apply(this, arguments);\n    },\n    onlabel: function onlabel(t, e, i) {\n      joint.dia.CellView.prototype.pointerdown.apply(this, arguments), this.notify(\"link:pointerdown\", t, e, i), this.dragLabelStart(t, e, i), this.eventData(t).stopPropagation && t.stopPropagation();\n    },\n    dragConnectionStart: function dragConnectionStart(t, e, i) {\n      if (this.can(\"vertexAdd\")) {\n        var n = this.addVertex({\n          x: e,\n          y: i\n        }, {\n          ui: !0\n        });\n        this.eventData(t, {\n          action: \"vertex-move\",\n          vertexIdx: n\n        });\n      }\n    },\n    dragLabelStart: function dragLabelStart(t, e, i) {\n      if (this.can(\"labelMove\")) {\n        var n = t.currentTarget,\n            r = parseInt(n.getAttribute(\"label-idx\"), 10),\n            o = this._getDefaultLabelPositionArgs(),\n            s = this._getLabelPositionArgs(r),\n            a = this._mergeLabelPositionArgs(s, o);\n\n        this.eventData(t, {\n          action: \"label-move\",\n          labelIdx: r,\n          positionArgs: a,\n          stopPropagation: !0\n        }), this.paper.delegateDragEvents(this, t.data);\n      } else this.eventData(t, {\n        stopPropagation: !0\n      });\n    },\n    dragVertexStart: function dragVertexStart(t, e, i) {\n      if (this.can(\"vertexMove\")) {\n        var n = t.target,\n            r = parseInt(n.getAttribute(\"idx\"), 10);\n        this.eventData(t, {\n          action: \"vertex-move\",\n          vertexIdx: r\n        });\n      }\n    },\n    dragVertexRemoveStart: function dragVertexRemoveStart(t, e, i) {\n      if (this.can(\"vertexRemove\")) {\n        var n = t.target,\n            r = parseInt(n.getAttribute(\"idx\"), 10);\n        this.model.removeVertex(r);\n      }\n    },\n    dragArrowheadStart: function dragArrowheadStart(t, e, i) {\n      if (this.can(\"arrowheadMove\")) {\n        var n = t.target.getAttribute(\"end\"),\n            r = this.startArrowheadMove(n, {\n          ignoreBackwardsCompatibility: !0\n        });\n        this.eventData(t, r);\n      }\n    },\n    dragStart: function dragStart(t, e, i) {\n      this.can(\"linkMove\") && this.eventData(t, {\n        action: \"move\",\n        dx: e,\n        dy: i\n      });\n    },\n    dragLabel: function dragLabel(t, e, i) {\n      var n = this.eventData(t),\n          r = {\n        position: this.getLabelPosition(e, i, n.positionArgs)\n      };\n      this.model.label(n.labelIdx, r);\n    },\n    dragVertex: function dragVertex(t, e, i) {\n      var n = this.eventData(t);\n      this.model.vertex(n.vertexIdx, {\n        x: e,\n        y: i\n      }, {\n        ui: !0\n      });\n    },\n    dragArrowhead: function dragArrowhead(t, e, i) {\n      var n = this.eventData(t);\n      this.paper.options.snapLinks ? this._snapArrowhead(e, i, n) : this._connectArrowhead(this.getEventTarget(t), e, i, n);\n    },\n    drag: function drag(t, e, i) {\n      var n = this.eventData(t);\n      this.model.translate(e - n.dx, i - n.dy, {\n        ui: !0\n      }), this.eventData(t, {\n        dx: e,\n        dy: i\n      });\n    },\n    dragLabelEnd: function dragLabelEnd() {},\n    dragVertexEnd: function dragVertexEnd() {},\n    dragArrowheadEnd: function dragArrowheadEnd(t, e, i) {\n      var n = this.eventData(t),\n          r = this.paper;\n      r.options.snapLinks ? this._snapArrowheadEnd(n) : this._connectArrowheadEnd(n, e, i), r.linkAllowed(this) ? (this._finishEmbedding(n), this._notifyConnectEvent(n, t)) : this._disallow(n), this._afterArrowheadMove(n), this.vel.contains(t.target) || this.mouseleave(t);\n    },\n    dragEnd: function dragEnd() {},\n    _disallow: function _disallow(t) {\n      switch (t.whenNotAllowed) {\n        case \"remove\":\n          this.model.remove({\n            ui: !0\n          });\n          break;\n\n        case \"revert\":\n        default:\n          this.model.set(t.arrowhead, t.initialEnd, {\n            ui: !0\n          });\n      }\n    },\n    _finishEmbedding: function _finishEmbedding(t) {\n      this.paper.options.embeddingMode && this.model.reparent() && (t.z = null);\n    },\n    _notifyConnectEvent: function _notifyConnectEvent(t, e) {\n      var i = t.arrowhead,\n          n = t.initialEnd,\n          r = this.model.prop(i);\n\n      if (r && !joint.dia.Link.endsEqual(n, r)) {\n        var o = this.paper;\n        n.id && this.notify(\"link:disconnect\", e, o.findViewByModel(n.id), t.initialMagnet, i), r.id && this.notify(\"link:connect\", e, o.findViewByModel(r.id), t.magnetUnderPointer, i);\n      }\n    },\n    _snapArrowhead: function _snapArrowhead(t, e, r) {\n      var o,\n          s = this.paper.options.snapLinks.radius || 50,\n          i = this.paper.findViewsInArea({\n        x: t - s,\n        y: e - s,\n        width: 2 * s,\n        height: 2 * s\n      }),\n          n = r.closestView || null,\n          a = r.closestMagnet || null;\n      r.closestView = r.closestMagnet = null;\n      var l,\n          h = Number.MAX_VALUE,\n          u = g.point(t, e),\n          c = this.paper;\n      i.forEach(function (n) {\n        \"false\" !== n.el.getAttribute(\"magnet\") && (o = n.model.getBBox().center().distance(u)) < s && o < h && (a === n.el || c.options.validateConnection.apply(c, r.validateConnectionArgs(n, null))) && (h = o, r.closestView = n, r.closestMagnet = n.el), n.$(\"[magnet]\").each(function (t, e) {\n          var i = n.getNodeBBox(e);\n          (o = u.distance({\n            x: i.x + i.width / 2,\n            y: i.y + i.height / 2\n          })) < s && o < h && (a === e || c.options.validateConnection.apply(c, r.validateConnectionArgs(n, e))) && (h = o, r.closestView = n, r.closestMagnet = e);\n        }.bind(this));\n      }, this);\n      var d = r.closestView,\n          f = r.closestMagnet,\n          p = r.arrowhead,\n          m = a !== f;\n\n      if (n && m && n.unhighlight(a, {\n        connecting: !0,\n        snapping: !0\n      }), d) {\n        if (!m) return;\n        d.highlight(f, {\n          connecting: !0,\n          snapping: !0\n        }), l = d.getLinkEnd(f, t, e, this.model, p);\n      } else l = {\n        x: t,\n        y: e\n      };\n\n      this.model.set(p, l || {\n        x: t,\n        y: e\n      }, {\n        ui: !0\n      });\n    },\n    _snapArrowheadEnd: function _snapArrowheadEnd(t) {\n      var e = t.closestView,\n          i = t.closestMagnet;\n      e && i && (e.unhighlight(i, {\n        connecting: !0,\n        snapping: !0\n      }), t.magnetUnderPointer = e.findMagnet(i)), t.closestView = t.closestMagnet = null;\n    },\n    _connectArrowhead: function _connectArrowhead(t, e, i, n) {\n      n.eventTarget !== t && (n.magnetUnderPointer && n.viewUnderPointer.unhighlight(n.magnetUnderPointer, {\n        connecting: !0\n      }), n.viewUnderPointer = this.paper.findView(t), n.viewUnderPointer ? (n.magnetUnderPointer = n.viewUnderPointer.findMagnet(t), n.magnetUnderPointer && this.paper.options.validateConnection.apply(this.paper, n.validateConnectionArgs(n.viewUnderPointer, n.magnetUnderPointer)) ? n.magnetUnderPointer && n.viewUnderPointer.highlight(n.magnetUnderPointer, {\n        connecting: !0\n      }) : n.magnetUnderPointer = null) : n.magnetUnderPointer = null), n.eventTarget = t, this.model.set(n.arrowhead, {\n        x: e,\n        y: i\n      }, {\n        ui: !0\n      });\n    },\n    _connectArrowheadEnd: function _connectArrowheadEnd(t, e, i) {\n      var n = t.viewUnderPointer,\n          r = t.magnetUnderPointer;\n\n      if (r && n) {\n        n.unhighlight(r, {\n          connecting: !0\n        });\n        var o = t.arrowhead,\n            s = n.getLinkEnd(r, e, i, this.model, o);\n        this.model.set(o, s, {\n          ui: !0\n        });\n      }\n    },\n    _beforeArrowheadMove: function _beforeArrowheadMove(t) {\n      t.z = this.model.get(\"z\"), this.model.toFront(), this.el.style.pointerEvents = \"none\", this.paper.options.markAvailable && this._markAvailableMagnets(t);\n    },\n    _afterArrowheadMove: function _afterArrowheadMove(t) {\n      null !== t.z && (this.model.set(\"z\", t.z, {\n        ui: !0\n      }), t.z = null), this.el.style.pointerEvents = \"visiblePainted\", this.paper.options.markAvailable && this._unmarkAvailableMagnets(t);\n    },\n    _createValidateConnectionArgs: function _createValidateConnectionArgs(t) {\n      var e,\n          i = [];\n      i[4] = t, i[5] = this;\n      var n = 0,\n          r = 0;\n      e = \"source\" === t ? (n = 2, \"target\") : (r = 2, \"source\");\n      var o = this.model.get(e);\n\n      if (o.id) {\n        var s = i[n] = this.paper.findViewByModel(o.id),\n            a = s.getMagnetFromLinkEnd(o);\n        a === s.el && (a = void 0), i[n + 1] = a;\n      }\n\n      return function (t, e) {\n        return i[r] = t, i[r + 1] = t.el === e ? void 0 : e, i;\n      };\n    },\n    _markAvailableMagnets: function _markAvailableMagnets(t) {\n      function e(t, e) {\n        var i = t.paper;\n        return i.options.validateConnection.apply(i, this.validateConnectionArgs(t, e));\n      }\n\n      var i = this.paper,\n          n = i.model.getElements();\n      t.marked = {};\n\n      for (var r = 0, o = n.length; r < o; r++) {\n        var s = n[r].findView(i);\n\n        if (s) {\n          var a = Array.prototype.slice.call(s.el.querySelectorAll(\"[magnet]\"));\n          \"false\" !== s.el.getAttribute(\"magnet\") && a.push(s.el);\n          var l = a.filter(e.bind(t, s));\n\n          if (0 < l.length) {\n            for (var h = 0, u = l.length; h < u; h++) {\n              s.highlight(l[h], {\n                magnetAvailability: !0\n              });\n            }\n\n            s.highlight(null, {\n              elementAvailability: !0\n            }), t.marked[s.model.id] = l;\n          }\n        }\n      }\n    },\n    _unmarkAvailableMagnets: function _unmarkAvailableMagnets(t) {\n      for (var e, i, n = Object.keys(t.marked), r = 0, o = n.length; r < o; r++) {\n        e = n[r], i = t.marked[e];\n        var s = this.paper.findViewByModel(e);\n\n        if (s) {\n          for (var a = 0, l = i.length; a < l; a++) {\n            s.unhighlight(i[a], {\n              magnetAvailability: !0\n            });\n          }\n\n          s.unhighlight(null, {\n            elementAvailability: !0\n          });\n        }\n      }\n\n      t.marked = null;\n    },\n    startArrowheadMove: function startArrowheadMove(t, e) {\n      e || (e = {});\n      var i = {\n        action: \"arrowhead-move\",\n        arrowhead: t,\n        whenNotAllowed: e.whenNotAllowed || \"revert\",\n        initialMagnet: this[t + \"Magnet\"] || (this[t + \"View\"] ? this[t + \"View\"].el : null),\n        initialEnd: joint.util.clone(this.model.get(t)),\n        validateConnectionArgs: this._createValidateConnectionArgs(t)\n      };\n      return this._beforeArrowheadMove(i), !0 !== e.ignoreBackwardsCompatibility && (this._dragData = i), i;\n    }\n  }, {\n    makeSelector: function makeSelector(t) {\n      var e = \"\";\n      return t.port ? e += '[port=\"' + t.port + '\"]' : t.selector && (e += t.selector), e;\n    }\n  }), Object.defineProperty(joint.dia.LinkView.prototype, \"sourceBBox\", {\n    enumerable: !0,\n    get: function get() {\n      var t = this.sourceView,\n          e = this.sourceMagnet;\n      if (t) return e || (e = t.el), t.getNodeBBox(e);\n      var i = this.model.source();\n      return new g.Rect(i.x, i.y, 1, 1);\n    }\n  }), Object.defineProperty(joint.dia.LinkView.prototype, \"targetBBox\", {\n    enumerable: !0,\n    get: function get() {\n      var t = this.targetView,\n          e = this.targetMagnet;\n      if (t) return e || (e = t.el), t.getNodeBBox(e);\n      var i = this.model.target();\n      return new g.Rect(i.x, i.y, 1, 1);\n    }\n  }), joint.dia.Paper = joint.mvc.View.extend({\n    className: \"paper\",\n    options: {\n      width: 800,\n      height: 600,\n      origin: {\n        x: 0,\n        y: 0\n      },\n      gridSize: 1,\n      drawGrid: !1,\n      background: !1,\n      perpendicularLinks: !1,\n      elementView: joint.dia.ElementView,\n      linkView: joint.dia.LinkView,\n      snapLinks: !1,\n      multiLinks: !0,\n      guard: function guard(t, e) {\n        return !1;\n      },\n      highlighting: {\n        default: {\n          name: \"stroke\",\n          options: {\n            padding: 3\n          }\n        },\n        magnetAvailability: {\n          name: \"addClass\",\n          options: {\n            className: \"available-magnet\"\n          }\n        },\n        elementAvailability: {\n          name: \"addClass\",\n          options: {\n            className: \"available-cell\"\n          }\n        }\n      },\n      preventContextMenu: !0,\n      preventDefaultBlankAction: !0,\n      restrictTranslate: !1,\n      markAvailable: !1,\n      defaultLink: new joint.dia.Link(),\n      defaultConnector: {\n        name: \"normal\"\n      },\n      defaultRouter: {\n        name: \"normal\"\n      },\n      defaultAnchor: {\n        name: \"center\"\n      },\n      defaultConnectionPoint: {\n        name: \"bbox\"\n      },\n      connectionStrategy: null,\n      validateMagnet: function validateMagnet(t, e) {\n        return \"passive\" !== e.getAttribute(\"magnet\");\n      },\n      validateConnection: function validateConnection(t, e, i, n, r, o) {\n        return (\"target\" === r ? i : t) instanceof joint.dia.ElementView;\n      },\n      embeddingMode: !1,\n      validateEmbedding: function validateEmbedding(t, e) {\n        return !0;\n      },\n      findParentBy: \"bbox\",\n      frontParentOnly: !0,\n      interactive: {\n        labelMove: !1\n      },\n      linkPinning: !0,\n      allowLink: null,\n      clickThreshold: 0,\n      moveThreshold: 0,\n      magnetThreshold: 0,\n      cellViewNamespace: joint.shapes,\n      highlighterNamespace: joint.highlighters\n    },\n    events: {\n      dblclick: \"pointerdblclick\",\n      contextmenu: \"contextmenu\",\n      mousedown: \"pointerdown\",\n      touchstart: \"pointerdown\",\n      mouseover: \"mouseover\",\n      mouseout: \"mouseout\",\n      mouseenter: \"mouseenter\",\n      mouseleave: \"mouseleave\",\n      mousewheel: \"mousewheel\",\n      DOMMouseScroll: \"mousewheel\",\n      \"mouseenter .joint-cell\": \"mouseenter\",\n      \"mouseleave .joint-cell\": \"mouseleave\",\n      \"mouseenter .joint-tools\": \"mouseenter\",\n      \"mouseleave .joint-tools\": \"mouseleave\",\n      \"mousedown .joint-cell [event]\": \"onevent\",\n      \"touchstart .joint-cell [event]\": \"onevent\",\n      \"mousedown .joint-cell [magnet]\": \"onmagnet\",\n      \"touchstart .joint-cell [magnet]\": \"onmagnet\",\n      \"dblclick .joint-cell [magnet]\": \"magnetpointerdblclick\",\n      \"contextmenu .joint-cell [magnet]\": \"magnetcontextmenu\",\n      \"mousedown .joint-link .label\": \"onlabel\",\n      \"touchstart .joint-link .label\": \"onlabel\",\n      \"dragstart .joint-cell image\": \"onImageDragStart\"\n    },\n    documentEvents: {\n      mousemove: \"pointermove\",\n      touchmove: \"pointermove\",\n      mouseup: \"pointerup\",\n      touchend: \"pointerup\",\n      touchcancel: \"pointerup\"\n    },\n    _highlights: {},\n    init: function init() {\n      joint.util.bindAll(this, \"pointerup\");\n      var t = this.model = this.options.model || new joint.dia.Graph();\n      this.setGrid(this.options.drawGrid), this.cloneOptions(), this.render(), this.setDimensions(), this.listenTo(t, \"add\", this.onCellAdded).listenTo(t, \"remove\", this.removeView).listenTo(t, \"reset\", this.resetViews).listenTo(t, \"sort\", this._onSort).listenTo(t, \"batch:stop\", this._onBatchStop), this.on(\"cell:highlight\", this.onCellHighlight).on(\"cell:unhighlight\", this.onCellUnhighlight).on(\"scale translate\", this.update), this._views = {}, this.$document = $(this.el.ownerDocument);\n    },\n    cloneOptions: function cloneOptions() {\n      var t = this.options;\n      t.origin = joint.util.assign({}, t.origin), t.defaultConnector = joint.util.assign({}, t.defaultConnector), t.highlighting = joint.util.defaultsDeep({}, t.highlighting, this.constructor.prototype.options.highlighting);\n    },\n    render: function render() {\n      return this.$el.empty(), this.svg = V(\"svg\").attr({\n        width: \"100%\",\n        height: \"100%\"\n      }).node, this.viewport = V(\"g\").addClass(joint.util.addClassNamePrefix(\"viewport\")).node, this.defs = V(\"defs\").node, this.tools = V(\"g\").addClass(joint.util.addClassNamePrefix(\"tools-container\")).node, V(this.svg).append([this.defs, this.viewport, this.tools]), this.$background = $(\"<div/>\").addClass(joint.util.addClassNamePrefix(\"paper-background\")), this.options.background && this.drawBackground(this.options.background), this.$grid = $(\"<div/>\").addClass(joint.util.addClassNamePrefix(\"paper-grid\")), this.options.drawGrid && this.drawGrid(), this.$el.append(this.$background, this.$grid, this.svg), this;\n    },\n    update: function update() {\n      return this.options.drawGrid && this.drawGrid(), this._background && this.updateBackgroundImage(this._background), this;\n    },\n    _viewportMatrix: null,\n    _viewportTransformString: null,\n    matrix: function matrix(t) {\n      var e = this.viewport;\n\n      if (void 0 === t) {\n        var i = e.getAttribute(\"transform\");\n        return (this._viewportTransformString || null) === i ? t = this._viewportMatrix : (t = e.getCTM(), this._viewportMatrix = t, this._viewportTransformString = i), V.createSVGMatrix(t);\n      }\n\n      t = V.createSVGMatrix(t);\n      var n = V.matrixToTransformString(t);\n      return e.setAttribute(\"transform\", n), this.tools.setAttribute(\"transform\", n), this._viewportMatrix = t, this._viewportTransformString = e.getAttribute(\"transform\"), this;\n    },\n    clientMatrix: function clientMatrix() {\n      return V.createSVGMatrix(this.viewport.getScreenCTM());\n    },\n    _sortDelayingBatches: [\"add\", \"to-front\", \"to-back\"],\n    _onSort: function _onSort() {\n      this.model.hasActiveBatch(this._sortDelayingBatches) || this.sortViews();\n    },\n    _onBatchStop: function _onBatchStop(t) {\n      var e = t && t.batchName;\n      this._sortDelayingBatches.includes(e) && !this.model.hasActiveBatch(this._sortDelayingBatches) && this.sortViews();\n    },\n    onRemove: function onRemove() {\n      this.removeViews();\n    },\n    getComputedSize: function getComputedSize() {\n      var t = joint.util,\n          e = this.options,\n          i = e.width,\n          n = e.height;\n      return t.isNumber(i) || (i = this.el.clientWidth), t.isNumber(n) || (n = this.el.clientHeight), {\n        width: i,\n        height: n\n      };\n    },\n    setDimensions: function setDimensions(t, e) {\n      var i = joint.util,\n          n = this.options,\n          r = void 0 === t ? n.width : t,\n          o = void 0 === e ? n.height : e;\n      this.options.width = r, this.options.height = o, i.isNumber(r) && (r = Math.round(r)), i.isNumber(o) && (o = Math.round(o)), this.$el.css({\n        width: null === r ? \"\" : r,\n        height: null === o ? \"\" : o\n      });\n      var s = this.getComputedSize();\n      this.trigger(\"resize\", s.width, s.height);\n    },\n    setOrigin: function setOrigin(t, e) {\n      return this.translate(t || 0, e || 0, {\n        absolute: !0\n      });\n    },\n    fitToContent: function fitToContent(t, e, i, n) {\n      i = joint.util.isObject(t) ? (t = (n = t).gridWidth || 1, e = n.gridHeight || 1, n.padding || 0) : (n = n || {}, t = t || 1, e = e || 1, i || 0), i = joint.util.normalizeSides(i);\n      var r = V(this.viewport).getBBox(),\n          o = this.scale(),\n          s = this.translate();\n      r.x *= o.sx, r.y *= o.sy, r.width *= o.sx, r.height *= o.sy;\n      var a = Math.max(Math.ceil((r.width + r.x) / t), 1) * t,\n          l = Math.max(Math.ceil((r.height + r.y) / e), 1) * e,\n          h = 0,\n          u = 0;\n      (\"negative\" == n.allowNewOrigin && r.x < 0 || \"positive\" == n.allowNewOrigin && 0 <= r.x || \"any\" == n.allowNewOrigin) && (h = Math.ceil(-r.x / t) * t, a += h += i.left), (\"negative\" == n.allowNewOrigin && r.y < 0 || \"positive\" == n.allowNewOrigin && 0 <= r.y || \"any\" == n.allowNewOrigin) && (u = Math.ceil(-r.y / e) * e, l += u += i.top), a += i.right, l += i.bottom, a = Math.max(a, n.minWidth || 0), l = Math.max(l, n.minHeight || 0), a = Math.min(a, n.maxWidth || Number.MAX_VALUE), l = Math.min(l, n.maxHeight || Number.MAX_VALUE);\n      var c = this.getComputedSize(),\n          d = a != c.width || l != c.height;\n      (h != s.tx || u != s.ty) && this.translate(h, u), d && this.setDimensions(a, l);\n    },\n    scaleContentToFit: function scaleContentToFit(t) {\n      var e = this.getContentBBox();\n\n      if (e.width && e.height) {\n        t = t || {}, joint.util.defaults(t, {\n          padding: 0,\n          preserveAspectRatio: !0,\n          scaleGrid: null,\n          minScale: 0,\n          maxScale: Number.MAX_VALUE\n        });\n        var i,\n            n = t.padding,\n            r = t.minScaleX || t.minScale,\n            o = t.maxScaleX || t.maxScale,\n            s = t.minScaleY || t.minScale,\n            a = t.maxScaleY || t.maxScale;\n        if (t.fittingBBox) i = t.fittingBBox;else {\n          var l = this.translate(),\n              h = this.getComputedSize();\n          i = {\n            x: l.tx,\n            y: l.ty,\n            width: h.width,\n            height: h.height\n          };\n        }\n        i = new g.Rect(i).inflate(-n);\n        var u = this.scale(),\n            c = i.width / e.width * u.sx,\n            d = i.height / e.height * u.sy;\n\n        if (t.preserveAspectRatio && (c = d = Math.min(c, d)), t.scaleGrid) {\n          var f = t.scaleGrid;\n          c = f * Math.floor(c / f), d = f * Math.floor(d / f);\n        }\n\n        c = Math.min(o, Math.max(r, c)), d = Math.min(a, Math.max(s, d)), this.scale(c, d);\n        var p = this.getContentBBox(),\n            m = i.x - p.x,\n            v = i.y - p.y;\n        this.translate(m, v);\n      }\n    },\n    getContentArea: function getContentArea() {\n      return V(this.viewport).getBBox();\n    },\n    getContentBBox: function getContentBBox() {\n      var t = this.viewport.getBoundingClientRect(),\n          e = this.clientMatrix(),\n          i = this.translate();\n      return new g.Rect({\n        x: t.left - e.e + i.tx,\n        y: t.top - e.f + i.ty,\n        width: t.width,\n        height: t.height\n      });\n    },\n    getArea: function getArea() {\n      return this.paperToLocalRect(this.getComputedSize());\n    },\n    getRestrictedArea: function getRestrictedArea() {\n      return joint.util.isFunction(this.options.restrictTranslate) ? this.options.restrictTranslate.apply(this, arguments) : !0 === this.options.restrictTranslate ? this.getArea() : this.options.restrictTranslate || null;\n    },\n    createViewForModel: function createViewForModel(t) {\n      var e,\n          i,\n          n = this.options.cellViewNamespace,\n          r = t.get(\"type\") + \"View\",\n          o = joint.util.getByPath(n, r, \".\");\n      return i = t.isLink() ? (e = this.options.linkView, joint.dia.LinkView) : (e = this.options.elementView, joint.dia.ElementView), new (e.prototype instanceof Backbone.View ? o || e : e.call(this, t) || o || i)({\n        model: t,\n        interactive: this.options.interactive\n      });\n    },\n    onCellAdded: function onCellAdded(t, e, i) {\n      if (this.options.async && !1 !== i.async && joint.util.isNumber(i.position)) {\n        if (this._asyncCells = this._asyncCells || [], this._asyncCells.push(t), 0 == i.position) {\n          if (this._frameId) throw new Error(\"another asynchronous rendering in progress\");\n          this.asyncRenderViews(this._asyncCells, i), delete this._asyncCells;\n        }\n      } else this.renderView(t);\n    },\n    removeView: function removeView(t) {\n      var e = this._views[t.id];\n      return e && (e.remove(), delete this._views[t.id]), e;\n    },\n    renderView: function renderView(t) {\n      var e = this._views[t.id] = this.createViewForModel(t);\n      return this.viewport.appendChild(e.el), e.paper = this, e.render(), e;\n    },\n    onImageDragStart: function onImageDragStart() {\n      return !1;\n    },\n    beforeRenderViews: function beforeRenderViews(t) {\n      return t.sort(function (t) {\n        return t.isLink() ? 1 : -1;\n      }), t;\n    },\n    afterRenderViews: function afterRenderViews() {\n      this.sortViews();\n    },\n    resetViews: function resetViews(t, e) {\n      this.removeViews();\n      var i = t.models.slice();\n      if (i = this.beforeRenderViews(i, e) || i, this.cancelRenderViews(), this.options.async) this.asyncRenderViews(i, e);else {\n        for (var n = 0, r = i.length; n < r; n++) {\n          this.renderView(i[n]);\n        }\n\n        this.sortViews();\n      }\n    },\n    cancelRenderViews: function cancelRenderViews() {\n      this._frameId && (joint.util.cancelFrame(this._frameId), delete this._frameId);\n    },\n    removeViews: function removeViews() {\n      joint.util.invoke(this._views, \"remove\"), this._views = {};\n    },\n    asyncBatchAdded: joint.util.noop,\n    asyncRenderViews: function asyncRenderViews(t, e) {\n      if (this._frameId) {\n        var i = this.options.async && this.options.async.batchSize || 50;\n        t.splice(0, i).forEach(function (t) {\n          t.graph === this.model && this.renderView(t);\n        }, this), this.asyncBatchAdded();\n      }\n\n      t.length ? this._frameId = joint.util.nextFrame(function () {\n        this.asyncRenderViews(t, e);\n      }, this) : (delete this._frameId, this.afterRenderViews(e), this.trigger(\"render:done\", e));\n    },\n    sortViews: function sortViews() {\n      var t = $(this.viewport).children(\"[model-id]\"),\n          r = this.model.get(\"cells\");\n      joint.util.sortElements(t, function (t, e) {\n        var i = r.get($(t).attr(\"model-id\")),\n            n = r.get($(e).attr(\"model-id\"));\n        return (i.get(\"z\") || 0) > (n.get(\"z\") || 0) ? 1 : -1;\n      });\n    },\n    MIN_SCALE: 1e-6,\n    scale: function scale(t, e, i, n) {\n      if (void 0 === t) return V.matrixToScale(this.matrix());\n      void 0 === e && (e = t), void 0 === i && (n = i = 0);\n      var r = this.translate();\n\n      if (i || n || r.tx || r.ty) {\n        var o = r.tx - i * (t - 1),\n            s = r.ty - n * (e - 1);\n        this.translate(o, s);\n      }\n\n      t = Math.max(t || 0, this.MIN_SCALE), e = Math.max(e || 0, this.MIN_SCALE);\n      var a = this.matrix();\n      return a.a = t, a.d = e, this.matrix(a), this.trigger(\"scale\", t, e, i, n), this;\n    },\n    rotate: function rotate(t, e, i) {\n      if (void 0 === t) return V.matrixToRotate(this.matrix());\n\n      if (void 0 === e) {\n        var n = this.viewport.getBBox();\n        e = n.width / 2, i = n.height / 2;\n      }\n\n      var r = this.matrix().translate(e, i).rotate(t).translate(-e, -i);\n      return this.matrix(r), this;\n    },\n    translate: function translate(t, e) {\n      if (void 0 === t) return V.matrixToTranslate(this.matrix());\n      var i = this.matrix();\n      i.e = t || 0, i.f = e || 0, this.matrix(i);\n      var n = this.translate(),\n          r = this.options.origin;\n      return r.x = n.tx, r.y = n.ty, this.trigger(\"translate\", n.tx, n.ty), this.options.drawGrid && this.drawGrid(), this;\n    },\n    findView: function findView(t) {\n      var e = joint.util.isString(t) ? this.viewport.querySelector(t) : t instanceof $ ? t[0] : t,\n          i = this.findAttribute(\"model-id\", e);\n      if (i) return this._views[i];\n    },\n    findViewByModel: function findViewByModel(t) {\n      var e = joint.util.isString(t) || joint.util.isNumber(t) ? t : t && t.id;\n      return this._views[e];\n    },\n    findViewsFromPoint: function findViewsFromPoint(e) {\n      return e = new g.Point(e), this.model.getElements().map(this.findViewByModel, this).filter(function (t) {\n        return t && t.vel.getBBox({\n          target: this.viewport\n        }).containsPoint(e);\n      }, this);\n    },\n    findViewsInArea: function findViewsInArea(e, t) {\n      t = joint.util.defaults(t || {}, {\n        strict: !1\n      }), e = new g.Rect(e);\n      var i = this.model.getElements().map(this.findViewByModel, this),\n          n = t.strict ? \"containsRect\" : \"intersect\";\n      return i.filter(function (t) {\n        return t && e[n](t.vel.getBBox({\n          target: this.viewport\n        }));\n      }, this);\n    },\n    removeTools: function removeTools() {\n      return joint.dia.CellView.dispatchToolsEvent(this, \"remove\"), this;\n    },\n    hideTools: function hideTools() {\n      return joint.dia.CellView.dispatchToolsEvent(this, \"hide\"), this;\n    },\n    showTools: function showTools() {\n      return joint.dia.CellView.dispatchToolsEvent(this, \"show\"), this;\n    },\n    getModelById: function getModelById(t) {\n      return this.model.getCell(t);\n    },\n    snapToGrid: function snapToGrid(t, e) {\n      return this.clientToLocalPoint(t, e).snapToGrid(this.options.gridSize);\n    },\n    localToPaperPoint: function localToPaperPoint(t, e) {\n      var i = new g.Point(t, e);\n      return V.transformPoint(i, this.matrix());\n    },\n    localToPaperRect: function localToPaperRect(t, e, i, n) {\n      var r = new g.Rect(t, e, i, n);\n      return V.transformRect(r, this.matrix());\n    },\n    paperToLocalPoint: function paperToLocalPoint(t, e) {\n      var i = new g.Point(t, e);\n      return V.transformPoint(i, this.matrix().inverse());\n    },\n    paperToLocalRect: function paperToLocalRect(t, e, i, n) {\n      var r = new g.Rect(t, e, i, n);\n      return V.transformRect(r, this.matrix().inverse());\n    },\n    localToClientPoint: function localToClientPoint(t, e) {\n      var i = new g.Point(t, e);\n      return V.transformPoint(i, this.clientMatrix());\n    },\n    localToClientRect: function localToClientRect(t, e, i, n) {\n      var r = new g.Rect(t, e, i, n);\n      return V.transformRect(r, this.clientMatrix());\n    },\n    clientToLocalPoint: function clientToLocalPoint(t, e) {\n      var i = new g.Point(t, e);\n      return V.transformPoint(i, this.clientMatrix().inverse());\n    },\n    clientToLocalRect: function clientToLocalRect(t, e, i, n) {\n      var r = new g.Rect(t, e, i, n);\n      return V.transformRect(r, this.clientMatrix().inverse());\n    },\n    localToPagePoint: function localToPagePoint(t, e) {\n      return this.localToPaperPoint(t, e).offset(this.pageOffset());\n    },\n    localToPageRect: function localToPageRect(t, e, i, n) {\n      return this.localToPaperRect(t, e, i, n).offset(this.pageOffset());\n    },\n    pageToLocalPoint: function pageToLocalPoint(t, e) {\n      var i = new g.Point(t, e).difference(this.pageOffset());\n      return this.paperToLocalPoint(i);\n    },\n    pageToLocalRect: function pageToLocalRect(t, e, i, n) {\n      var r = this.pageOffset(),\n          o = new g.Rect(t, e, i, n);\n      return o.x -= r.x, o.y -= r.y, this.paperToLocalRect(o);\n    },\n    clientOffset: function clientOffset() {\n      var t = this.svg.getBoundingClientRect();\n      return new g.Point(t.left, t.top);\n    },\n    pageOffset: function pageOffset() {\n      return this.clientOffset().offset(window.scrollX, window.scrollY);\n    },\n    linkAllowed: function linkAllowed(t) {\n      if (!(t instanceof joint.dia.LinkView)) throw new Error(\"Must provide a linkView.\");\n      var e = t.model,\n          i = this.options,\n          n = this.model,\n          r = n.constructor.validations;\n      return !(!i.multiLinks && !r.multiLinks.call(this, n, e)) && !(!i.linkPinning && !r.linkPinning.call(this, n, e)) && !(\"function\" == typeof i.allowLink && !i.allowLink.call(this, t, this));\n    },\n    getDefaultLink: function getDefaultLink(t, e) {\n      return joint.util.isFunction(this.options.defaultLink) ? this.options.defaultLink.call(this, t, e) : this.options.defaultLink.clone();\n    },\n    resolveHighlighter: function resolveHighlighter(e) {\n      var t = (e = e || {}).highlighter,\n          i = this.options;\n\n      if (void 0 === t) {\n        var n = [\"embedding\", \"connecting\", \"magnetAvailability\", \"elementAvailability\"].find(function (t) {\n          return !!e[t];\n        });\n        t = n && i.highlighting[n] || i.highlighting.default;\n      }\n\n      if (!t) return !1;\n      joint.util.isString(t) && (t = {\n        name: t\n      });\n      var r = t.name,\n          o = i.highlighterNamespace[r];\n      if (!o) throw new Error('Unknown highlighter (\"' + r + '\")');\n      if (\"function\" != typeof o.highlight) throw new Error('Highlighter (\"' + r + '\") is missing required highlight() method');\n      if (\"function\" != typeof o.unhighlight) throw new Error('Highlighter (\"' + r + '\") is missing required unhighlight() method');\n      return {\n        highlighter: o,\n        options: t.options || {},\n        name: r\n      };\n    },\n    onCellHighlight: function onCellHighlight(t, e, i) {\n      if (i = this.resolveHighlighter(i)) {\n        e.id || (e.id = V.uniqueId());\n        var n = i.name + e.id + JSON.stringify(i.options);\n\n        if (!this._highlights[n]) {\n          var r = i.highlighter;\n          r.highlight(t, e, joint.util.assign({}, i.options)), this._highlights[n] = {\n            cellView: t,\n            magnetEl: e,\n            opt: i.options,\n            highlighter: r\n          };\n        }\n      }\n    },\n    onCellUnhighlight: function onCellUnhighlight(t, e, i) {\n      if (i = this.resolveHighlighter(i)) {\n        var n = i.name + e.id + JSON.stringify(i.options),\n            r = this._highlights[n];\n        r && (r.highlighter.unhighlight(r.cellView, r.magnetEl, r.opt), this._highlights[n] = null);\n      }\n    },\n    pointerdblclick: function pointerdblclick(t) {\n      t.preventDefault(), t = joint.util.normalizeEvent(t);\n      var e = this.findView(t.target);\n\n      if (!this.guard(t, e)) {\n        var i = this.snapToGrid({\n          x: t.clientX,\n          y: t.clientY\n        });\n        e ? e.pointerdblclick(t, i.x, i.y) : this.trigger(\"blank:pointerdblclick\", t, i.x, i.y);\n      }\n    },\n    pointerclick: function pointerclick(t) {\n      if (this.eventData(t).mousemoved <= this.options.clickThreshold) {\n        t = joint.util.normalizeEvent(t);\n        var e = this.findView(t.target);\n        if (this.guard(t, e)) return;\n        var i = this.snapToGrid({\n          x: t.clientX,\n          y: t.clientY\n        });\n        e ? e.pointerclick(t, i.x, i.y) : this.trigger(\"blank:pointerclick\", t, i.x, i.y);\n      }\n    },\n    contextmenu: function contextmenu(t) {\n      this.options.preventContextMenu && t.preventDefault(), t = joint.util.normalizeEvent(t);\n      var e = this.findView(t.target);\n\n      if (!this.guard(t, e)) {\n        var i = this.snapToGrid({\n          x: t.clientX,\n          y: t.clientY\n        });\n        e ? e.contextmenu(t, i.x, i.y) : this.trigger(\"blank:contextmenu\", t, i.x, i.y);\n      }\n    },\n    pointerdown: function pointerdown(t) {\n      t = joint.util.normalizeEvent(t);\n      var e = this.findView(t.target);\n\n      if (!this.guard(t, e)) {\n        var i = this.snapToGrid({\n          x: t.clientX,\n          y: t.clientY\n        });\n        e ? (t.preventDefault(), e.pointerdown(t, i.x, i.y)) : (this.options.preventDefaultBlankAction && t.preventDefault(), this.trigger(\"blank:pointerdown\", t, i.x, i.y)), this.delegateDragEvents(e, t.data);\n      }\n    },\n    pointermove: function pointermove(t) {\n      var e = this.eventData(t);\n\n      if (e.mousemoved || (e.mousemoved = 0), !(++e.mousemoved <= this.options.moveThreshold)) {\n        t = joint.util.normalizeEvent(t);\n        var i = this.snapToGrid({\n          x: t.clientX,\n          y: t.clientY\n        }),\n            n = e.sourceView;\n        n ? n.pointermove(t, i.x, i.y) : this.trigger(\"blank:pointermove\", t, i.x, i.y), this.eventData(t, e);\n      }\n    },\n    pointerup: function pointerup(t) {\n      this.undelegateDocumentEvents();\n      var e = joint.util.normalizeEvent(t),\n          i = this.snapToGrid({\n        x: e.clientX,\n        y: e.clientY\n      }),\n          n = this.eventData(t).sourceView;\n      n ? n.pointerup(e, i.x, i.y) : this.trigger(\"blank:pointerup\", e, i.x, i.y), e.isPropagationStopped() || this.pointerclick($.Event(t, {\n        type: \"click\",\n        data: t.data\n      })), t.stopImmediatePropagation(), this.delegateEvents();\n    },\n    mouseover: function mouseover(t) {\n      t = joint.util.normalizeEvent(t);\n      var e = this.findView(t.target);\n      if (!this.guard(t, e)) if (e) e.mouseover(t);else {\n        if (this.el === t.target) return;\n        this.trigger(\"blank:mouseover\", t);\n      }\n    },\n    mouseout: function mouseout(t) {\n      t = joint.util.normalizeEvent(t);\n      var e = this.findView(t.target);\n      if (!this.guard(t, e)) if (e) e.mouseout(t);else {\n        if (this.el === t.target) return;\n        this.trigger(\"blank:mouseout\", t);\n      }\n    },\n    mouseenter: function mouseenter(t) {\n      t = joint.util.normalizeEvent(t);\n      var e = this.findView(t.target);\n\n      if (!this.guard(t, e)) {\n        var i = this.findView(t.relatedTarget);\n\n        if (e) {\n          if (i === e) return;\n          e.mouseenter(t);\n        } else {\n          if (i) return;\n          this.trigger(\"paper:mouseenter\", t);\n        }\n      }\n    },\n    mouseleave: function mouseleave(t) {\n      t = joint.util.normalizeEvent(t);\n      var e = this.findView(t.target);\n\n      if (!this.guard(t, e)) {\n        var i = this.findView(t.relatedTarget);\n\n        if (e) {\n          if (i === e) return;\n          e.mouseleave(t);\n        } else {\n          if (i) return;\n          this.trigger(\"paper:mouseleave\", t);\n        }\n      }\n    },\n    mousewheel: function mousewheel(t) {\n      t = joint.util.normalizeEvent(t);\n      var e = this.findView(t.target);\n\n      if (!this.guard(t, e)) {\n        var i = t.originalEvent,\n            n = this.snapToGrid({\n          x: i.clientX,\n          y: i.clientY\n        }),\n            r = Math.max(-1, Math.min(1, i.wheelDelta || -i.detail));\n        e ? e.mousewheel(t, n.x, n.y, r) : this.trigger(\"blank:mousewheel\", t, n.x, n.y, r);\n      }\n    },\n    onevent: function onevent(t) {\n      var e = t.currentTarget,\n          i = e.getAttribute(\"event\");\n\n      if (i) {\n        var n = this.findView(e);\n\n        if (n) {\n          if (t = joint.util.normalizeEvent(t), this.guard(t, n)) return;\n          var r = this.snapToGrid({\n            x: t.clientX,\n            y: t.clientY\n          });\n          n.onevent(t, i, r.x, r.y);\n        }\n      }\n    },\n    magnetEvent: function magnetEvent(t, e) {\n      var i = t.currentTarget;\n\n      if (i.getAttribute(\"magnet\")) {\n        var n = this.findView(i);\n\n        if (n) {\n          if (t = joint.util.normalizeEvent(t), this.guard(t, n)) return;\n          var r = this.snapToGrid(t.clientX, t.clientY);\n          e.call(this, n, t, i, r.x, r.y);\n        }\n      }\n    },\n    onmagnet: function onmagnet(t) {\n      this.magnetEvent(t, function (t, e, i, n, r) {\n        t.onmagnet(e, n, r);\n      });\n    },\n    magnetpointerdblclick: function magnetpointerdblclick(t) {\n      this.magnetEvent(t, function (t, e, i, n, r) {\n        t.magnetpointerdblclick(e, i, n, r);\n      });\n    },\n    magnetcontextmenu: function magnetcontextmenu(t) {\n      this.options.preventContextMenu && t.preventDefault(), this.magnetEvent(t, function (t, e, i, n, r) {\n        t.magnetcontextmenu(e, i, n, r);\n      });\n    },\n    onlabel: function onlabel(t) {\n      var e = t.currentTarget,\n          i = this.findView(e);\n\n      if (i) {\n        if (t = joint.util.normalizeEvent(t), this.guard(t, i)) return;\n        var n = this.snapToGrid(t.clientX, t.clientY);\n        i.onlabel(t, n.x, n.y);\n      }\n    },\n    delegateDragEvents: function delegateDragEvents(t, e) {\n      e || (e = {}), this.eventData({\n        data: e\n      }, {\n        sourceView: t || null,\n        mousemoved: 0\n      }), this.delegateDocumentEvents(null, e), this.undelegateEvents();\n    },\n    guard: function guard(t, e) {\n      return \"mousedown\" === t.type && 2 === t.button || !(!this.options.guard || !this.options.guard(t, e)) || (t.data && void 0 !== t.data.guarded ? t.data.guarded : !(e && e.model && e.model instanceof joint.dia.Cell) && this.svg !== t.target && this.el !== t.target && !$.contains(this.svg, t.target));\n    },\n    setGridSize: function setGridSize(t) {\n      return this.options.gridSize = t, this.options.drawGrid && this.drawGrid(), this;\n    },\n    clearGrid: function clearGrid() {\n      return this.$grid && this.$grid.css(\"backgroundImage\", \"none\"), this;\n    },\n    _getGriRefs: function _getGriRefs() {\n      return this._gridCache || (this._gridCache = {\n        root: V(\"svg\", {\n          width: \"100%\",\n          height: \"100%\"\n        }, V(\"defs\")),\n        patterns: {},\n        add: function add(t, e) {\n          V(this.root.node.childNodes[0]).append(e), this.patterns[t] = e, this.root.append(V(\"rect\", {\n            width: \"100%\",\n            height: \"100%\",\n            fill: \"url(#\" + t + \")\"\n          }));\n        },\n        get: function get(t) {\n          return this.patterns[t];\n        },\n        exist: function exist(t) {\n          return void 0 !== this.patterns[t];\n        }\n      }), this._gridCache;\n    },\n    setGrid: function setGrid(t) {\n      return this.clearGrid(), this._gridCache = null, this._gridSettings = [], (Array.isArray(t) ? t : [t || {}]).forEach(function (t) {\n        this._gridSettings.push.apply(this._gridSettings, this._resolveDrawGridOption(t));\n      }, this), this;\n    },\n    _resolveDrawGridOption: function _resolveDrawGridOption(t) {\n      var e = this.constructor.gridPatterns;\n      if (joint.util.isString(t) && Array.isArray(e[t])) return e[t].map(function (t) {\n        return joint.util.assign({}, t);\n      });\n      var i = t || {\n        args: [{}]\n      },\n          n = Array.isArray(i),\n          r = i.name;\n\n      if (n || r || i.markup || (r = \"dot\"), r && Array.isArray(e[r])) {\n        var o = e[r].map(function (t) {\n          return joint.util.assign({}, t);\n        }),\n            s = Array.isArray(i.args) ? i.args : [i.args || {}];\n        joint.util.defaults(s[0], joint.util.omit(t, \"args\"));\n\n        for (var a = 0; a < s.length; a++) {\n          o[a] && joint.util.assign(o[a], s[a]);\n        }\n\n        return o;\n      }\n\n      return n ? i : [i];\n    },\n    drawGrid: function drawGrid(t) {\n      var a = this.options.gridSize;\n      if (a <= 1) return this.clearGrid();\n\n      var l = Array.isArray(t) ? t : [t],\n          h = this.matrix(),\n          u = this._getGriRefs();\n\n      this._gridSettings.forEach(function (t, e) {\n        var i = \"pattern_\" + e,\n            n = joint.util.merge(t, l[e], {\n          sx: h.a || 1,\n          sy: h.d || 1,\n          ox: h.e || 0,\n          oy: h.f || 0\n        });\n        n.width = a * (h.a || 1) * (n.scaleFactor || 1), n.height = a * (h.d || 1) * (n.scaleFactor || 1), u.exist(i) || u.add(i, V(\"pattern\", {\n          id: i,\n          patternUnits: \"userSpaceOnUse\"\n        }, V(n.markup)));\n        var r = u.get(i);\n        joint.util.isFunction(n.update) && n.update(r.node.childNodes[0], n);\n        var o = n.ox % n.width;\n        o < 0 && (o += n.width);\n        var s = n.oy % n.height;\n        s < 0 && (s += n.height), r.attr({\n          x: o,\n          y: s,\n          width: n.width,\n          height: n.height\n        });\n      });\n\n      var e = new XMLSerializer().serializeToString(u.root.node);\n      return e = \"url(data:image/svg+xml;base64,\" + btoa(e) + \")\", this.$grid.css(\"backgroundImage\", e), this;\n    },\n    updateBackgroundImage: function updateBackgroundImage(t) {\n      var e = (t = t || {}).position || \"center\",\n          i = t.size || \"auto auto\",\n          n = this.scale(),\n          r = this.translate();\n      joint.util.isObject(e) && (e = r.tx + n.sx * (e.x || 0) + \"px \" + (r.ty + n.sy * (e.y || 0)) + \"px\");\n      joint.util.isObject(i) && (i = (i = new g.Rect(i).scale(n.sx, n.sy)).width + \"px \" + i.height + \"px\"), this.$background.css({\n        backgroundSize: i,\n        backgroundPosition: e\n      });\n    },\n    drawBackgroundImage: function drawBackgroundImage(t, e) {\n      if (t instanceof HTMLImageElement) {\n        var i,\n            n = (e = e || {}).size,\n            r = e.repeat || \"no-repeat\",\n            o = e.opacity || 1,\n            s = Math.abs(e.quality) || 1,\n            a = this.constructor.backgroundPatterns[joint.util.camelCase(r)];\n\n        if (joint.util.isFunction(a)) {\n          t.width *= s, t.height *= s;\n          var l = a(t, e);\n          if (!(l instanceof HTMLCanvasElement)) throw new Error(\"dia.Paper: background pattern must return an HTML Canvas instance\");\n          i = l.toDataURL(\"image/png\"), r = \"repeat\", joint.util.isObject(n) ? (n.width *= l.width / t.width, n.height *= l.height / t.height) : void 0 === n && (e.size = {\n            width: l.width / s,\n            height: l.height / s\n          });\n        } else i = t.src, void 0 === n && (e.size = {\n          width: t.width,\n          height: t.height\n        });\n\n        this.$background.css({\n          opacity: o,\n          backgroundRepeat: r,\n          backgroundImage: \"url(\" + i + \")\"\n        }), this.updateBackgroundImage(e);\n      } else this.$background.css(\"backgroundImage\", \"\");\n    },\n    updateBackgroundColor: function updateBackgroundColor(t) {\n      this.$el.css(\"backgroundColor\", t || \"\");\n    },\n    drawBackground: function drawBackground(t) {\n      if (t = t || {}, this.updateBackgroundColor(t.color), t.image) {\n        t = this._background = joint.util.cloneDeep(t);\n        var e = document.createElement(\"img\");\n        e.onload = this.drawBackgroundImage.bind(this, e, t), e.src = t.image;\n      } else this.drawBackgroundImage(null), this._background = null;\n\n      return this;\n    },\n    setInteractivity: function setInteractivity(t) {\n      this.options.interactive = t, joint.util.invoke(this._views, \"setInteractivity\", t);\n    },\n    isDefined: function isDefined(t) {\n      return !!this.svg.getElementById(t);\n    },\n    defineFilter: function defineFilter(t) {\n      if (!joint.util.isObject(t)) throw new TypeError(\"dia.Paper: defineFilter() requires 1. argument to be an object.\");\n      var e = t.id,\n          i = t.name;\n\n      if (e || (e = i + this.svg.id + joint.util.hashCode(JSON.stringify(t))), !this.isDefined(e)) {\n        var n = joint.util.filter,\n            r = n[i] && n[i](t.args || {});\n        if (!r) throw new Error(\"Non-existing filter \" + i);\n        var o = joint.util.assign({\n          filterUnits: \"objectBoundingBox\",\n          x: -1,\n          y: -1,\n          width: 3,\n          height: 3\n        }, t.attrs, {\n          id: e\n        });\n        V(r, o).appendTo(this.defs);\n      }\n\n      return e;\n    },\n    defineGradient: function defineGradient(t) {\n      if (!joint.util.isObject(t)) throw new TypeError(\"dia.Paper: defineGradient() requires 1. argument to be an object.\");\n      var e = t.id,\n          i = t.type,\n          n = t.stops;\n\n      if (e || (e = i + this.svg.id + joint.util.hashCode(JSON.stringify(t))), !this.isDefined(e)) {\n        var r = joint.util.template('<stop offset=\"${offset}\" stop-color=\"${color}\" stop-opacity=\"${opacity}\"/>'),\n            o = [\"<\" + i + \">\", joint.util.toArray(n).map(function (t) {\n          return r({\n            offset: t.offset,\n            color: t.color,\n            opacity: Number.isFinite(t.opacity) ? t.opacity : 1\n          });\n        }).join(\"\"), \"</\" + i + \">\"].join(\"\"),\n            s = joint.util.assign({\n          id: e\n        }, t.attrs);\n        V(o, s).appendTo(this.defs);\n      }\n\n      return e;\n    },\n    defineMarker: function defineMarker(t) {\n      if (!joint.util.isObject(t)) throw new TypeError(\"dia.Paper: defineMarker() requires 1. argument to be an object.\");\n      var e = t.id;\n\n      if (e || (e = this.svg.id + joint.util.hashCode(JSON.stringify(t))), !this.isDefined(e)) {\n        var i = joint.util.omit(t, \"type\", \"userSpaceOnUse\");\n        V(\"marker\", {\n          id: e,\n          orient: \"auto\",\n          overflow: \"visible\",\n          markerUnits: t.markerUnits || \"userSpaceOnUse\"\n        }, [V(t.type || \"path\", i)]).appendTo(this.defs);\n      }\n\n      return e;\n    }\n  }, {\n    backgroundPatterns: {\n      flipXy: function flipXy(t) {\n        var e = document.createElement(\"canvas\"),\n            i = t.width,\n            n = t.height;\n        e.width = 2 * i, e.height = 2 * n;\n        var r = e.getContext(\"2d\");\n        return r.drawImage(t, 0, 0, i, n), r.setTransform(-1, 0, 0, -1, e.width, e.height), r.drawImage(t, 0, 0, i, n), r.setTransform(-1, 0, 0, 1, e.width, 0), r.drawImage(t, 0, 0, i, n), r.setTransform(1, 0, 0, -1, 0, e.height), r.drawImage(t, 0, 0, i, n), e;\n      },\n      flipX: function flipX(t) {\n        var e = document.createElement(\"canvas\"),\n            i = t.width,\n            n = t.height;\n        e.width = 2 * i, e.height = n;\n        var r = e.getContext(\"2d\");\n        return r.drawImage(t, 0, 0, i, n), r.translate(2 * i, 0), r.scale(-1, 1), r.drawImage(t, 0, 0, i, n), e;\n      },\n      flipY: function flipY(t) {\n        var e = document.createElement(\"canvas\"),\n            i = t.width,\n            n = t.height;\n        e.width = i, e.height = 2 * n;\n        var r = e.getContext(\"2d\");\n        return r.drawImage(t, 0, 0, i, n), r.translate(0, 2 * n), r.scale(1, -1), r.drawImage(t, 0, 0, i, n), e;\n      },\n      watermark: function watermark(t, e) {\n        e = e || {};\n        var i = t.width,\n            n = t.height,\n            r = document.createElement(\"canvas\");\n        r.width = 3 * i, r.height = 3 * n;\n\n        for (var o = r.getContext(\"2d\"), s = joint.util.isNumber(e.watermarkAngle) ? -e.watermarkAngle : -20, a = g.toRad(s), l = r.width / 4, h = r.height / 4, u = 0; u < 4; u++) {\n          for (var c = 0; c < 4; c++) {\n            0 < (u + c) % 2 && (o.setTransform(1, 0, 0, 1, (2 * u - 1) * l, (2 * c - 1) * h), o.rotate(a), o.drawImage(t, -i / 2, -n / 2, i, n));\n          }\n        }\n\n        return r;\n      }\n    },\n    gridPatterns: {\n      dot: [{\n        color: \"#AAAAAA\",\n        thickness: 1,\n        markup: \"rect\",\n        update: function update(t, e) {\n          V(t).attr({\n            width: e.thickness * e.sx,\n            height: e.thickness * e.sy,\n            fill: e.color\n          });\n        }\n      }],\n      fixedDot: [{\n        color: \"#AAAAAA\",\n        thickness: 1,\n        markup: \"rect\",\n        update: function update(t, e) {\n          var i = e.sx <= 1 ? e.thickness * e.sx : e.thickness;\n          V(t).attr({\n            width: i,\n            height: i,\n            fill: e.color\n          });\n        }\n      }],\n      mesh: [{\n        color: \"#AAAAAA\",\n        thickness: 1,\n        markup: \"path\",\n        update: function update(t, e) {\n          var i,\n              n = e.width,\n              r = e.height,\n              o = e.thickness;\n          i = 0 <= n - o && 0 <= r - o ? [\"M\", n, 0, \"H0 M0 0 V0\", r].join(\" \") : \"M 0 0 0 0\", V(t).attr({\n            d: i,\n            stroke: e.color,\n            \"stroke-width\": e.thickness\n          });\n        }\n      }],\n      doubleMesh: [{\n        color: \"#AAAAAA\",\n        thickness: 1,\n        markup: \"path\",\n        update: function update(t, e) {\n          var i,\n              n = e.width,\n              r = e.height,\n              o = e.thickness;\n          i = 0 <= n - o && 0 <= r - o ? [\"M\", n, 0, \"H0 M0 0 V0\", r].join(\" \") : \"M 0 0 0 0\", V(t).attr({\n            d: i,\n            stroke: e.color,\n            \"stroke-width\": e.thickness\n          });\n        }\n      }, {\n        color: \"#000000\",\n        thickness: 3,\n        scaleFactor: 4,\n        markup: \"path\",\n        update: function update(t, e) {\n          var i,\n              n = e.width,\n              r = e.height,\n              o = e.thickness;\n          i = 0 <= n - o && 0 <= r - o ? [\"M\", n, 0, \"H0 M0 0 V0\", r].join(\" \") : \"M 0 0 0 0\", V(t).attr({\n            d: i,\n            stroke: e.color,\n            \"stroke-width\": e.thickness\n          });\n        }\n      }]\n    }\n  }), function (n, p) {\n    var o = function o(t) {\n      var e = p.cloneDeep(t) || {};\n      this.ports = [], this.groups = {}, this.portLayoutNamespace = n.layout.Port, this.portLabelLayoutNamespace = n.layout.PortLabel, this._init(e);\n    };\n\n    o.prototype = {\n      getPorts: function getPorts() {\n        return this.ports;\n      },\n      getGroup: function getGroup(t) {\n        return this.groups[t] || {};\n      },\n      getPortsByGroup: function getPortsByGroup(e) {\n        return this.ports.filter(function (t) {\n          return t.group === e;\n        });\n      },\n      getGroupPortsMetrics: function getGroupPortsMetrics(t, r) {\n        var e = this.getGroup(t),\n            i = this.getPortsByGroup(t),\n            n = e.position || {},\n            o = n.name,\n            s = this.portLayoutNamespace;\n        s[o] || (o = \"left\");\n        var a = n.args || {},\n            l = i.map(function (t) {\n          return t && t.position && t.position.args;\n        }),\n            h = s[o](l, r, a),\n            u = {\n          ports: i,\n          result: []\n        };\n        return p.toArray(h).reduce(function (t, e, i) {\n          var n = t.ports[i];\n          return t.result.push({\n            portId: n.id,\n            portTransformation: e,\n            labelTransformation: this._getPortLabelLayout(n, g.Point(e), r),\n            portAttrs: n.attrs,\n            portSize: n.size,\n            labelSize: n.label.size\n          }), t;\n        }.bind(this), u), u.result;\n      },\n      _getPortLabelLayout: function _getPortLabelLayout(t, e, i) {\n        var n = this.portLabelLayoutNamespace,\n            r = t.label.position.name || \"left\";\n        return n[r] ? n[r](e, i, t.label.position.args) : null;\n      },\n      _init: function _init(t) {\n        if (p.isObject(t.groups)) for (var e = Object.keys(t.groups), i = 0, n = e.length; i < n; i++) {\n          var r = e[i];\n          this.groups[r] = this._evaluateGroup(t.groups[r]);\n        }\n\n        for (var o = p.toArray(t.items), s = 0, a = o.length; s < a; s++) {\n          this.ports.push(this._evaluatePort(o[s]));\n        }\n      },\n      _evaluateGroup: function _evaluateGroup(t) {\n        return p.merge(t, {\n          position: this._getPosition(t.position, !0),\n          label: this._getLabel(t, !0)\n        });\n      },\n      _evaluatePort: function _evaluatePort(t) {\n        var e = p.assign({}, t),\n            i = this.getGroup(t.group);\n        return e.markup = e.markup || i.markup, e.attrs = p.merge({}, i.attrs, e.attrs), e.position = this._createPositionNode(i, e), e.label = p.merge({}, i.label, this._getLabel(e)), e.z = this._getZIndex(i, e), e.size = p.assign({}, i.size, e.size), e;\n      },\n      _getZIndex: function _getZIndex(t, e) {\n        return p.isNumber(e.z) ? e.z : p.isNumber(t.z) || \"auto\" === t.z ? t.z : \"auto\";\n      },\n      _createPositionNode: function _createPositionNode(t, e) {\n        return p.merge({\n          name: \"left\",\n          args: {}\n        }, t.position, {\n          args: e.args\n        });\n      },\n      _getPosition: function _getPosition(t, e) {\n        var i,\n            n = {};\n        p.isFunction(t) ? (i = \"fn\", n.fn = t) : p.isString(t) ? i = t : void 0 === t ? i = e ? \"left\" : null : Array.isArray(t) ? (i = \"absolute\", n.x = t[0], n.y = t[1]) : p.isObject(t) && (i = t.name, p.assign(n, t.args));\n        var r = {\n          args: n\n        };\n        return i && (r.name = i), r;\n      },\n      _getLabel: function _getLabel(t, e) {\n        var i = t.label || {},\n            n = i;\n        return n.position = this._getPosition(i.position, e), n;\n      }\n    }, p.assign(n.dia.Element.prototype, {\n      _initializePorts: function _initializePorts() {\n        this._createPortData(), this.on(\"change:ports\", function () {\n          this._processRemovedPort(), this._createPortData();\n        }, this);\n      },\n      _processRemovedPort: function _processRemovedPort() {\n        var t = this.get(\"ports\") || {},\n            e = {};\n        p.toArray(t.items).forEach(function (t) {\n          e[t.id] = !0;\n        });\n        var i = this.previous(\"ports\") || {},\n            n = {};\n        p.toArray(i.items).forEach(function (t) {\n          e[t.id] || (n[t.id] = !0);\n        });\n        var r = this.graph;\n        r && !p.isEmpty(n) && (r.getConnectedLinks(this, {\n          inbound: !0\n        }).forEach(function (t) {\n          n[t.get(\"target\").port] && t.remove();\n        }), r.getConnectedLinks(this, {\n          outbound: !0\n        }).forEach(function (t) {\n          n[t.get(\"source\").port] && t.remove();\n        }));\n      },\n      hasPorts: function hasPorts() {\n        var t = this.prop(\"ports/items\");\n        return Array.isArray(t) && 0 < t.length;\n      },\n      hasPort: function hasPort(t) {\n        return -1 !== this.getPortIndex(t);\n      },\n      getPorts: function getPorts() {\n        return p.cloneDeep(this.prop(\"ports/items\")) || [];\n      },\n      getPort: function getPort(e) {\n        return p.cloneDeep(p.toArray(this.prop(\"ports/items\")).find(function (t) {\n          return t.id && t.id === e;\n        }));\n      },\n      getPortsPositions: function getPortsPositions(t) {\n        return this._portSettingsData.getGroupPortsMetrics(t, g.Rect(this.size())).reduce(function (t, e) {\n          var i = e.portTransformation;\n          return t[e.portId] = {\n            x: i.x,\n            y: i.y,\n            angle: i.angle\n          }, t;\n        }, {});\n      },\n      getPortIndex: function getPortIndex(t) {\n        var e = p.isObject(t) ? t.id : t;\n        return this._isValidPortId(e) ? p.toArray(this.prop(\"ports/items\")).findIndex(function (t) {\n          return t.id === e;\n        }) : -1;\n      },\n      addPort: function addPort(t, e) {\n        if (!p.isObject(t) || Array.isArray(t)) throw new Error(\"Element: addPort requires an object.\");\n        var i = p.assign([], this.prop(\"ports/items\"));\n        return i.push(t), this.prop(\"ports/items\", i, e), this;\n      },\n      portProp: function portProp(t, e, i, n) {\n        var r = this.getPortIndex(t);\n        if (-1 === r) throw new Error(\"Element: unable to find port with id \" + t);\n        var o = Array.prototype.slice.call(arguments, 1);\n        return Array.isArray(e) ? o[0] = [\"ports\", \"items\", r].concat(e) : p.isString(e) ? o[0] = [\"ports/items/\", r, \"/\", e].join(\"\") : (o = [\"ports/items/\" + r], p.isPlainObject(e) && (o.push(e), o.push(i))), this.prop.apply(this, o);\n      },\n      _validatePorts: function _validatePorts() {\n        var t = this.get(\"ports\") || {},\n            e = [];\n        t = t || {};\n        var i = p.toArray(t.items);\n        return i.forEach(function (t) {\n          \"object\" != typeof t && e.push(\"Element: invalid port \", t), this._isValidPortId(t.id) || (t.id = p.uuid());\n        }, this), n.util.uniq(i, \"id\").length !== i.length && e.push(\"Element: found id duplicities in ports.\"), e;\n      },\n      _isValidPortId: function _isValidPortId(t) {\n        return null != t && !p.isObject(t);\n      },\n      addPorts: function addPorts(t, e) {\n        return t.length && this.prop(\"ports/items\", p.assign([], this.prop(\"ports/items\")).concat(t), e), this;\n      },\n      removePort: function removePort(t, e) {\n        var i = e || {},\n            n = p.assign([], this.prop(\"ports/items\")),\n            r = this.getPortIndex(t);\n        return -1 !== r && (n.splice(r, 1), i.rewrite = !0, this.prop(\"ports/items\", n, i)), this;\n      },\n      removePorts: function removePorts(t, e) {\n        var i;\n\n        if (Array.isArray(t)) {\n          if (i = e || {}, t.length) {\n            i.rewrite = !0;\n            var n = p.assign([], this.prop(\"ports/items\")).filter(function (i) {\n              return !t.some(function (t) {\n                var e = p.isObject(t) ? t.id : t;\n                return i.id === e;\n              });\n            });\n            this.prop(\"ports/items\", n, i);\n          }\n        } else (i = t || {}).rewrite = !0, this.prop(\"ports/items\", [], i);\n\n        return this;\n      },\n      _createPortData: function _createPortData() {\n        var t,\n            e = this._validatePorts();\n\n        if (0 < e.length) throw this.set(\"ports\", this.previous(\"ports\")), new Error(e.join(\" \"));\n        this._portSettingsData && (t = this._portSettingsData.getPorts()), this._portSettingsData = new o(this.get(\"ports\"));\n\n        var i = this._portSettingsData.getPorts();\n\n        if (t) {\n          var n = i.filter(function (e) {\n            if (!t.find(function (t) {\n              return t.id === e.id;\n            })) return e;\n          }),\n              r = t.filter(function (e) {\n            if (!i.find(function (t) {\n              return t.id === e.id;\n            })) return e;\n          });\n          0 < r.length && this.trigger(\"ports:remove\", this, r), 0 < n.length && this.trigger(\"ports:add\", this, n);\n        }\n      }\n    }), p.assign(n.dia.ElementView.prototype, {\n      portContainerMarkup: \"g\",\n      portMarkup: [{\n        tagName: \"circle\",\n        selector: \"circle\",\n        attributes: {\n          r: 10,\n          fill: \"#FFFFFF\",\n          stroke: \"#000000\"\n        }\n      }],\n      portLabelMarkup: [{\n        tagName: \"text\",\n        selector: \"text\",\n        attributes: {\n          fill: \"#000000\"\n        }\n      }],\n      _portElementsCache: null,\n      _initializePorts: function _initializePorts() {\n        this._portElementsCache = {}, this.listenTo(this.model, \"change:ports\", function () {\n          this._refreshPorts();\n        });\n      },\n      _refreshPorts: function _refreshPorts() {\n        this._removePorts(), this._portElementsCache = {}, this._renderPorts();\n      },\n      _renderPorts: function _renderPorts() {\n        for (var i = [], n = this._getContainerElement(), t = 0, e = n.node.childNodes.length; t < e; t++) {\n          i.push(n.node.childNodes[t]);\n        }\n\n        var r = p.groupBy(this.model._portSettingsData.getPorts(), \"z\");\n        p.toArray(r.auto).forEach(function (t) {\n          var e = this._getPortElement(t);\n\n          n.append(e), i.push(e);\n        }, this);\n\n        for (var o = Object.keys(r), s = 0; s < o.length; s++) {\n          var a = o[s];\n\n          if (\"auto\" !== a) {\n            var l = parseInt(a, 10);\n\n            this._appendPorts(r[a], l, i);\n          }\n        }\n\n        this._updatePorts();\n      },\n      _getContainerElement: function _getContainerElement() {\n        return this.rotatableNode || this.vel;\n      },\n      _appendPorts: function _appendPorts(t, e, i) {\n        var n = this._getContainerElement(),\n            r = p.toArray(t).map(this._getPortElement, this);\n\n        i[e] || e < 0 ? V(i[Math.max(e, 0)]).before(r) : n.append(r);\n      },\n      _getPortElement: function _getPortElement(t) {\n        return this._portElementsCache[t.id] ? this._portElementsCache[t.id].portElement : this._createPortElement(t);\n      },\n      findPortNode: function findPortNode(t, e) {\n        var i = this._portElementsCache[t];\n        if (!i) return null;\n        var n = i.portContentElement.node,\n            r = i.portContentSelectors;\n        return this.findBySelector(e, n, r)[0];\n      },\n      _updatePorts: function _updatePorts() {\n        this._updatePortGroup(void 0), Object.keys(this.model._portSettingsData.groups).forEach(this._updatePortGroup, this);\n      },\n      _removePorts: function _removePorts() {\n        p.invoke(this._portElementsCache, \"portElement.remove\");\n      },\n      _createPortElement: function _createPortElement(t) {\n        var e,\n            i,\n            n,\n            r = V(this.portContainerMarkup).addClass(\"joint-port\"),\n            o = this._getPortMarkup(t);\n\n        if (Array.isArray(o)) {\n          var s = this.parseDOMJSON(o, r.node),\n              a = s.fragment;\n          e = 1 < a.childNodes.length ? V(\"g\").append(a) : V(a.firstChild), n = s.selectors;\n        } else e = V(o), Array.isArray(e) && (e = V(\"g\").append(e));\n\n        if (!e) throw new Error(\"ElementView: Invalid port markup.\");\n        e.attr({\n          port: t.id,\n          \"port-group\": t.group\n        });\n\n        var l,\n            h,\n            u = this._getPortLabelMarkup(t.label);\n\n        if (Array.isArray(u)) {\n          var c = this.parseDOMJSON(u, r.node),\n              d = c.fragment;\n          i = 1 < d.childNodes.length ? V(\"g\").append(d) : V(d.firstChild), l = c.selectors;\n        } else i = V(u), Array.isArray(i) && (i = V(\"g\").append(i));\n\n        if (!i) throw new Error(\"ElementView: Invalid port label markup.\");\n\n        if (n && l) {\n          for (var f in l) {\n            if (n[f] && f !== this.selector) throw new Error(\"ElementView: selectors within port must be unique.\");\n          }\n\n          h = p.assign({}, n, l);\n        } else h = n || l;\n\n        return r.append([e.addClass(\"joint-port-body\"), i.addClass(\"joint-port-label\")]), this._portElementsCache[t.id] = {\n          portElement: r,\n          portLabelElement: i,\n          portSelectors: h,\n          portLabelSelectors: l,\n          portContentElement: e,\n          portContentSelectors: n\n        }, r;\n      },\n      _updatePortGroup: function _updatePortGroup(t) {\n        for (var e = g.Rect(this.model.size()), i = this.model._portSettingsData.getGroupPortsMetrics(t, e), n = 0, r = i.length; n < r; n++) {\n          var o = i[n],\n              s = o.portId,\n              a = this._portElementsCache[s] || {},\n              l = o.portTransformation;\n          this.applyPortTransform(a.portElement, l), this.updateDOMSubtreeAttributes(a.portElement.node, o.portAttrs, {\n            rootBBox: new g.Rect(o.portSize),\n            selectors: a.portSelectors\n          });\n          var h = o.labelTransformation;\n          h && (this.applyPortTransform(a.portLabelElement, h, -l.angle || 0), this.updateDOMSubtreeAttributes(a.portLabelElement.node, h.attrs, {\n            rootBBox: new g.Rect(o.labelSize),\n            selectors: a.portLabelSelectors\n          }));\n        }\n      },\n      applyPortTransform: function applyPortTransform(t, e, i) {\n        var n = V.createSVGMatrix().rotate(i || 0).translate(e.x || 0, e.y || 0).rotate(e.angle || 0);\n        t.transform(n, {\n          absolute: !0\n        });\n      },\n      _getPortMarkup: function _getPortMarkup(t) {\n        return t.markup || this.model.get(\"portMarkup\") || this.model.portMarkup || this.portMarkup;\n      },\n      _getPortLabelMarkup: function _getPortLabelMarkup(t) {\n        return t.markup || this.model.get(\"portLabelMarkup\") || this.model.portLabelMarkup || this.portLabelMarkup;\n      }\n    });\n  }(joint, joint.util), joint.dia.Element.define(\"basic.Generic\", {\n    attrs: {\n      \".\": {\n        fill: \"#ffffff\",\n        stroke: \"none\"\n      }\n    }\n  }), joint.shapes.basic.Generic.define(\"basic.Rect\", {\n    attrs: {\n      rect: {\n        fill: \"#ffffff\",\n        stroke: \"#000000\",\n        width: 100,\n        height: 60\n      },\n      text: {\n        fill: \"#000000\",\n        text: \"\",\n        \"font-size\": 14,\n        \"ref-x\": .5,\n        \"ref-y\": .5,\n        \"text-anchor\": \"middle\",\n        \"y-alignment\": \"middle\",\n        \"font-family\": \"Arial, helvetica, sans-serif\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect/></g><text/></g>'\n  }), joint.shapes.basic.TextView = joint.dia.ElementView.extend({\n    initialize: function initialize() {\n      joint.dia.ElementView.prototype.initialize.apply(this, arguments), this.listenTo(this.model, \"change:attrs\", this.resize);\n    }\n  }), joint.shapes.basic.Generic.define(\"basic.Text\", {\n    attrs: {\n      text: {\n        \"font-size\": 18,\n        fill: \"#000000\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><text/></g></g>'\n  }), joint.shapes.basic.Generic.define(\"basic.Circle\", {\n    size: {\n      width: 60,\n      height: 60\n    },\n    attrs: {\n      circle: {\n        fill: \"#ffffff\",\n        stroke: \"#000000\",\n        r: 30,\n        cx: 30,\n        cy: 30\n      },\n      text: {\n        \"font-size\": 14,\n        text: \"\",\n        \"text-anchor\": \"middle\",\n        \"ref-x\": .5,\n        \"ref-y\": .5,\n        \"y-alignment\": \"middle\",\n        fill: \"#000000\",\n        \"font-family\": \"Arial, helvetica, sans-serif\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle/></g><text/></g>'\n  }), joint.shapes.basic.Generic.define(\"basic.Ellipse\", {\n    size: {\n      width: 60,\n      height: 40\n    },\n    attrs: {\n      ellipse: {\n        fill: \"#ffffff\",\n        stroke: \"#000000\",\n        rx: 30,\n        ry: 20,\n        cx: 30,\n        cy: 20\n      },\n      text: {\n        \"font-size\": 14,\n        text: \"\",\n        \"text-anchor\": \"middle\",\n        \"ref-x\": .5,\n        \"ref-y\": .5,\n        \"y-alignment\": \"middle\",\n        fill: \"#000000\",\n        \"font-family\": \"Arial, helvetica, sans-serif\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><ellipse/></g><text/></g>'\n  }), joint.shapes.basic.Generic.define(\"basic.Polygon\", {\n    size: {\n      width: 60,\n      height: 40\n    },\n    attrs: {\n      polygon: {\n        fill: \"#ffffff\",\n        stroke: \"#000000\"\n      },\n      text: {\n        \"font-size\": 14,\n        text: \"\",\n        \"text-anchor\": \"middle\",\n        \"ref-x\": .5,\n        \"ref-dy\": 20,\n        \"y-alignment\": \"middle\",\n        fill: \"#000000\",\n        \"font-family\": \"Arial, helvetica, sans-serif\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon/></g><text/></g>'\n  }), joint.shapes.basic.Generic.define(\"basic.Polyline\", {\n    size: {\n      width: 60,\n      height: 40\n    },\n    attrs: {\n      polyline: {\n        fill: \"#ffffff\",\n        stroke: \"#000000\"\n      },\n      text: {\n        \"font-size\": 14,\n        text: \"\",\n        \"text-anchor\": \"middle\",\n        \"ref-x\": .5,\n        \"ref-dy\": 20,\n        \"y-alignment\": \"middle\",\n        fill: \"#000000\",\n        \"font-family\": \"Arial, helvetica, sans-serif\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polyline/></g><text/></g>'\n  }), joint.shapes.basic.Generic.define(\"basic.Image\", {\n    attrs: {\n      text: {\n        \"font-size\": 14,\n        text: \"\",\n        \"text-anchor\": \"middle\",\n        \"ref-x\": .5,\n        \"ref-dy\": 20,\n        \"y-alignment\": \"middle\",\n        fill: \"#000000\",\n        \"font-family\": \"Arial, helvetica, sans-serif\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><image/></g><text/></g>'\n  }), joint.shapes.basic.Generic.define(\"basic.Path\", {\n    size: {\n      width: 60,\n      height: 60\n    },\n    attrs: {\n      path: {\n        fill: \"#ffffff\",\n        stroke: \"#000000\"\n      },\n      text: {\n        \"font-size\": 14,\n        text: \"\",\n        \"text-anchor\": \"middle\",\n        ref: \"path\",\n        \"ref-x\": .5,\n        \"ref-dy\": 10,\n        fill: \"#000000\",\n        \"font-family\": \"Arial, helvetica, sans-serif\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><path/></g><text/></g>'\n  }), joint.shapes.basic.Path.define(\"basic.Rhombus\", {\n    attrs: {\n      path: {\n        d: \"M 30 0 L 60 30 30 60 0 30 z\"\n      },\n      text: {\n        \"ref-y\": .5,\n        \"ref-dy\": null,\n        \"y-alignment\": \"middle\"\n      }\n    }\n  }), joint.shapes.basic.PortsModelInterface = {\n    initialize: function initialize() {\n      this.updatePortsAttrs(), this.on(\"change:inPorts change:outPorts\", this.updatePortsAttrs, this), this.constructor.__super__.constructor.__super__.initialize.apply(this, arguments);\n    },\n    updatePortsAttrs: function updatePortsAttrs(t) {\n      if (this._portSelectors) {\n        var e = joint.util.omit(this.get(\"attrs\"), this._portSelectors);\n        this.set(\"attrs\", e, {\n          silent: !0\n        });\n      }\n\n      this._portSelectors = [];\n      var r = {};\n      joint.util.toArray(this.get(\"inPorts\")).forEach(function (t, e, i) {\n        var n = this.getPortAttrs(t, e, i.length, \".inPorts\", \"in\");\n        this._portSelectors = this._portSelectors.concat(Object.keys(n)), joint.util.assign(r, n);\n      }, this), joint.util.toArray(this.get(\"outPorts\")).forEach(function (t, e, i) {\n        var n = this.getPortAttrs(t, e, i.length, \".outPorts\", \"out\");\n        this._portSelectors = this._portSelectors.concat(Object.keys(n)), joint.util.assign(r, n);\n      }, this), this.attr(r, {\n        silent: !0\n      }), this.processPorts(), this.trigger(\"process:ports\");\n    },\n    getPortSelector: function getPortSelector(t) {\n      var e = \".inPorts\",\n          i = this.get(\"inPorts\").indexOf(t);\n      if (i < 0 && (e = \".outPorts\", (i = this.get(\"outPorts\").indexOf(t)) < 0)) throw new Error(\"getPortSelector(): Port doesn't exist.\");\n      return e + \">g:nth-child(\" + (i + 1) + \")>.port-body\";\n    }\n  }, joint.shapes.basic.PortsViewInterface = {\n    initialize: function initialize() {\n      this.listenTo(this.model, \"process:ports\", this.update), joint.dia.ElementView.prototype.initialize.apply(this, arguments);\n    },\n    update: function update() {\n      this.renderPorts(), joint.dia.ElementView.prototype.update.apply(this, arguments);\n    },\n    renderPorts: function renderPorts() {\n      var i = this.$(\".inPorts\").empty(),\n          n = this.$(\".outPorts\").empty(),\n          r = joint.util.template(this.model.portMarkup),\n          t = joint.util.toArray(this.model.ports);\n      t.filter(function (t) {\n        return \"in\" === t.type;\n      }).forEach(function (t, e) {\n        i.append(V(r({\n          id: e,\n          port: t\n        })).node);\n      }), t.filter(function (t) {\n        return \"out\" === t.type;\n      }).forEach(function (t, e) {\n        n.append(V(r({\n          id: e,\n          port: t\n        })).node);\n      });\n    }\n  }, joint.shapes.basic.Generic.define(\"basic.TextBlock\", {\n    attrs: {\n      rect: {\n        fill: \"#ffffff\",\n        stroke: \"#000000\",\n        width: 80,\n        height: 100\n      },\n      text: {\n        fill: \"#000000\",\n        \"font-size\": 14,\n        \"font-family\": \"Arial, helvetica, sans-serif\"\n      },\n      \".content\": {\n        text: \"\",\n        \"ref-x\": .5,\n        \"ref-y\": .5,\n        \"y-alignment\": \"middle\",\n        \"x-alignment\": \"middle\"\n      }\n    },\n    content: \"\"\n  }, {\n    markup: ['<g class=\"rotatable\">', '<g class=\"scalable\"><rect/></g>', joint.env.test(\"svgforeignobject\") ? '<foreignObject class=\"fobj\"><body xmlns=\"http://www.w3.org/1999/xhtml\"><div class=\"content\"/></body></foreignObject>' : '<text class=\"content\"/>', \"</g>\"].join(\"\"),\n    initialize: function initialize() {\n      this.listenTo(this, \"change:size\", this.updateSize), this.listenTo(this, \"change:content\", this.updateContent), this.updateSize(this, this.get(\"size\")), this.updateContent(this, this.get(\"content\")), joint.shapes.basic.Generic.prototype.initialize.apply(this, arguments);\n    },\n    updateSize: function updateSize(t, e) {\n      this.attr({\n        \".fobj\": joint.util.assign({}, e),\n        div: {\n          style: joint.util.assign({}, e)\n        }\n      });\n    },\n    updateContent: function updateContent(t, e) {\n      joint.env.test(\"svgforeignobject\") ? this.attr({\n        \".content\": {\n          html: joint.util.sanitizeHTML(e)\n        }\n      }) : this.attr({\n        \".content\": {\n          text: e\n        }\n      });\n    },\n    setForeignObjectSize: function setForeignObjectSize() {\n      this.updateSize.apply(this, arguments);\n    },\n    setDivContent: function setDivContent() {\n      this.updateContent.apply(this, arguments);\n    }\n  }), joint.shapes.basic.TextBlockView = joint.dia.ElementView.extend({\n    initialize: function initialize() {\n      joint.dia.ElementView.prototype.initialize.apply(this, arguments), this.noSVGForeignObjectElement = !joint.env.test(\"svgforeignobject\"), joint.env.test(\"svgforeignobject\") || this.listenTo(this.model, \"change:content change:size\", function (t) {\n        this.updateContent(t);\n      });\n    },\n    update: function update(t, e) {\n      var i = this.model;\n      if (joint.env.test(\"svgforeignobject\")) joint.dia.ElementView.prototype.update.call(this, i, e);else {\n        var n = joint.util.omit(e || i.get(\"attrs\"), \".content\");\n        joint.dia.ElementView.prototype.update.call(this, i, n), e && !joint.util.has(e, \".content\") || this.updateContent(i, e);\n      }\n    },\n    updateContent: function updateContent(t, e) {\n      var i = joint.util.merge({}, (e || t.get(\"attrs\"))[\".content\"]);\n      i = joint.util.omit(i, \"text\");\n      var n = joint.util.breakText(t.get(\"content\"), t.get(\"size\"), i, {\n        svgDocument: this.paper.svg\n      }),\n          r = joint.util.setByPath({}, \".content\", i, \"/\");\n      r[\".content\"].text = n, joint.dia.ElementView.prototype.update.call(this, t, r);\n    }\n  }), function (a, y, t, b) {\n    \"use strict\";\n\n    var e = a.Element;\n    e.define(\"standard.Rectangle\", {\n      attrs: {\n        body: {\n          refWidth: \"100%\",\n          refHeight: \"100%\",\n          strokeWidth: 2,\n          stroke: \"#000000\",\n          fill: \"#FFFFFF\"\n        },\n        label: {\n          textVerticalAnchor: \"middle\",\n          textAnchor: \"middle\",\n          refX: \"50%\",\n          refY: \"50%\",\n          fontSize: 14,\n          fill: \"#333333\"\n        }\n      }\n    }, {\n      markup: [{\n        tagName: \"rect\",\n        selector: \"body\"\n      }, {\n        tagName: \"text\",\n        selector: \"label\"\n      }]\n    }), e.define(\"standard.Circle\", {\n      attrs: {\n        body: {\n          refCx: \"50%\",\n          refCy: \"50%\",\n          refR: \"50%\",\n          strokeWidth: 2,\n          stroke: \"#333333\",\n          fill: \"#FFFFFF\"\n        },\n        label: {\n          textVerticalAnchor: \"middle\",\n          textAnchor: \"middle\",\n          refX: \"50%\",\n          refY: \"50%\",\n          fontSize: 14,\n          fill: \"#333333\"\n        }\n      }\n    }, {\n      markup: [{\n        tagName: \"circle\",\n        selector: \"body\"\n      }, {\n        tagName: \"text\",\n        selector: \"label\"\n      }]\n    }), e.define(\"standard.Ellipse\", {\n      attrs: {\n        body: {\n          refCx: \"50%\",\n          refCy: \"50%\",\n          refRx: \"50%\",\n          refRy: \"50%\",\n          strokeWidth: 2,\n          stroke: \"#333333\",\n          fill: \"#FFFFFF\"\n        },\n        label: {\n          textVerticalAnchor: \"middle\",\n          textAnchor: \"middle\",\n          refX: \"50%\",\n          refY: \"50%\",\n          fontSize: 14,\n          fill: \"#333333\"\n        }\n      }\n    }, {\n      markup: [{\n        tagName: \"ellipse\",\n        selector: \"body\"\n      }, {\n        tagName: \"text\",\n        selector: \"label\"\n      }]\n    }), e.define(\"standard.Path\", {\n      attrs: {\n        body: {\n          refD: \"M 0 0 L 10 0 10 10 0 10 Z\",\n          strokeWidth: 2,\n          stroke: \"#333333\",\n          fill: \"#FFFFFF\"\n        },\n        label: {\n          textVerticalAnchor: \"middle\",\n          textAnchor: \"middle\",\n          refX: \"50%\",\n          refY: \"50%\",\n          fontSize: 14,\n          fill: \"#333333\"\n        }\n      }\n    }, {\n      markup: [{\n        tagName: \"path\",\n        selector: \"body\"\n      }, {\n        tagName: \"text\",\n        selector: \"label\"\n      }]\n    }), e.define(\"standard.Polygon\", {\n      attrs: {\n        body: {\n          refPoints: \"0 0 10 0 10 10 0 10\",\n          strokeWidth: 2,\n          stroke: \"#333333\",\n          fill: \"#FFFFFF\"\n        },\n        label: {\n          textVerticalAnchor: \"middle\",\n          textAnchor: \"middle\",\n          refX: \"50%\",\n          refY: \"50%\",\n          fontSize: 14,\n          fill: \"#333333\"\n        }\n      }\n    }, {\n      markup: [{\n        tagName: \"polygon\",\n        selector: \"body\"\n      }, {\n        tagName: \"text\",\n        selector: \"label\"\n      }]\n    }), e.define(\"standard.Polyline\", {\n      attrs: {\n        body: {\n          refPoints: \"0 0 10 0 10 10 0 10 0 0\",\n          strokeWidth: 2,\n          stroke: \"#333333\",\n          fill: \"#FFFFFF\"\n        },\n        label: {\n          textVerticalAnchor: \"middle\",\n          textAnchor: \"middle\",\n          refX: \"50%\",\n          refY: \"50%\",\n          fontSize: 14,\n          fill: \"#333333\"\n        }\n      }\n    }, {\n      markup: [{\n        tagName: \"polyline\",\n        selector: \"body\"\n      }, {\n        tagName: \"text\",\n        selector: \"label\"\n      }]\n    }), e.define(\"standard.Image\", {\n      attrs: {\n        image: {\n          refWidth: \"100%\",\n          refHeight: \"100%\"\n        },\n        label: {\n          textVerticalAnchor: \"top\",\n          textAnchor: \"middle\",\n          refX: \"50%\",\n          refY: \"100%\",\n          refY2: 10,\n          fontSize: 14,\n          fill: \"#333333\"\n        }\n      }\n    }, {\n      markup: [{\n        tagName: \"image\",\n        selector: \"image\"\n      }, {\n        tagName: \"text\",\n        selector: \"label\"\n      }]\n    }), e.define(\"standard.BorderedImage\", {\n      attrs: {\n        border: {\n          refWidth: \"100%\",\n          refHeight: \"100%\",\n          stroke: \"#333333\",\n          strokeWidth: 2\n        },\n        background: {\n          refWidth: -1,\n          refHeight: -1,\n          x: .5,\n          y: .5,\n          fill: \"#FFFFFF\"\n        },\n        image: {\n          refWidth: -1,\n          refHeight: -1,\n          x: .5,\n          y: .5\n        },\n        label: {\n          textVerticalAnchor: \"top\",\n          textAnchor: \"middle\",\n          refX: \"50%\",\n          refY: \"100%\",\n          refY2: 10,\n          fontSize: 14,\n          fill: \"#333333\"\n        }\n      }\n    }, {\n      markup: [{\n        tagName: \"rect\",\n        selector: \"background\",\n        attributes: {\n          stroke: \"none\"\n        }\n      }, {\n        tagName: \"image\",\n        selector: \"image\"\n      }, {\n        tagName: \"rect\",\n        selector: \"border\",\n        attributes: {\n          fill: \"none\"\n        }\n      }, {\n        tagName: \"text\",\n        selector: \"label\"\n      }]\n    }), e.define(\"standard.EmbeddedImage\", {\n      attrs: {\n        body: {\n          refWidth: \"100%\",\n          refHeight: \"100%\",\n          stroke: \"#333333\",\n          fill: \"#FFFFFF\",\n          strokeWidth: 2\n        },\n        image: {\n          refWidth: \"30%\",\n          refHeight: -20,\n          x: 10,\n          y: 10,\n          preserveAspectRatio: \"xMidYMin\"\n        },\n        label: {\n          textVerticalAnchor: \"top\",\n          textAnchor: \"left\",\n          refX: \"30%\",\n          refX2: 20,\n          refY: 10,\n          fontSize: 14,\n          fill: \"#333333\"\n        }\n      }\n    }, {\n      markup: [{\n        tagName: \"rect\",\n        selector: \"body\"\n      }, {\n        tagName: \"image\",\n        selector: \"image\"\n      }, {\n        tagName: \"text\",\n        selector: \"label\"\n      }]\n    }), e.define(\"standard.InscribedImage\", {\n      attrs: {\n        border: {\n          refRx: \"50%\",\n          refRy: \"50%\",\n          refCx: \"50%\",\n          refCy: \"50%\",\n          stroke: \"#333333\",\n          strokeWidth: 2\n        },\n        background: {\n          refRx: \"50%\",\n          refRy: \"50%\",\n          refCx: \"50%\",\n          refCy: \"50%\",\n          fill: \"#FFFFFF\"\n        },\n        image: {\n          refWidth: \"68%\",\n          refHeight: \"68%\",\n          refX: \"16%\",\n          refY: \"16%\",\n          preserveAspectRatio: \"xMidYMid\"\n        },\n        label: {\n          textVerticalAnchor: \"top\",\n          textAnchor: \"middle\",\n          refX: \"50%\",\n          refY: \"100%\",\n          refY2: 10,\n          fontSize: 14,\n          fill: \"#333333\"\n        }\n      }\n    }, {\n      markup: [{\n        tagName: \"ellipse\",\n        selector: \"background\"\n      }, {\n        tagName: \"image\",\n        selector: \"image\"\n      }, {\n        tagName: \"ellipse\",\n        selector: \"border\",\n        attributes: {\n          fill: \"none\"\n        }\n      }, {\n        tagName: \"text\",\n        selector: \"label\"\n      }]\n    }), e.define(\"standard.HeaderedRectangle\", {\n      attrs: {\n        body: {\n          refWidth: \"100%\",\n          refHeight: \"100%\",\n          strokeWidth: 2,\n          stroke: \"#000000\",\n          fill: \"#FFFFFF\"\n        },\n        header: {\n          refWidth: \"100%\",\n          height: 30,\n          strokeWidth: 2,\n          stroke: \"#000000\",\n          fill: \"#FFFFFF\"\n        },\n        headerText: {\n          textVerticalAnchor: \"middle\",\n          textAnchor: \"middle\",\n          refX: \"50%\",\n          refY: 15,\n          fontSize: 16,\n          fill: \"#333333\"\n        },\n        bodyText: {\n          textVerticalAnchor: \"middle\",\n          textAnchor: \"middle\",\n          refX: \"50%\",\n          refY: \"50%\",\n          refY2: 15,\n          fontSize: 14,\n          fill: \"#333333\"\n        }\n      }\n    }, {\n      markup: [{\n        tagName: \"rect\",\n        selector: \"body\"\n      }, {\n        tagName: \"rect\",\n        selector: \"header\"\n      }, {\n        tagName: \"text\",\n        selector: \"headerText\"\n      }, {\n        tagName: \"text\",\n        selector: \"bodyText\"\n      }]\n    });\n    joint.dia.Element.define(\"standard.Cylinder\", {\n      attrs: {\n        body: {\n          lateralArea: 10,\n          fill: \"#FFFFFF\",\n          stroke: \"#333333\",\n          strokeWidth: 2\n        },\n        top: {\n          refCx: \"50%\",\n          cy: 10,\n          refRx: \"50%\",\n          ry: 10,\n          fill: \"#FFFFFF\",\n          stroke: \"#333333\",\n          strokeWidth: 2\n        },\n        label: {\n          textVerticalAnchor: \"middle\",\n          textAnchor: \"middle\",\n          refX: \"50%\",\n          refY: \"100%\",\n          refY2: 15,\n          fontSize: 14,\n          fill: \"#333333\"\n        }\n      }\n    }, {\n      markup: [{\n        tagName: \"path\",\n        selector: \"body\"\n      }, {\n        tagName: \"ellipse\",\n        selector: \"top\"\n      }, {\n        tagName: \"text\",\n        selector: \"label\"\n      }],\n      topRy: function topRy(t, e) {\n        if (void 0 === t) return this.attr(\"body/lateralArea\");\n        var i = {\n          lateralArea: t\n        },\n            n = y.isPercentage(t) ? {\n          refCy: t,\n          refRy: t,\n          cy: null,\n          ry: null\n        } : {\n          refCy: null,\n          refRy: null,\n          cy: t,\n          ry: t\n        };\n        return this.attr({\n          body: i,\n          top: n\n        }, e);\n      }\n    }, {\n      attributes: {\n        lateralArea: {\n          set: function set(t, e) {\n            var i = y.isPercentage(t);\n            i && (t = parseFloat(t) / 100);\n            var n = e.x,\n                r = e.y,\n                o = e.width,\n                s = e.height,\n                a = o / 2,\n                l = i ? s * t : t,\n                h = b.KAPPA,\n                u = h * a,\n                c = h * (i ? s * t : t),\n                d = n + o / 2,\n                f = n + o,\n                g = r + l,\n                p = g - l,\n                m = r + s - l,\n                v = r + s;\n            return {\n              d: [\"M\", n, g, \"L\", n, m, \"C\", n, m + c, d - u, v, d, v, \"C\", d + u, v, f, m + c, f, m, \"L\", f, g, \"C\", f, g - c, d + u, p, d, p, \"C\", d - u, p, n, g - c, n, g, \"Z\"].join(\" \")\n            };\n          }\n        }\n      }\n    });\n    var i = t.test(\"svgforeignobject\") ? {\n      tagName: \"foreignObject\",\n      selector: \"foreignObject\",\n      attributes: {\n        overflow: \"hidden\"\n      },\n      children: [{\n        tagName: \"div\",\n        namespaceURI: \"http://www.w3.org/1999/xhtml\",\n        selector: \"label\",\n        style: {\n          width: \"100%\",\n          height: \"100%\",\n          position: \"static\",\n          backgroundColor: \"transparent\",\n          textAlign: \"center\",\n          margin: 0,\n          padding: \"0px 5px\",\n          boxSizing: \"border-box\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"center\"\n        }\n      }]\n    } : {\n      tagName: \"text\",\n      selector: \"label\",\n      attributes: {\n        \"text-anchor\": \"middle\"\n      }\n    };\n    e.define(\"standard.TextBlock\", {\n      attrs: {\n        body: {\n          refWidth: \"100%\",\n          refHeight: \"100%\",\n          stroke: \"#333333\",\n          fill: \"#ffffff\",\n          strokeWidth: 2\n        },\n        foreignObject: {\n          refWidth: \"100%\",\n          refHeight: \"100%\"\n        },\n        label: {\n          style: {\n            fontSize: 14\n          }\n        }\n      }\n    }, {\n      markup: [{\n        tagName: \"rect\",\n        selector: \"body\"\n      }, i]\n    }, {\n      attributes: {\n        text: {\n          set: function set(t, e, i, n) {\n            if (!(i instanceof HTMLElement)) {\n              var r = n.style || {},\n                  o = {\n                text: t,\n                width: -5,\n                height: \"100%\"\n              },\n                  s = y.assign({\n                textVerticalAnchor: \"middle\"\n              }, r);\n              return a.attributes.textWrap.set.call(this, o, e, i, s), {\n                fill: r.color || null\n              };\n            }\n\n            i.textContent = t;\n          },\n          position: function position(t, e, i) {\n            if (i instanceof SVGElement) return e.center();\n          }\n        }\n      }\n    });\n    var n = a.Link;\n    n.define(\"standard.Link\", {\n      attrs: {\n        line: {\n          connection: !0,\n          stroke: \"#333333\",\n          strokeWidth: 2,\n          strokeLinejoin: \"round\",\n          targetMarker: {\n            type: \"path\",\n            d: \"M 10 -5 0 0 10 5 z\"\n          }\n        },\n        wrapper: {\n          connection: !0,\n          strokeWidth: 10,\n          strokeLinejoin: \"round\"\n        }\n      }\n    }, {\n      markup: [{\n        tagName: \"path\",\n        selector: \"wrapper\",\n        attributes: {\n          fill: \"none\",\n          cursor: \"pointer\",\n          stroke: \"transparent\"\n        }\n      }, {\n        tagName: \"path\",\n        selector: \"line\",\n        attributes: {\n          fill: \"none\",\n          \"pointer-events\": \"none\"\n        }\n      }]\n    }), n.define(\"standard.DoubleLink\", {\n      attrs: {\n        line: {\n          connection: !0,\n          stroke: \"#DDDDDD\",\n          strokeWidth: 4,\n          strokeLinejoin: \"round\",\n          targetMarker: {\n            type: \"path\",\n            stroke: \"#000000\",\n            d: \"M 10 -3 10 -10 -2 0 10 10 10 3\"\n          }\n        },\n        outline: {\n          connection: !0,\n          stroke: \"#000000\",\n          strokeWidth: 6,\n          strokeLinejoin: \"round\"\n        }\n      }\n    }, {\n      markup: [{\n        tagName: \"path\",\n        selector: \"outline\",\n        attributes: {\n          fill: \"none\"\n        }\n      }, {\n        tagName: \"path\",\n        selector: \"line\",\n        attributes: {\n          fill: \"none\"\n        }\n      }]\n    }), n.define(\"standard.ShadowLink\", {\n      attrs: {\n        line: {\n          connection: !0,\n          stroke: \"#FF0000\",\n          strokeWidth: 20,\n          strokeLinejoin: \"round\",\n          targetMarker: {\n            type: \"path\",\n            stroke: \"none\",\n            d: \"M 0 -10 -10 0 0 10 z\"\n          },\n          sourceMarker: {\n            type: \"path\",\n            stroke: \"none\",\n            d: \"M -10 -10 0 0 -10 10 0 10 0 -10 z\"\n          }\n        },\n        shadow: {\n          connection: !0,\n          refX: 3,\n          refY: 6,\n          stroke: \"#000000\",\n          strokeOpacity: .2,\n          strokeWidth: 20,\n          strokeLinejoin: \"round\",\n          targetMarker: {\n            type: \"path\",\n            d: \"M 0 -10 -10 0 0 10 z\",\n            stroke: \"none\"\n          },\n          sourceMarker: {\n            type: \"path\",\n            stroke: \"none\",\n            d: \"M -10 -10 0 0 -10 10 0 10 0 -10 z\"\n          }\n        }\n      }\n    }, {\n      markup: [{\n        tagName: \"path\",\n        selector: \"shadow\",\n        attributes: {\n          fill: \"none\"\n        }\n      }, {\n        tagName: \"path\",\n        selector: \"line\",\n        attributes: {\n          fill: \"none\"\n        }\n      }]\n    });\n  }(joint.dia, joint.util, joint.env, V), joint.routers.manhattan = function (X, n, Y) {\n    \"use strict\";\n\n    var r = {\n      step: 10,\n      maximumLoops: 2e3,\n      precision: 1,\n      maxAllowedDirectionChange: 90,\n      perpendicular: !0,\n      excludeEnds: [],\n      excludeTypes: [\"basic.Text\"],\n      startDirections: [\"top\", \"right\", \"bottom\", \"left\"],\n      endDirections: [\"top\", \"right\", \"bottom\", \"left\"],\n      directionMap: {\n        top: {\n          x: 0,\n          y: -1\n        },\n        right: {\n          x: 1,\n          y: 0\n        },\n        bottom: {\n          x: 0,\n          y: 1\n        },\n        left: {\n          x: -1,\n          y: 0\n        }\n      },\n      cost: function cost() {\n        return this.step;\n      },\n      directions: function directions() {\n        var t = this.step,\n            e = this.cost();\n        return [{\n          offsetX: t,\n          offsetY: 0,\n          cost: e\n        }, {\n          offsetX: 0,\n          offsetY: t,\n          cost: e\n        }, {\n          offsetX: -t,\n          offsetY: 0,\n          cost: e\n        }, {\n          offsetX: 0,\n          offsetY: -t,\n          cost: e\n        }];\n      },\n      penalties: function penalties() {\n        return {\n          0: 0,\n          45: this.step / 2,\n          90: this.step / 2\n        };\n      },\n      paddingBox: function paddingBox() {\n        var t = this.step;\n        return {\n          x: -t,\n          y: -t,\n          width: 2 * t,\n          height: 2 * t\n        };\n      },\n      fallbackRouter: function fallbackRouter(t, e, i) {\n        if (!Y.isFunction(n.routers.orthogonal)) throw new Error(\"Manhattan requires the orthogonal router as default fallback.\");\n        return n.routers.orthogonal(t, Y.assign({}, r, e), i);\n      },\n      fallbackRoute: function fallbackRoute(t, e, i) {\n        return null;\n      },\n      draggingRoute: null\n    };\n\n    function y(t) {\n      this.map = {}, this.options = t, this.mapGridSize = 100;\n    }\n\n    function W() {\n      this.items = [], this.hash = {}, this.values = {}, this.OPEN = 1, this.CLOSE = 2;\n    }\n\n    function b(t, e) {\n      return e && e.paddingBox ? t.sourceBBox.clone().moveAndExpand(e.paddingBox) : t.sourceBBox.clone();\n    }\n\n    function J(t, e) {\n      return e && e.paddingBox ? t.targetBBox.clone().moveAndExpand(e.paddingBox) : t.targetBBox.clone();\n    }\n\n    function Z(t, e) {\n      return t.sourceAnchor ? t.sourceAnchor : b(t, e).center();\n    }\n\n    function K(t, e, i, n, r) {\n      var o,\n          s,\n          a,\n          l,\n          h,\n          u,\n          c,\n          d,\n          f,\n          g,\n          p = 360 / i,\n          m = t.theta((o = t, s = e, a = n, l = r.step, h = s.x - o.x, u = s.y - o.y, c = h / a.x, d = u / a.y, f = c * l, g = d * l, new X.Point(o.x + f, o.y + g))),\n          v = X.normalizeAngle(m + p / 2);\n      return p * Math.floor(v / p);\n    }\n\n    function Q(t, e) {\n      var i = Math.abs(t - e);\n      return 180 < i ? 360 - i : i;\n    }\n\n    function tt(t, e) {\n      if (!t) return e;\n      var i = Math.abs(t),\n          n = Math.round(i / e);\n      return n ? e + (i - n * e) / n : i;\n    }\n\n    function et(t, e) {\n      return t.round(e);\n    }\n\n    function it(t, e, i) {\n      return et((n = t.clone(), o = (r = e).source, s = X.snapToGrid(n.x - o.x, r.x) + o.x, a = X.snapToGrid(n.y - o.y, r.y) + o.y, new X.Point(s, a)), i);\n      var n, r, o, s, a;\n    }\n\n    function nt(t) {\n      return t.clone().toString();\n    }\n\n    function g(t) {\n      return new X.Point(0 === t.x ? 0 : Math.abs(t.x) / t.x, 0 === t.y ? 0 : Math.abs(t.y) / t.y);\n    }\n\n    function rt(t, e, i, n, r, o, s) {\n      for (var a, l = [], h = g(r.difference(i)), u = nt(i), c = t[u]; c;) {\n        var d = g((a = e[u]).difference(c));\n        d.equals(h) || (l.unshift(a), h = d), c = t[u = nt(c)];\n      }\n\n      var f = e[u];\n      return g(f.difference(n)).equals(h) || l.unshift(f), l;\n    }\n\n    function ot(t, e) {\n      for (var i = 1 / 0, n = 0, r = e.length; n < r; n++) {\n        var o = t.manhattanDistance(e[n]);\n        o < i && (i = o);\n      }\n\n      return i;\n    }\n\n    function st(d, f, t, g, e) {\n      var p = e.precision,\n          m = e.directionMap,\n          v = d.difference(f.center()),\n          i = Y.isObject(m) ? Object.keys(m) : [],\n          y = Y.toArray(t),\n          n = i.reduce(function (t, e) {\n        if (y.includes(e)) {\n          for (var i, n = m[e], r = new X.Point(d.x + n.x * (Math.abs(v.x) + f.width), d.y + n.y * (Math.abs(v.y) + f.height)), o = new X.Line(d, r).intersect(f) || [], s = o.length, a = null, l = 0; l < s; l++) {\n            var h = o[l],\n                u = d.squaredDistance(h);\n            (void 0 === i || i < u) && (i = u, a = h);\n          }\n\n          if (a) {\n            var c = it(a, g, p);\n            f.containsPoint(c) && (c = it(c.offset(n.x * g.x, n.y * g.y), g, p)), t.push(c);\n          }\n        }\n\n        return t;\n      }, []);\n      return f.containsPoint(d) || n.push(it(d, g, p)), n;\n    }\n\n    function w(t, e, i, n) {\n      var r,\n          o,\n          s,\n          a,\n          l = n.precision;\n      r = t instanceof X.Rect ? et(Z(this, n).clone(), l) : et(t.clone(), l), o = e instanceof X.Rect ? et((s = this, a = n, s.targetAnchor ? s.targetAnchor : J(s, a).center()).clone(), l) : et(e.clone(), l);\n      var h,\n          u,\n          c,\n          d,\n          f,\n          g,\n          p,\n          m,\n          v,\n          y,\n          b = (h = n.step, c = o, {\n        source: (u = r).clone(),\n        x: tt(c.x - u.x, h),\n        y: tt(c.y - u.y, h)\n      });\n\n      if (g = t instanceof X.Rect ? st(d = r, t, n.startDirections, b, n) : [d = r], p = e instanceof X.Rect ? st(f = o, e, n.endDirections, b, n) : [f = o], g = g.filter(i.isPointAccessible, i), p = p.filter(i.isPointAccessible, i), 0 < g.length && 0 < p.length) {\n        for (var w = new W(), x = {}, k = {}, A = {}, j = 0, P = g.length; j < P; j++) {\n          var C = g[j],\n              V = nt(C);\n          w.add(V, ot(C, p)), x[V] = C, A[V] = 0;\n        }\n\n        var E,\n            M,\n            _ = n.previousDirectionAngle,\n            S = void 0 === _,\n            B = n.directions;\n        m = b, y = (v = n).step, Y.toArray(v.directions).forEach(function (t) {\n          t.gridOffsetX = t.offsetX / y * m.x, t.gridOffsetY = t.offsetY / y * m.y;\n        });\n\n        for (var T = B.length, N = Y.toArray(p).reduce(function (t, e) {\n          var i = nt(e);\n          return t.push(i), t;\n        }, []), L = n.maximumLoops; !w.isEmpty() && 0 < L;) {\n          var F,\n              R = w.pop(),\n              D = x[R],\n              z = k[R],\n              O = A[R],\n              I = void 0 === z,\n              G = D.equals(d);\n          if (F = I ? S ? G ? null : K(d, D, T, b, n) : _ : K(z, D, T, b, n), 0 <= N.indexOf(R)) return n.previousDirectionAngle = F, rt(k, x, D, d, f);\n\n          for (j = 0; j < T; j++) {\n            var $ = (E = B[j]).angle;\n\n            if (M = Q(F, $), S && G || !(M > n.maxAllowedDirectionChange)) {\n              var q = it(D.clone().offset(E.gridOffsetX, E.gridOffsetY), b, l),\n                  H = nt(q);\n\n              if (!w.isClose(H) && i.isPointAccessible(q)) {\n                if (0 <= N.indexOf(H)) if (!q.equals(f)) if (Q($, K(q, f, T, b, n)) > n.maxAllowedDirectionChange) continue;\n                var U = O + E.cost + (G ? 0 : n.penalties[M]);\n                (!w.isOpen(H) || U < A[H]) && (x[H] = q, k[H] = D, A[H] = U, w.add(H, U + ot(q, p)));\n              }\n            }\n          }\n\n          L--;\n        }\n      }\n\n      return n.fallbackRoute.call(this, d, f, n);\n    }\n\n    function o(t, e, i) {\n      !function (t) {\n        if (t.directions = Y.result(t, \"directions\"), t.penalties = Y.result(t, \"penalties\"), t.paddingBox = Y.result(t, \"paddingBox\"), t.padding = Y.result(t, \"padding\"), t.padding) {\n          var e = Y.normalizeSides(t.padding);\n          t.paddingBox = {\n            x: -e.left,\n            y: -e.top,\n            width: e.left + e.right,\n            height: e.top + e.bottom\n          };\n        }\n\n        Y.toArray(t.directions).forEach(function (t) {\n          var e = new X.Point(0, 0),\n              i = new X.Point(t.offsetX, t.offsetY);\n          t.angle = X.normalizeAngle(e.theta(i));\n        });\n      }(e), i.options.perpendicular = !!e.perpendicular;\n\n      for (var n, r, o = b(i, e), s = J(i, e), a = Z(i, e), l = new y(e).build(i.paper.model, i.model), h = Y.toArray(t).map(X.Point), u = [], c = a, d = 0, f = h.length; d <= f; d++) {\n        var g = null;\n        if (r = n || o, !(n = h[d])) if (n = s, (!i.model.get(\"source\").id || !i.model.get(\"target\").id) && Y.isFunction(e.draggingRoute)) {\n          var p = r === o ? a : r,\n              m = n.origin();\n          g = e.draggingRoute.call(i, p, m, e);\n        }\n        if (null === (g = g || w.call(i, r, n, l, e))) return e.fallbackRouter(t, e, i);\n        var v = g[0];\n        v && v.equals(c) && g.shift(), c = g[g.length - 1] || c, Array.prototype.push.apply(u, g);\n      }\n\n      return u;\n    }\n\n    return y.prototype.build = function (r, o) {\n      var c = this.options,\n          d = Y.toArray(c.excludeEnds).reduce(function (t, e) {\n        var i = o.get(e);\n\n        if (i) {\n          var n = r.getCell(i.id);\n          n && t.push(n);\n        }\n\n        return t;\n      }, []),\n          f = [],\n          t = r.getCell(o.get(\"source\").id);\n      t && (f = Y.union(f, t.getAncestors().map(function (t) {\n        return t.id;\n      })));\n      var e = r.getCell(o.get(\"target\").id);\n      e && (f = Y.union(f, e.getAncestors().map(function (t) {\n        return t.id;\n      })));\n      var g = this.mapGridSize;\n      return r.getElements().reduce(function (t, e) {\n        var i = Y.toArray(c.excludeTypes).includes(e.get(\"type\")),\n            n = d.find(function (t) {\n          return t.id === e.id;\n        }),\n            r = f.includes(e.id);\n        if (!(i || n || r)) for (var o = e.getBBox().moveAndExpand(c.paddingBox), s = o.origin().snapToGrid(g), a = o.corner().snapToGrid(g), l = s.x; l <= a.x; l += g) {\n          for (var h = s.y; h <= a.y; h += g) {\n            var u = l + \"@\" + h;\n            t[u] = t[u] || [], t[u].push(o);\n          }\n        }\n        return t;\n      }, this.map), this;\n    }, y.prototype.isPointAccessible = function (e) {\n      var t = e.clone().snapToGrid(this.mapGridSize).toString();\n      return Y.toArray(this.map[t]).every(function (t) {\n        return !t.containsPoint(e);\n      });\n    }, W.prototype.add = function (t, e) {\n      this.hash[t] ? this.items.splice(this.items.indexOf(t), 1) : this.hash[t] = this.OPEN, this.values[t] = e;\n      var i = n.util.sortedIndex(this.items, t, function (t) {\n        return this.values[t];\n      }.bind(this));\n      this.items.splice(i, 0, t);\n    }, W.prototype.remove = function (t) {\n      this.hash[t] = this.CLOSE;\n    }, W.prototype.isOpen = function (t) {\n      return this.hash[t] === this.OPEN;\n    }, W.prototype.isClose = function (t) {\n      return this.hash[t] === this.CLOSE;\n    }, W.prototype.isEmpty = function () {\n      return 0 === this.items.length;\n    }, W.prototype.pop = function () {\n      var t = this.items.shift();\n      return this.remove(t), t;\n    }, function (t, e, i) {\n      return o(t, Y.assign({}, r, e), i);\n    };\n  }(g, joint, joint.util), joint.routers.metro = function (n) {\n    var r = {\n      maxAllowedDirectionChange: 45,\n      diagonalCost: function diagonalCost() {\n        var t = this.step;\n        return Math.ceil(Math.sqrt(t * t << 1));\n      },\n      directions: function directions() {\n        var t = this.step,\n            e = this.cost(),\n            i = this.diagonalCost();\n        return [{\n          offsetX: t,\n          offsetY: 0,\n          cost: e\n        }, {\n          offsetX: t,\n          offsetY: t,\n          cost: i\n        }, {\n          offsetX: 0,\n          offsetY: t,\n          cost: e\n        }, {\n          offsetX: -t,\n          offsetY: t,\n          cost: i\n        }, {\n          offsetX: -t,\n          offsetY: 0,\n          cost: e\n        }, {\n          offsetX: -t,\n          offsetY: -t,\n          cost: i\n        }, {\n          offsetX: 0,\n          offsetY: -t,\n          cost: e\n        }, {\n          offsetX: t,\n          offsetY: -t,\n          cost: i\n        }];\n      },\n      fallbackRoute: function fallbackRoute(t, e, i) {\n        var n = t.theta(e),\n            r = [],\n            o = {\n          x: e.x,\n          y: t.y\n        },\n            s = {\n          x: t.x,\n          y: e.y\n        };\n\n        if (90 < n % 180) {\n          var a = o;\n          o = s, s = a;\n        }\n\n        var l = n % 90 < 45 ? o : s,\n            h = new g.Line(t, l),\n            u = 90 * Math.ceil(n / 90),\n            c = g.Point.fromPolar(h.squaredLength(), g.toRad(u + 135), l),\n            d = new g.Line(e, c),\n            f = h.intersection(d),\n            p = f || e,\n            m = f ? p : t,\n            v = 360 / i.directions.length,\n            y = m.theta(e),\n            b = g.normalizeAngle(y + v / 2),\n            w = v * Math.floor(b / v);\n        return i.previousDirectionAngle = w, p && r.push(p.round()), r.push(e), r;\n      }\n    };\n    return function (t, e, i) {\n      if (!n.isFunction(joint.routers.manhattan)) throw new Error(\"Metro requires the manhattan router.\");\n      return joint.routers.manhattan(t, n.assign({}, r, e), i);\n    };\n  }(joint.util), joint.routers.normal = function (t, e, i) {\n    return t;\n  }, joint.routers.oneSide = function (t, e, i) {\n    var n,\n        r,\n        o,\n        s = e.side || \"bottom\",\n        a = joint.util.normalizeSides(e.padding || 40),\n        l = i.sourceBBox,\n        h = i.targetBBox,\n        u = l.center(),\n        c = h.center();\n\n    switch (s) {\n      case \"bottom\":\n        o = 1, n = \"y\", r = \"height\";\n        break;\n\n      case \"top\":\n        o = -1, n = \"y\", r = \"height\";\n        break;\n\n      case \"left\":\n        o = -1, n = \"x\", r = \"width\";\n        break;\n\n      case \"right\":\n        o = 1, n = \"x\", r = \"width\";\n        break;\n\n      default:\n        throw new Error(\"Router: invalid side\");\n    }\n\n    return u[n] += o * (l[r] / 2 + a[s]), c[n] += o * (h[r] / 2 + a[s]), 0 < o * (u[n] - c[n]) ? c[n] = u[n] : u[n] = c[n], [u].concat(t, c);\n  }, joint.routers.orthogonal = function (x) {\n    var h = {\n      N: \"S\",\n      S: \"N\",\n      E: \"W\",\n      W: \"E\"\n    },\n        f = {\n      N: -Math.PI / 2 * 3,\n      S: -Math.PI / 2,\n      E: 0,\n      W: Math.PI\n    };\n\n    function p(t, e, i) {\n      var n = new g.Point(t.x, e.y);\n      return i.containsPoint(n) && (n = new g.Point(e.x, t.y)), n;\n    }\n\n    function d(t, e) {\n      return t[\"W\" === e || \"E\" === e ? \"width\" : \"height\"];\n    }\n\n    function k(t, e) {\n      return t.x === e.x ? t.y > e.y ? \"N\" : \"S\" : t.y === e.y ? t.x > e.x ? \"W\" : \"E\" : null;\n    }\n\n    function A(t) {\n      return new g.Rect(t.x, t.y, 0, 0);\n    }\n\n    function j(t) {\n      var e = x.normalizeSides(t.padding || t.elementPadding || 20);\n      return {\n        x: -e.left,\n        y: -e.top,\n        width: e.left + e.right,\n        height: e.top + e.bottom\n      };\n    }\n\n    function P(t, e) {\n      return t.sourceBBox.clone().moveAndExpand(j(e));\n    }\n\n    function C(t, e) {\n      return t.targetBBox.clone().moveAndExpand(j(e));\n    }\n\n    function V(t, e, i) {\n      var n = new g.Point(t.x, e.y),\n          r = new g.Point(e.x, t.y),\n          o = k(t, n),\n          s = k(t, r),\n          a = h[i],\n          l = o === i || o !== a && (s === a || s !== i) ? n : r;\n      return {\n        points: [l],\n        direction: k(l, e)\n      };\n    }\n\n    function E(t, e, i) {\n      var n = p(t, e, i);\n      return {\n        points: [n],\n        direction: k(n, e)\n      };\n    }\n\n    function M(e, t, i, n) {\n      var r,\n          o = {},\n          s = [new g.Point(e.x, t.y), new g.Point(t.x, e.y)],\n          a = s.filter(function (t) {\n        return !i.containsPoint(t);\n      }),\n          l = a.filter(function (t) {\n        return k(t, e) !== n;\n      });\n      if (0 < l.length) r = (r = l.filter(function (t) {\n        return k(e, t) === n;\n      }).pop()) || l[0], o.points = [r], o.direction = k(r, t);else {\n        r = x.difference(s, a)[0];\n        var h = new g.Point(t).move(r, -d(i, n) / 2),\n            u = p(h, e, i);\n        o.points = [u, h], o.direction = k(h, t);\n      }\n      return o;\n    }\n\n    function _(t, e, i, n) {\n      var r = E(e, t, n),\n          o = r.points[0];\n\n      if (i.containsPoint(o)) {\n        var s = (r = E(t, e, i)).points[0];\n\n        if (n.containsPoint(s)) {\n          var a = new g.Point(t).move(s, -d(i, k(t, s)) / 2),\n              l = new g.Point(e).move(o, -d(n, k(e, o)) / 2),\n              h = new g.Line(a, l).midpoint(),\n              u = E(t, h, i),\n              c = V(h, e, u.direction);\n          r.points = [u.points[0], c.points[0]], r.direction = c.direction;\n        }\n      }\n\n      return r;\n    }\n\n    function S(t, e, i, n, r) {\n      var o,\n          s,\n          a,\n          l = {},\n          h = i.union(n).inflate(1),\n          u = h.center().distance(e) > h.center().distance(t),\n          c = u ? e : t,\n          d = u ? t : e;\n      return s = p(o = r ? (o = g.Point.fromPolar(h.width + h.height, f[r], c), h.pointNearestToPoint(o).move(o, -1)) : h.pointNearestToPoint(c).move(c, 1), d, h), o.round().equals(s.round()) ? (s = g.Point.fromPolar(h.width + h.height, g.toRad(o.theta(c)) + Math.PI / 2, d), a = p(o, s = h.pointNearestToPoint(s).move(d, 1).round(), h), l.points = u ? [s, a, o] : [o, a, s]) : l.points = u ? [s, o] : [o, s], l.direction = k(u ? o : s, e), l;\n    }\n\n    return function (t, e, i) {\n      var n,\n          r,\n          o,\n          s,\n          a,\n          l = P(i, e),\n          h = C(i, e),\n          u = (r = e, (n = i).sourceAnchor ? n.sourceAnchor : P(n, r).center()),\n          c = (s = e, (o = i).targetAnchor ? o.targetAnchor : C(o, s).center());\n      l = l.union(A(u)), h = h.union(A(c)), (t = x.toArray(t).map(g.Point)).unshift(u), t.push(c);\n\n      for (var d = [], f = 0, p = t.length - 1; f < p; f++) {\n        var m = null,\n            v = t[f],\n            y = t[f + 1],\n            b = !!k(v, y);\n        if (0 === f) f + 1 === p ? l.intersect(h.clone().inflate(1)) ? m = S(v, y, l, h) : b || (m = _(v, y, l, h)) : l.containsPoint(y) ? m = S(v, y, l, A(y).moveAndExpand(j(e))) : b || (m = E(v, y, l));else if (f + 1 === p) {\n          var w = b && k(y, v) === a;\n          h.containsPoint(v) || w ? m = S(v, y, A(v).moveAndExpand(j(e)), h, a) : b || (m = M(v, y, h, a));\n        } else b || (m = V(v, y, a));\n        a = m ? (Array.prototype.push.apply(d, m.points), m.direction) : k(v, y), f + 1 < p && d.push(y);\n      }\n\n      return d;\n    };\n  }(joint.util), joint.connectors.normal = function (t, e, i, n) {\n    var r = n && n.raw,\n        o = [t].concat(i).concat([e]),\n        s = new g.Polyline(o),\n        a = new g.Path(s);\n    return r ? a : a.serialize();\n  }, joint.connectors.rounded = function (t, e, i, n) {\n    n || (n = {});\n    var r,\n        o = n.radius || 10,\n        s = n.raw,\n        a = new g.Path();\n    r = g.Path.createSegment(\"M\", t), a.appendSegment(r);\n\n    for (var l, h, u, c, d, f, p, m, v, y, b, w = 0, x = i.length; w < x; w++) {\n      l = new g.Point(i[w]), h = i[w - 1] || t, u = i[w + 1] || e, c = d || l.distance(h) / 2, d = l.distance(u) / 2, f = -Math.min(o, c), p = -Math.min(o, d), m = l.clone().move(h, f).round(), v = l.clone().move(u, p).round(), y = new g.Point(1 / 3 * m.x + 2 / 3 * l.x, 2 / 3 * l.y + 1 / 3 * m.y), b = new g.Point(1 / 3 * v.x + 2 / 3 * l.x, 2 / 3 * l.y + 1 / 3 * v.y), r = g.Path.createSegment(\"L\", m), a.appendSegment(r), r = g.Path.createSegment(\"C\", y, b, v), a.appendSegment(r);\n    }\n\n    return r = g.Path.createSegment(\"L\", e), a.appendSegment(r), s ? a : a.serialize();\n  }, joint.connectors.smooth = function (t, e, i, n) {\n    var r,\n        o = n && n.raw;\n\n    if (i && 0 !== i.length) {\n      var s = [t].concat(i).concat([e]),\n          a = g.Curve.throughPoints(s);\n      r = new g.Path(a);\n    } else {\n      var l;\n\n      if (r = new g.Path(), l = g.Path.createSegment(\"M\", t), r.appendSegment(l), Math.abs(t.x - e.x) >= Math.abs(t.y - e.y)) {\n        var h = (t.x + e.x) / 2;\n        l = g.Path.createSegment(\"C\", h, t.y, h, e.y, e.x, e.y), r.appendSegment(l);\n      } else {\n        var u = (t.y + e.y) / 2;\n        l = g.Path.createSegment(\"C\", t.x, u, e.x, u, e.x, e.y), r.appendSegment(l);\n      }\n    }\n\n    return o ? r : r.serialize();\n  }, joint.connectors.jumpover = function (w, x) {\n    var k = [\"arc\", \"gap\", \"cubic\"],\n        A = [\"smooth\"];\n\n    function j(t, e, i) {\n      var r = [].concat(t, i, e);\n      return r.reduce(function (t, e, i) {\n        var n = r[i + 1];\n        return null != n && (t[i] = w.line(e, n)), t;\n      }, []);\n    }\n\n    function P() {\n      for (var t = this._jumpOverUpdateList, e = 0; e < t.length; e++) {\n        t[e].update();\n      }\n    }\n\n    function C(t, e) {\n      return w.line(t, e).squaredLength();\n    }\n\n    function V(t, d, f) {\n      var g,\n          p = new w.Path();\n      return g = w.Path.createSegment(\"M\", t[0].start), p.appendSegment(g), joint.util.toArray(t).forEach(function (t, e) {\n        var i, n, r, o;\n\n        if (t.isJump) {\n          if (\"arc\" === f) {\n            i = -90, n = t.start.difference(t.end);\n            var s = Number(n.x < 0 || 0 === n.x && n.y < 0);\n            s && (i += 180);\n            var a,\n                l = t.midpoint(),\n                h = new w.Line(l, t.end).rotate(l, i);\n            r = (a = new w.Line(t.start, l)).pointAt(2 / 3).rotate(t.start, i), o = h.pointAt(1 / 3).rotate(h.end, -i), g = w.Path.createSegment(\"C\", r, o, h.end), p.appendSegment(g), a = new w.Line(l, t.end), r = h.pointAt(1 / 3).rotate(h.end, i), o = a.pointAt(1 / 3).rotate(t.end, -i), g = w.Path.createSegment(\"C\", r, o, t.end), p.appendSegment(g);\n          } else if (\"gap\" === f) g = w.Path.createSegment(\"M\", t.end), p.appendSegment(g);else if (\"cubic\" === f) {\n            i = t.start.theta(t.end);\n            var u = .6 * d,\n                c = 1.35 * d;\n            n = t.start.difference(t.end), (s = Number(n.x < 0 || 0 === n.x && n.y < 0)) && (c *= -1), r = w.Point(t.start.x + u, t.start.y + c).rotate(t.start, i), o = w.Point(t.end.x - u, t.end.y + c).rotate(t.end, i), g = w.Path.createSegment(\"C\", r, o, t.end), p.appendSegment(g);\n          }\n        } else g = w.Path.createSegment(\"L\", t.end), p.appendSegment(g);\n      }), p;\n    }\n\n    return function (t, e, i, n) {\n      var r, o;\n      null == (o = (r = this).paper._jumpOverUpdateList) && (o = r.paper._jumpOverUpdateList = [], r.paper.on(\"cell:pointerup\", P), r.paper.model.on(\"reset\", function () {\n        o = r.paper._jumpOverUpdateList = [];\n      })), o.indexOf(r) < 0 && (o.push(r), r.listenToOnce(r.model, \"change:connector remove\", function () {\n        o.splice(o.indexOf(r), 1);\n      }));\n      var s = n.raw,\n          a = n.size || 5,\n          l = n.jump && (\"\" + n.jump).toLowerCase(),\n          h = n.ignoreConnectors || A;\n      -1 === k.indexOf(l) && (l = k[0]);\n      var u = this.paper,\n          c = u.model.getLinks();\n      if (1 === c.length) return V(j(t, e, i), a, l);\n      var d = this.model,\n          f = c.indexOf(d),\n          g = u.options.defaultConnector || {},\n          p = c.filter(function (t, e) {\n        var i = t.get(\"connector\") || g;\n        return !x.toArray(h).includes(i.name) && (!(f < e) || \"jumpover\" !== i.name);\n      }),\n          m = p.map(function (t) {\n        return u.findViewByModel(t);\n      }),\n          v = j(t, e, i),\n          y = m.map(function (t) {\n        return null == t ? [] : t === this ? v : j(t.sourcePoint, t.targetPoint, t.route);\n      }, this),\n          b = V(v.reduce(function (t, s) {\n        var h,\n            u,\n            c,\n            e = p.reduce(function (t, e, i) {\n          if (e !== d) {\n            var n = (r = s, o = y[i], x.toArray(o).reduce(function (t, e) {\n              var i = r.intersection(e);\n              return i && t.push(i), t;\n            }, []));\n            t.push.apply(t, n);\n          }\n\n          var r, o;\n          return t;\n        }, []).sort(function (t, e) {\n          return C(s.start, t) - C(s.start, e);\n        });\n        return 0 < e.length ? t.push.apply(t, (h = s, c = a, (u = e).reduce(function (t, e, i) {\n          if (!0 === e.skip) return t;\n          var n = t.pop() || h,\n              r = w.point(e).move(n.start, -c),\n              o = w.point(e).move(n.start, +c),\n              s = u[i + 1];\n\n          if (null != s) {\n            var a = o.distance(s);\n            a <= c && (o = s.move(n.start, a), s.skip = !0);\n          } else if (r.distance(n.end) < 2 * c + 1) return t.push(n), t;\n\n          if (o.distance(n.start) < 2 * c + 1) return t.push(n), t;\n          var l = w.line(r, o);\n          return l.isJump = !0, t.push(w.line(n.start, r), l, w.line(o, n.end)), t;\n        }, []))) : t.push(s), t;\n      }, []), a, l);\n      return s ? b : b.serialize();\n    };\n  }(g, joint.util), function (r, o, s) {\n    function d(t, e, i) {\n      var n = t.toJSON();\n      return n.angle = e || 0, o.util.defaults({}, i, n);\n    }\n\n    function n(t, e, i) {\n      return t.map(function (t, e, i) {\n        var n = this.pointAt((e + .5) / i.length);\n        return (t.dx || t.dy) && n.offset(t.dx || 0, t.dy || 0), d(n.round(), 0, t);\n      }, r.line(e, i));\n    }\n\n    function a(t, e, s, a) {\n      var l = e.center(),\n          h = e.width / e.height,\n          u = e.topMiddle(),\n          c = r.Ellipse.fromRect(e);\n      return t.map(function (t, e, i) {\n        var n = s + a(e, i.length),\n            r = u.clone().rotate(l, -n).scale(h, 1, l),\n            o = t.compensateRotation ? -c.tangentTheta(r) : 0;\n        return (t.dx || t.dy) && r.offset(t.dx || 0, t.dy || 0), t.dr && r.move(l, t.dr), d(r.round(), o, t);\n      });\n    }\n\n    function l(t, e) {\n      var i = e.x;\n      s.isString(i) && (i = parseFloat(i) / 100 * t.width);\n      var n = e.y;\n      return s.isString(n) && (n = parseFloat(n) / 100 * t.height), r.point(i || 0, n || 0);\n    }\n\n    o.layout.Port = {\n      absolute: function absolute(t, e, i) {\n        return t.map(l.bind(null, e));\n      },\n      fn: function fn(t, e, i) {\n        return i.fn(t, e, i);\n      },\n      line: function line(t, e, i) {\n        return n(t, l(e, i.start || e.origin()), l(e, i.end || e.corner()));\n      },\n      left: function left(t, e, i) {\n        return n(t, e.origin(), e.bottomLeft());\n      },\n      right: function right(t, e, i) {\n        return n(t, e.topRight(), e.corner());\n      },\n      top: function top(t, e, i) {\n        return n(t, e.origin(), e.topRight());\n      },\n      bottom: function bottom(t, e, i) {\n        return n(t, e.bottomLeft(), e.corner());\n      },\n      ellipseSpread: function ellipseSpread(t, e, i) {\n        var n = i.startAngle || 0,\n            r = i.step || 360 / t.length;\n        return a(t, e, n, function (t) {\n          return t * r;\n        });\n      },\n      ellipse: function ellipse(t, e, i) {\n        var n = i.startAngle || 0,\n            r = i.step || 20;\n        return a(t, e, n, function (t, e) {\n          return (t + .5 - e / 2) * r;\n        });\n      }\n    };\n  }(g, joint, joint.util), function (u, t, f) {\n    function g(t, e) {\n      return f.defaultsDeep({}, t, e, {\n        x: 0,\n        y: 0,\n        angle: 0,\n        attrs: {\n          \".\": {\n            y: \"0\",\n            \"text-anchor\": \"start\"\n          }\n        }\n      });\n    }\n\n    function n(t, e, i, n) {\n      n = f.defaults({}, n, {\n        offset: 15\n      });\n      var r,\n          o,\n          s,\n          a,\n          l = e.center().theta(t),\n          h = p(e),\n          u = n.offset,\n          c = 0;\n      a = l < h[1] || l > h[2] ? (s = \".3em\", r = u, o = 0, \"start\") : l < h[0] ? (s = \"0\", r = 0, o = -u, i ? (c = -90, \"start\") : \"middle\") : l < h[3] ? (s = \".3em\", r = -u, o = 0, \"end\") : (s = \".6em\", r = 0, o = u, i ? (c = 90, \"start\") : \"middle\");\n      var d = Math.round;\n      return g({\n        x: d(r),\n        y: d(o),\n        angle: c,\n        attrs: {\n          \".\": {\n            y: s,\n            \"text-anchor\": a\n          }\n        }\n      });\n    }\n\n    function p(t) {\n      var e = t.center(),\n          i = e.theta(t.origin()),\n          n = e.theta(t.bottomLeft()),\n          r = e.theta(t.corner());\n      return [i, e.theta(t.topRight()), r, n];\n    }\n\n    function r(t, e, i, n) {\n      var r,\n          o,\n          s,\n          a,\n          l = e.center().theta(t),\n          h = (n = f.defaults({}, n, {\n        offset: 15\n      })).offset,\n          u = 0,\n          c = p(e);\n      a = l < c[1] || l > c[2] ? (s = \".3em\", r = -h, o = 0, \"end\") : l < c[0] ? (s = \".6em\", r = 0, o = h, i ? (u = 90, \"start\") : \"middle\") : l < c[3] ? (s = \".3em\", r = h, o = 0, \"start\") : (s = \"0em\", r = 0, o = -h, i ? (u = -90, \"start\") : \"middle\");\n      var d = Math.round;\n      return g({\n        x: d(r),\n        y: d(o),\n        angle: u,\n        attrs: {\n          \".\": {\n            y: s,\n            \"text-anchor\": a\n          }\n        }\n      });\n    }\n\n    function o(t, e, i) {\n      i = f.defaults({}, i, {\n        offset: 20\n      });\n      var n,\n          r = u.point(0, 0),\n          o = -t.theta(r),\n          s = o,\n          a = t.clone().move(r, i.offset).difference(t).round(),\n          l = \".3em\";\n      (o + 90) % 180 == 0 ? (n = e ? \"end\" : \"middle\", e || -270 !== o || (l = \"0em\")) : -270 < o && o < -90 ? (n = \"start\", s = o - 180) : n = \"end\";\n      var h = Math.round;\n      return g({\n        x: h(a.x),\n        y: h(a.y),\n        angle: e ? s : 0,\n        attrs: {\n          \".\": {\n            y: l,\n            \"text-anchor\": n\n          }\n        }\n      });\n    }\n\n    t.layout.PortLabel = {\n      manual: function manual(t, e, i) {\n        return g(i, e);\n      },\n      left: function left(t, e, i) {\n        return g(i, {\n          x: -15,\n          attrs: {\n            \".\": {\n              y: \".3em\",\n              \"text-anchor\": \"end\"\n            }\n          }\n        });\n      },\n      right: function right(t, e, i) {\n        return g(i, {\n          x: 15,\n          attrs: {\n            \".\": {\n              y: \".3em\",\n              \"text-anchor\": \"start\"\n            }\n          }\n        });\n      },\n      top: function top(t, e, i) {\n        return g(i, {\n          y: -15,\n          attrs: {\n            \".\": {\n              \"text-anchor\": \"middle\"\n            }\n          }\n        });\n      },\n      bottom: function bottom(t, e, i) {\n        return g(i, {\n          y: 15,\n          attrs: {\n            \".\": {\n              y: \".6em\",\n              \"text-anchor\": \"middle\"\n            }\n          }\n        });\n      },\n      outsideOriented: function outsideOriented(t, e, i) {\n        return n(t, e, !0, i);\n      },\n      outside: function outside(t, e, i) {\n        return n(t, e, !1, i);\n      },\n      insideOriented: function insideOriented(t, e, i) {\n        return r(t, e, !0, i);\n      },\n      inside: function inside(t, e, i) {\n        return r(t, e, !1, i);\n      },\n      radial: function radial(t, e, i) {\n        return o(t.difference(e.center()), !1, i);\n      },\n      radialOriented: function radialOriented(t, e, i) {\n        return o(t.difference(e.center()), !0, i);\n      }\n    };\n  }(g, joint, joint.util), joint.highlighters.addClass = {\n    className: joint.util.addClassNamePrefix(\"highlighted\"),\n    highlight: function highlight(t, e, i) {\n      var n = (i || {}).className || this.className;\n      V(e).addClass(n);\n    },\n    unhighlight: function unhighlight(t, e, i) {\n      var n = (i || {}).className || this.className;\n      V(e).removeClass(n);\n    }\n  }, joint.highlighters.opacity = {\n    highlight: function highlight(t, e) {\n      V(e).addClass(joint.util.addClassNamePrefix(\"highlight-opacity\"));\n    },\n    unhighlight: function unhighlight(t, e) {\n      V(e).removeClass(joint.util.addClassNamePrefix(\"highlight-opacity\"));\n    }\n  }, joint.highlighters.stroke = {\n    defaultOptions: {\n      padding: 3,\n      rx: 0,\n      ry: 0,\n      attrs: {\n        \"stroke-width\": 3,\n        stroke: \"#FEB663\"\n      }\n    },\n    _views: {},\n    getHighlighterId: function getHighlighterId(t, e) {\n      return t.id + JSON.stringify(e);\n    },\n    removeHighlighter: function removeHighlighter(t) {\n      this._views[t] && (this._views[t].remove(), this._views[t] = null);\n    },\n    highlight: function highlight(t, e, i) {\n      var n = this.getHighlighterId(e, i);\n\n      if (!this._views[n]) {\n        var r,\n            o = joint.util.defaults(i || {}, this.defaultOptions),\n            s = V(e);\n\n        try {\n          var a = s.convertToPathData();\n        } catch (t) {\n          r = s.bbox(!0), a = V.rectToPath(joint.util.assign({}, o, r));\n        }\n\n        var l = V(\"path\").attr({\n          d: a,\n          \"pointer-events\": \"none\",\n          \"vector-effect\": \"non-scaling-stroke\",\n          fill: \"none\"\n        }).attr(o.attrs),\n            h = s.getTransformToElement(t.el),\n            u = o.padding;\n\n        if (u) {\n          r || (r = s.bbox(!0));\n          var c = r.x + r.width / 2,\n              d = r.y + r.height / 2;\n          r = V.transformRect(r, h);\n          var f = Math.max(r.width, 1),\n              g = Math.max(r.height, 1),\n              p = (f + u) / f,\n              m = (g + u) / g,\n              v = V.createSVGMatrix({\n            a: p,\n            b: 0,\n            c: 0,\n            d: m,\n            e: c - p * c,\n            f: d - m * d\n          });\n          h = h.multiply(v);\n        }\n\n        l.transform(h);\n        var y = this._views[n] = new joint.mvc.View({\n          svgElement: !0,\n          className: \"highlight-stroke\",\n          el: l.node\n        }),\n            b = this.removeHighlighter.bind(this, n),\n            w = t.model;\n        y.listenTo(w, \"remove\", b), y.listenTo(w.graph, \"reset\", b), t.vel.append(l);\n      }\n    },\n    unhighlight: function unhighlight(t, e, i) {\n      this.removeHighlighter(this.getHighlighterId(e, i));\n    }\n  }, function (t, d) {\n    function e(c) {\n      return function (t, e, i, n) {\n        var r = !!n.rotate,\n            o = r ? t.getNodeUnrotatedBBox(e) : t.getNodeBBox(e),\n            s = o[c](),\n            a = n.dx;\n\n        if (a) {\n          var l = d.isPercentage(a);\n          a = parseFloat(a), isFinite(a) && (l && (a /= 100, a *= o.width), s.x += a);\n        }\n\n        var h = n.dy;\n\n        if (h) {\n          var u = d.isPercentage(h);\n          h = parseFloat(h), isFinite(h) && (u && (h /= 100, h *= o.height), s.y += h);\n        }\n\n        return r ? s.rotate(t.model.getBBox().center(), -t.model.angle()) : s;\n      };\n    }\n\n    function i(s) {\n      return function (t, e, i, n) {\n        if (i instanceof Element) {\n          var r = this.paper.findView(i),\n              o = r ? r.getNodeBBox(i).center() : new g.Point();\n          return s.call(this, t, e, o, n);\n        }\n\n        return s.apply(this, arguments);\n      };\n    }\n\n    t.anchors = {\n      center: e(\"center\"),\n      top: e(\"topMiddle\"),\n      bottom: e(\"bottomMiddle\"),\n      left: e(\"leftMiddle\"),\n      right: e(\"rightMiddle\"),\n      topLeft: e(\"origin\"),\n      topRight: e(\"topRight\"),\n      bottomLeft: e(\"bottomLeft\"),\n      bottomRight: e(\"corner\"),\n      perpendicular: i(function (t, e, i, n) {\n        var r = t.model.angle(),\n            o = t.getNodeBBox(e),\n            s = o.center(),\n            a = o.origin(),\n            l = o.corner(),\n            h = n.padding;\n\n        if (isFinite(h) || (h = 0), a.y + h <= i.y && i.y <= l.y - h) {\n          var u = i.y - s.y;\n          s.x += 0 === r || 180 === r ? 0 : 1 * u / Math.tan(g.toRad(r)), s.y += u;\n        } else if (a.x + h <= i.x && i.x <= l.x - h) {\n          var c = i.x - s.x;\n          s.y += 90 === r || 270 === r ? 0 : c * Math.tan(g.toRad(r)), s.x += c;\n        }\n\n        return s;\n      }),\n      midSide: i(function (t, e, i, n) {\n        var r,\n            o,\n            s,\n            a = !!n.rotate;\n        a ? (r = t.getNodeUnrotatedBBox(e), s = t.model.getBBox().center(), o = t.model.angle()) : r = t.getNodeBBox(e);\n        var l,\n            h = n.padding;\n\n        switch (isFinite(h) && r.inflate(h), a && i.rotate(s, o), r.sideNearestToPoint(i)) {\n          case \"left\":\n            l = r.leftMiddle();\n            break;\n\n          case \"right\":\n            l = r.rightMiddle();\n            break;\n\n          case \"top\":\n            l = r.topMiddle();\n            break;\n\n          case \"bottom\":\n            l = r.bottomMiddle();\n        }\n\n        return a ? l.rotate(s, -o) : l;\n      }),\n      modelCenter: function modelCenter(t, e) {\n        var i = t.model,\n            n = i.getBBox(),\n            r = n.center(),\n            o = i.angle(),\n            s = t.findAttribute(\"port\", e);\n\n        if (s) {\n          var a = i.portProp(s, \"group\"),\n              l = i.getPortsPositions(a),\n              h = new g.Point(l[s]).offset(n.origin());\n          return h.rotate(r, -o), h;\n        }\n\n        return r;\n      }\n    };\n  }(joint, joint.util), function (t, x, k, A) {\n    function j(t, e) {\n      return 1 === t.length ? t[0] : x.sortBy(t, function (t) {\n        return t.squaredDistance(e);\n      })[0];\n    }\n\n    function P(t, e, i) {\n      if (!isFinite(i)) return t;\n      var n = t.distance(e);\n      return 0 === i && 0 < n ? t : t.move(e, -Math.min(i, n - 1));\n    }\n\n    function C(t) {\n      var e = t.getAttribute(\"stroke-width\");\n      return null === e ? 0 : parseFloat(e) || 0;\n    }\n\n    function h(t, e, i, n) {\n      var r = e.getNodeBBox(i);\n      n.stroke && r.inflate(C(i) / 2);\n      var o = t.intersect(r);\n      return P(o ? j(o, t.start) : t.end, t.start, n.offset);\n    }\n\n    var V = \"segmentSubdivisons\",\n        E = \"shapeBBox\";\n    t.connectionPoints = {\n      anchor: function anchor(t, e, i, n) {\n        return P(t.end, t.start, n.offset);\n      },\n      bbox: h,\n      rectangle: function rectangle(t, e, i, n) {\n        var r = e.model.angle();\n        if (0 === r) return h(t, e, i, n);\n        var o = e.getNodeUnrotatedBBox(i);\n        n.stroke && o.inflate(C(i) / 2);\n        var s = o.center(),\n            a = t.clone().rotate(s, r),\n            l = a.setLength(1e6).intersect(o);\n        return P(l ? j(l, a.start).rotate(s, -r) : t.end, t.start, n.offset);\n      },\n      boundary: function boundary(t, e, i, n) {\n        var r,\n            o,\n            s = n.selector,\n            a = t.end;\n\n        if (r = \"string\" == typeof s ? e.findBySelector(s)[0] : Array.isArray(s) ? x.getByPath(i, s) : function (t) {\n          if (!t) return null;\n          var e = t;\n\n          do {\n            var i = e.tagName;\n            if (\"string\" != typeof i) return null;\n            if (\"G\" === (i = i.toUpperCase())) e = e.firstElementChild;else {\n              if (\"TITLE\" !== i) break;\n              e = e.nextElementSibling;\n            }\n          } while (e);\n\n          return e;\n        }(i), !A.isSVGGraphicsElement(r)) {\n          if (r === i || !A.isSVGGraphicsElement(i)) return a;\n          r = i;\n        }\n\n        var l,\n            h = e.getNodeShape(r),\n            u = e.getNodeMatrix(r),\n            c = e.getRootTranslateMatrix(),\n            d = e.getRootRotateMatrix(),\n            f = c.multiply(d).multiply(u),\n            g = f.inverse(),\n            p = A.transformLine(t, g),\n            m = p.start.clone(),\n            v = e.getNodeData(r);\n        if (!1 === n.insideout && (v[E] || (v[E] = h.bbox()), v[E].containsPoint(m))) return a;\n\n        if (h instanceof k.Path) {\n          var y = n.precision || 2;\n          v[V] || (v[V] = h.getSegmentSubdivisions({\n            precision: y\n          })), l = {\n            precision: y,\n            segmentSubdivisions: v[V]\n          };\n        }\n\n        !0 === n.extrapolate && p.setLength(1e6), (o = p.intersect(h, l)) ? A.isArray(o) && (o = j(o, m)) : !0 === n.sticky && (o = h instanceof k.Rect ? h.pointNearestToPoint(m) : h instanceof k.Ellipse ? h.intersectionWithLineFromCenterToPoint(m) : h.closestPoint(m, l));\n        var b = o ? A.transformPoint(o, f) : a,\n            w = n.offset || 0;\n        return n.stroke && (w += C(r) / 2), P(b, t.start, w);\n      }\n    };\n  }(joint, joint.util, g, V), function (t, e) {\n    function u(t, e) {\n      return 0 === e ? \"0%\" : Math.round(t / e * 100) + \"%\";\n    }\n\n    function i(h) {\n      return function (t, e, i, n) {\n        var r = e.model.angle(),\n            o = e.getNodeUnrotatedBBox(i),\n            s = e.model.getBBox().center();\n        n.rotate(s, r);\n        var a = n.x - o.x,\n            l = n.y - o.y;\n        return h && (a = u(a, o.width), l = u(l, o.height)), t.anchor = {\n          name: \"topLeft\",\n          args: {\n            dx: a,\n            dy: l,\n            rotate: !0\n          }\n        }, t;\n      };\n    }\n\n    t.connectionStrategies = {\n      useDefaults: e.noop,\n      pinAbsolute: i(!1),\n      pinRelative: i(!0)\n    };\n  }(joint, joint.util), function (n, E, l, g) {\n    function t(t, e, i) {\n      return n.connectionStrategies.pinRelative.call(this.paper, {}, e, i, t, this.model).anchor;\n    }\n\n    var e = n.dia.ToolView,\n        i = n.mvc.View.extend({\n      tagName: \"circle\",\n      svgElement: !0,\n      className: \"marker-vertex\",\n      events: {\n        mousedown: \"onPointerDown\",\n        touchstart: \"onPointerDown\",\n        dblclick: \"onDoubleClick\"\n      },\n      documentEvents: {\n        mousemove: \"onPointerMove\",\n        touchmove: \"onPointerMove\",\n        mouseup: \"onPointerUp\",\n        touchend: \"onPointerUp\",\n        touchcancel: \"onPointerUp\"\n      },\n      attributes: {\n        r: 6,\n        fill: \"#33334F\",\n        stroke: \"#FFFFFF\",\n        \"stroke-width\": 2,\n        cursor: \"move\"\n      },\n      position: function position(t, e) {\n        this.vel.attr({\n          cx: t,\n          cy: e\n        });\n      },\n      onPointerDown: function onPointerDown(t) {\n        t.stopPropagation(), t.preventDefault(), this.options.paper.undelegateEvents(), this.delegateDocumentEvents(null, t.data), this.trigger(\"will-change\");\n      },\n      onPointerMove: function onPointerMove(t) {\n        this.trigger(\"changing\", this, t);\n      },\n      onDoubleClick: function onDoubleClick(t) {\n        this.trigger(\"remove\", this, t);\n      },\n      onPointerUp: function onPointerUp(t) {\n        this.trigger(\"changed\", this, t), this.undelegateDocumentEvents(), this.options.paper.delegateEvents();\n      }\n    }),\n        r = e.extend({\n      name: \"vertices\",\n      options: {\n        handleClass: i,\n        snapRadius: 20,\n        redundancyRemoval: !0,\n        vertexAdding: !0\n      },\n      children: [{\n        tagName: \"path\",\n        selector: \"connection\",\n        className: \"joint-vertices-path\",\n        attributes: {\n          fill: \"none\",\n          stroke: \"transparent\",\n          \"stroke-width\": 10,\n          cursor: \"cell\"\n        }\n      }],\n      handles: null,\n      events: {\n        \"mousedown .joint-vertices-path\": \"onPathPointerDown\",\n        \"touchstart .joint-vertices-path\": \"onPathPointerDown\"\n      },\n      onRender: function onRender() {\n        this.resetHandles(), this.options.vertexAdding && (this.renderChildren(), this.updatePath());\n\n        for (var t = this.relatedView.model.vertices(), e = 0, i = t.length; e < i; e++) {\n          var n = t[e],\n              r = new this.options.handleClass({\n            index: e,\n            paper: this.paper\n          });\n          r.render(), r.position(n.x, n.y), this.simulateRelatedView(r.el), r.vel.appendTo(this.el), this.handles.push(r), this.startHandleListening(r);\n        }\n\n        return this;\n      },\n      update: function update() {\n        return this.render(), this;\n      },\n      updatePath: function updatePath() {\n        var t = this.childNodes.connection;\n        t && t.setAttribute(\"d\", this.relatedView.getConnection().serialize());\n      },\n      startHandleListening: function startHandleListening(t) {\n        var e = this.relatedView;\n        e.can(\"vertexMove\") && (this.listenTo(t, \"will-change\", this.onHandleWillChange), this.listenTo(t, \"changing\", this.onHandleChanging), this.listenTo(t, \"changed\", this.onHandleChanged)), e.can(\"vertexRemove\") && this.listenTo(t, \"remove\", this.onHandleRemove);\n      },\n      resetHandles: function resetHandles() {\n        var t = this.handles;\n        if (this.handles = [], this.stopListening(), Array.isArray(t)) for (var e = 0, i = t.length; e < i; e++) {\n          t[e].remove();\n        }\n      },\n      getNeighborPoints: function getNeighborPoints(t) {\n        var e = this.relatedView,\n            i = e.model.vertices(),\n            n = 0 < t ? i[t - 1] : e.sourceAnchor,\n            r = t < i.length - 1 ? i[t + 1] : e.targetAnchor;\n        return {\n          prev: new g.Point(n),\n          next: new g.Point(r)\n        };\n      },\n      onHandleWillChange: function onHandleWillChange(t, e) {\n        this.focus(), this.relatedView.model.startBatch(\"vertex-move\", {\n          ui: !0,\n          tool: this.cid\n        });\n      },\n      onHandleChanging: function onHandleChanging(t, e) {\n        var i = this.relatedView,\n            n = i.paper,\n            r = t.options.index,\n            o = E.normalizeEvent(e),\n            s = n.snapToGrid(o.clientX, o.clientY).toJSON();\n        this.snapVertex(s, r), i.model.vertex(r, s, {\n          ui: !0,\n          tool: this.cid\n        }), t.position(s.x, s.y);\n      },\n      snapVertex: function snapVertex(t, e) {\n        var i = this.options.snapRadius;\n\n        if (0 < i) {\n          var n = this.getNeighborPoints(e),\n              r = n.prev,\n              o = n.next;\n          Math.abs(t.x - r.x) < i ? t.x = r.x : Math.abs(t.x - o.x) < i && (t.x = o.x), Math.abs(t.y - r.y) < i ? t.y = n.prev.y : Math.abs(t.y - o.y) < i && (t.y = o.y);\n        }\n      },\n      onHandleChanged: function onHandleChanged(t, e) {\n        if (this.options.vertexAdding && this.updatePath(), this.options.redundancyRemoval) {\n          var i = this.relatedView;\n          i.removeRedundantLinearVertices({\n            ui: !0,\n            tool: this.cid\n          }) && this.render(), this.blur(), i.model.stopBatch(\"vertex-move\", {\n            ui: !0,\n            tool: this.cid\n          }), this.eventData(e).vertexAdded && i.model.stopBatch(\"vertex-add\", {\n            ui: !0,\n            tool: this.cid\n          });\n        }\n      },\n      onHandleRemove: function onHandleRemove(t) {\n        var e = t.options.index;\n        this.relatedView.model.removeVertex(e, {\n          ui: !0\n        });\n      },\n      onPathPointerDown: function onPathPointerDown(t) {\n        t.stopPropagation(), t.preventDefault();\n        var e = E.normalizeEvent(t),\n            i = this.paper.snapToGrid(e.clientX, e.clientY).toJSON(),\n            n = this.relatedView;\n        n.model.startBatch(\"vertex-add\", {\n          ui: !0,\n          tool: this.cid\n        });\n        var r = n.getVertexIndex(i.x, i.y);\n        this.snapVertex(i, r), n.model.insertVertex(r, i, {\n          ui: !0,\n          tool: this.cid\n        }), this.render();\n        var o = this.handles[r];\n        this.eventData(t, {\n          vertexAdded: !0\n        }), o.onPointerDown(t);\n      },\n      onRemove: function onRemove() {\n        this.resetHandles();\n      }\n    }, {\n      VertexHandle: i\n    }),\n        o = n.mvc.View.extend({\n      tagName: \"g\",\n      svgElement: !0,\n      className: \"marker-segment\",\n      events: {\n        mousedown: \"onPointerDown\",\n        touchstart: \"onPointerDown\"\n      },\n      documentEvents: {\n        mousemove: \"onPointerMove\",\n        touchmove: \"onPointerMove\",\n        mouseup: \"onPointerUp\",\n        touchend: \"onPointerUp\",\n        touchcancel: \"onPointerUp\"\n      },\n      children: [{\n        tagName: \"line\",\n        selector: \"line\",\n        attributes: {\n          stroke: \"#33334F\",\n          \"stroke-width\": 2,\n          fill: \"none\",\n          \"pointer-events\": \"none\"\n        }\n      }, {\n        tagName: \"rect\",\n        selector: \"handle\",\n        attributes: {\n          width: 20,\n          height: 8,\n          x: -10,\n          y: -4,\n          rx: 4,\n          ry: 4,\n          fill: \"#33334F\",\n          stroke: \"#FFFFFF\",\n          \"stroke-width\": 2\n        }\n      }],\n      onRender: function onRender() {\n        this.renderChildren();\n      },\n      position: function position(t, e, i, n) {\n        var r = l.createSVGMatrix().translate(t, e).rotate(i),\n            o = this.childNodes.handle;\n        o.setAttribute(\"transform\", l.matrixToTransformString(r)), o.setAttribute(\"cursor\", i % 180 == 0 ? \"row-resize\" : \"col-resize\");\n        var s = n.getClosestPoint(new g.Point(t, e)),\n            a = this.childNodes.line;\n        a.setAttribute(\"x1\", t), a.setAttribute(\"y1\", e), a.setAttribute(\"x2\", s.x), a.setAttribute(\"y2\", s.y);\n      },\n      onPointerDown: function onPointerDown(t) {\n        this.trigger(\"change:start\", this, t), t.stopPropagation(), t.preventDefault(), this.options.paper.undelegateEvents(), this.delegateDocumentEvents(null, t.data);\n      },\n      onPointerMove: function onPointerMove(t) {\n        this.trigger(\"changing\", this, t);\n      },\n      onPointerUp: function onPointerUp(t) {\n        this.undelegateDocumentEvents(), this.options.paper.delegateEvents(), this.trigger(\"change:end\", this, t);\n      },\n      show: function show() {\n        this.el.style.display = \"\";\n      },\n      hide: function hide() {\n        this.el.style.display = \"none\";\n      }\n    }),\n        s = e.extend({\n      name: \"segments\",\n      precision: .5,\n      options: {\n        handleClass: o,\n        segmentLengthThreshold: 40,\n        redundancyRemoval: !0,\n        anchor: t,\n        snapRadius: 10,\n        snapHandle: !0\n      },\n      handles: null,\n      onRender: function onRender() {\n        this.resetHandles();\n        var t = this.relatedView,\n            e = t.model.vertices();\n        e.unshift(t.sourcePoint), e.push(t.targetPoint);\n\n        for (var i = 0, n = e.length; i < n - 1; i++) {\n          var r = e[i],\n              o = e[i + 1],\n              s = this.renderHandle(r, o);\n          this.simulateRelatedView(s.el), this.handles.push(s), s.options.index = i;\n        }\n\n        return this;\n      },\n      renderHandle: function renderHandle(t, e) {\n        var i = new this.options.handleClass({\n          paper: this.paper\n        });\n        return i.render(), this.updateHandle(i, t, e), i.vel.appendTo(this.el), this.startHandleListening(i), i;\n      },\n      update: function update() {\n        return this.render(), this;\n      },\n      startHandleListening: function startHandleListening(t) {\n        this.listenTo(t, \"change:start\", this.onHandleChangeStart), this.listenTo(t, \"changing\", this.onHandleChanging), this.listenTo(t, \"change:end\", this.onHandleChangeEnd);\n      },\n      resetHandles: function resetHandles() {\n        var t = this.handles;\n        if (this.handles = [], this.stopListening(), Array.isArray(t)) for (var e = 0, i = t.length; e < i; e++) {\n          t[e].remove();\n        }\n      },\n      shiftHandleIndexes: function shiftHandleIndexes(t) {\n        for (var e = this.handles, i = 0, n = e.length; i < n; i++) {\n          e[i].options.index += t;\n        }\n      },\n      resetAnchor: function resetAnchor(t, e) {\n        var i = this.relatedView.model;\n        e ? i.prop([t, \"anchor\"], e, {\n          rewrite: !0,\n          ui: !0,\n          tool: this.cid\n        }) : i.removeProp([t, \"anchor\"], {\n          ui: !0,\n          tool: this.cid\n        });\n      },\n      snapHandle: function snapHandle(t, e, i) {\n        var n = t.options.index,\n            r = this.relatedView.model.vertices(),\n            o = t.options.axis,\n            s = r[n - 2] || i.sourceAnchor,\n            a = r[n + 1] || i.targetAnchor,\n            l = this.options.snapRadius;\n        return Math.abs(e[o] - s[o]) < l ? e[o] = s[o] : Math.abs(e[o] - a[o]) < l && (e[o] = a[o]), e;\n      },\n      onHandleChanging: function onHandleChanging(t, e) {\n        var i = this.eventData(e),\n            n = this.relatedView,\n            r = n.paper,\n            o = t.options.index - 1,\n            s = E.normalizeEvent(e),\n            a = r.snapToGrid(s.clientX, s.clientY),\n            l = this.snapHandle(t, a.clone(), i),\n            h = t.options.axis,\n            u = this.options.snapHandle ? 0 : a[h] - l[h],\n            c = n.model,\n            d = E.cloneDeep(c.vertices()),\n            f = d[o],\n            g = d[o + 1],\n            p = this.options.anchor;\n        \"function\" != typeof p && (p = null);\n        var m = n.sourceView,\n            v = n.sourceBBox,\n            y = !1,\n            b = !1;\n\n        if (f ? 0 === o ? v.containsPoint(f) ? (d.shift(), this.shiftHandleIndexes(-1), y = !0) : (f[h] = l[h], b = !0) : f[h] = l[h] : ((f = n.sourceAnchor.toJSON())[h] = l[h], v.containsPoint(f) ? (f[h] = l[h], y = !0) : (d.unshift(f), this.shiftHandleIndexes(1), b = !0)), p && m) {\n          if (y) {\n            var w = i.sourceAnchor.clone();\n            w[h] = l[h];\n            var x = p.call(n, w, m, n.sourceMagnet || m.el, \"source\", n);\n            this.resetAnchor(\"source\", x);\n          }\n\n          b && this.resetAnchor(\"source\", i.sourceAnchorDef);\n        }\n\n        var k = n.targetView,\n            A = n.targetBBox,\n            j = !1,\n            P = !1;\n\n        if (g ? o === d.length - 2 ? A.containsPoint(g) ? (d.pop(), j = !0) : (g[h] = l[h], P = !0) : g[h] = l[h] : ((g = n.targetAnchor.toJSON())[h] = l[h], A.containsPoint(g) ? j = !0 : (d.push(g), P = !0)), p && k) {\n          if (j) {\n            var C = i.targetAnchor.clone();\n            C[h] = l[h];\n            var V = p.call(n, C, k, n.targetMagnet || k.el, \"target\", n);\n            this.resetAnchor(\"target\", V);\n          }\n\n          P && this.resetAnchor(\"target\", i.targetAnchorDef);\n        }\n\n        c.vertices(d, {\n          ui: !0,\n          tool: this.cid\n        }), this.updateHandle(t, f, g, u);\n      },\n      onHandleChangeStart: function onHandleChangeStart(t, e) {\n        var i = t.options.index,\n            n = this.handles;\n\n        if (Array.isArray(n)) {\n          for (var r = 0, o = n.length; r < o; r++) {\n            r !== i && n[r].hide();\n          }\n\n          this.focus();\n          var s = this.relatedView,\n              a = s.model;\n          this.eventData(e, {\n            sourceAnchor: s.sourceAnchor.clone(),\n            targetAnchor: s.targetAnchor.clone(),\n            sourceAnchorDef: E.clone(a.prop([\"source\", \"anchor\"])),\n            targetAnchorDef: E.clone(a.prop([\"target\", \"anchor\"]))\n          }), s.model.startBatch(\"segment-move\", {\n            ui: !0,\n            tool: this.cid\n          });\n        }\n      },\n      onHandleChangeEnd: function onHandleChangeEnd(t) {\n        var e = this.relatedView;\n        this.options.redundancyRemoval && e.removeRedundantLinearVertices({\n          ui: !0,\n          tool: this.cid\n        }), this.render(), this.blur(), e.model.stopBatch(\"segment-move\", {\n          ui: !0,\n          tool: this.cid\n        });\n      },\n      updateHandle: function updateHandle(t, e, i, n) {\n        var r = Math.abs(e.x - i.x) < this.precision,\n            o = Math.abs(e.y - i.y) < this.precision;\n\n        if (r || o) {\n          var s = new g.Line(e, i);\n          if (s.length() < this.options.segmentLengthThreshold) t.hide();else {\n            var a = s.midpoint(),\n                l = r ? \"x\" : \"y\";\n            a[l] += n || 0;\n            var h = s.vector().vectorAngle(new g.Point(1, 0));\n            t.position(a.x, a.y, h, this.relatedView), t.show(), t.options.axis = l;\n          }\n        } else t.hide();\n      },\n      onRemove: function onRemove() {\n        this.resetHandles();\n      }\n    }, {\n      SegmentHandle: o\n    }),\n        a = e.extend({\n      tagName: \"path\",\n      xAxisVector: new g.Point(1, 0),\n      events: {\n        mousedown: \"onPointerDown\",\n        touchstart: \"onPointerDown\"\n      },\n      documentEvents: {\n        mousemove: \"onPointerMove\",\n        touchmove: \"onPointerMove\",\n        mouseup: \"onPointerUp\",\n        touchend: \"onPointerUp\",\n        touchcancel: \"onPointerUp\"\n      },\n      onRender: function onRender() {\n        this.update();\n      },\n      update: function update() {\n        var t,\n            e,\n            i = this.ratio,\n            n = this.relatedView,\n            r = n.getTangentAtRatio(i);\n        e = r ? (t = r.start, r.vector().vectorAngle(this.xAxisVector) || 0) : (t = n.getPointAtRatio(i), 0);\n        var o = l.createSVGMatrix().translate(t.x, t.y).rotate(e);\n        return this.vel.transform(o, {\n          absolute: !0\n        }), this;\n      },\n      onPointerDown: function onPointerDown(t) {\n        t.stopPropagation(), t.preventDefault();\n        var e = this.relatedView;\n        e.model.startBatch(\"arrowhead-move\", {\n          ui: !0,\n          tool: this.cid\n        }), e.can(\"arrowheadMove\") && (e.startArrowheadMove(this.arrowheadType), this.delegateDocumentEvents(), e.paper.undelegateEvents()), this.focus(), this.el.style.pointerEvents = \"none\";\n      },\n      onPointerMove: function onPointerMove(t) {\n        var e = E.normalizeEvent(t),\n            i = this.paper.snapToGrid(e.clientX, e.clientY);\n        this.relatedView.pointermove(e, i.x, i.y);\n      },\n      onPointerUp: function onPointerUp(t) {\n        this.undelegateDocumentEvents();\n        var e = this.relatedView,\n            i = e.paper,\n            n = E.normalizeEvent(t),\n            r = i.snapToGrid(n.clientX, n.clientY);\n        e.pointerup(n, r.x, r.y), i.delegateEvents(), this.blur(), this.el.style.pointerEvents = \"\", e.model.stopBatch(\"arrowhead-move\", {\n          ui: !0,\n          tool: this.cid\n        });\n      }\n    }),\n        h = a.extend({\n      name: \"target-arrowhead\",\n      ratio: 1,\n      arrowheadType: \"target\",\n      attributes: {\n        d: \"M -10 -8 10 0 -10 8 Z\",\n        fill: \"#33334F\",\n        stroke: \"#FFFFFF\",\n        \"stroke-width\": 2,\n        cursor: \"move\",\n        class: \"target-arrowhead\"\n      }\n    }),\n        u = a.extend({\n      name: \"source-arrowhead\",\n      ratio: 0,\n      arrowheadType: \"source\",\n      attributes: {\n        d: \"M 10 -8 -10 0 10 8 Z\",\n        fill: \"#33334F\",\n        stroke: \"#FFFFFF\",\n        \"stroke-width\": 2,\n        cursor: \"move\",\n        class: \"source-arrowhead\"\n      }\n    }),\n        c = e.extend({\n      name: \"button\",\n      events: {\n        mousedown: \"onPointerDown\",\n        touchstart: \"onPointerDown\"\n      },\n      options: {\n        distance: 0,\n        offset: 0,\n        rotate: !1\n      },\n      onRender: function onRender() {\n        this.renderChildren(this.options.markup), this.update();\n      },\n      update: function update() {\n        var t,\n            e,\n            i,\n            n = this.options.distance || 0;\n        i = (t = E.isPercentage(n) ? this.relatedView.getTangentAtRatio(parseFloat(n) / 100) : this.relatedView.getTangentAtLength(n)) ? (e = t.start, t.vector().vectorAngle(new g.Point(1, 0)) || 0) : (e = this.relatedView.getConnection().start, 0);\n        var r = l.createSVGMatrix().translate(e.x, e.y).rotate(i).translate(0, this.options.offset || 0);\n        return this.options.rotate || (r = r.rotate(-i)), this.vel.transform(r, {\n          absolute: !0\n        }), this;\n      },\n      onPointerDown: function onPointerDown(t) {\n        t.stopPropagation(), t.preventDefault();\n        var e = this.options.action;\n        \"function\" == typeof e && e.call(this.relatedView, t, this.relatedView);\n      }\n    }),\n        d = c.extend({\n      children: [{\n        tagName: \"circle\",\n        selector: \"button\",\n        attributes: {\n          r: 7,\n          fill: \"#FF1D00\",\n          cursor: \"pointer\"\n        }\n      }, {\n        tagName: \"path\",\n        selector: \"icon\",\n        attributes: {\n          d: \"M -3 -3 3 3 M -3 3 3 -3\",\n          fill: \"none\",\n          stroke: \"#FFFFFF\",\n          \"stroke-width\": 2,\n          \"pointer-events\": \"none\"\n        }\n      }],\n      options: {\n        distance: 60,\n        offset: 0,\n        action: function action(t) {\n          this.model.remove({\n            ui: !0,\n            tool: this.cid\n          });\n        }\n      }\n    }),\n        f = e.extend({\n      name: \"boundary\",\n      tagName: \"rect\",\n      options: {\n        padding: 10\n      },\n      attributes: {\n        fill: \"none\",\n        stroke: \"#33334F\",\n        \"stroke-width\": .5,\n        \"stroke-dasharray\": \"5, 5\",\n        \"pointer-events\": \"none\"\n      },\n      onRender: function onRender() {\n        this.update();\n      },\n      update: function update() {\n        var t = this.options.padding;\n        isFinite(t) || (t = 0);\n        var e = this.relatedView.getConnection().bbox().inflate(t);\n        return this.vel.attr(e.toJSON()), this;\n      }\n    }),\n        p = e.extend({\n      tagName: \"g\",\n      type: null,\n      children: [{\n        tagName: \"circle\",\n        selector: \"anchor\",\n        attributes: {\n          cursor: \"pointer\"\n        }\n      }, {\n        tagName: \"rect\",\n        selector: \"area\",\n        attributes: {\n          \"pointer-events\": \"none\",\n          fill: \"none\",\n          stroke: \"#33334F\",\n          \"stroke-dasharray\": \"2,4\",\n          rx: 5,\n          ry: 5\n        }\n      }],\n      events: {\n        mousedown: \"onPointerDown\",\n        touchstart: \"onPointerDown\",\n        dblclick: \"onPointerDblClick\"\n      },\n      documentEvents: {\n        mousemove: \"onPointerMove\",\n        touchmove: \"onPointerMove\",\n        mouseup: \"onPointerUp\",\n        touchend: \"onPointerUp\",\n        touchcancel: \"onPointerUp\"\n      },\n      options: {\n        snap: function snap(t, e, i, n, r, o) {\n          var s = o.options.snapRadius,\n              a = \"source\" === n,\n              l = a ? 0 : -1,\n              h = this.model.vertex(l) || this.getEndAnchor(a ? \"target\" : \"source\");\n          return h && (Math.abs(h.x - t.x) < s && (t.x = h.x), Math.abs(h.y - t.y) < s && (t.y = h.y)), t;\n        },\n        anchor: t,\n        customAnchorAttributes: {\n          \"stroke-width\": 4,\n          stroke: \"#33334F\",\n          fill: \"#FFFFFF\",\n          r: 5\n        },\n        defaultAnchorAttributes: {\n          \"stroke-width\": 2,\n          stroke: \"#FFFFFF\",\n          fill: \"#33334F\",\n          r: 6\n        },\n        areaPadding: 6,\n        snapRadius: 10,\n        restrictArea: !0,\n        redundancyRemoval: !0\n      },\n      onRender: function onRender() {\n        this.renderChildren(), this.toggleArea(!1), this.update();\n      },\n      update: function update() {\n        var t = this.type,\n            e = this.relatedView.getEndView(t);\n        return this.el.style.display = e ? (this.updateAnchor(), this.updateArea(), \"\") : \"none\", this;\n      },\n      updateAnchor: function updateAnchor() {\n        var t = this.childNodes;\n\n        if (t) {\n          var e = t.anchor;\n\n          if (e) {\n            var i = this.relatedView,\n                n = this.type,\n                r = i.getEndAnchor(n),\n                o = this.options,\n                s = i.model.prop([n, \"anchor\"]);\n            e.setAttribute(\"transform\", \"translate(\" + r.x + \",\" + r.y + \")\");\n            var a = s ? o.customAnchorAttributes : o.defaultAnchorAttributes;\n\n            for (var l in a) {\n              e.setAttribute(l, a[l]);\n            }\n          }\n        }\n      },\n      updateArea: function updateArea() {\n        var t = this.childNodes;\n\n        if (t) {\n          var e = t.area;\n\n          if (e) {\n            var i = this.relatedView,\n                n = this.type,\n                r = i.getEndView(n),\n                o = i.getEndMagnet(n),\n                s = this.options.areaPadding;\n            isFinite(s) || (s = 0);\n            var a = r.getNodeUnrotatedBBox(o).inflate(s),\n                l = r.model.angle();\n            e.setAttribute(\"x\", -a.width / 2), e.setAttribute(\"y\", -a.height / 2), e.setAttribute(\"width\", a.width), e.setAttribute(\"height\", a.height);\n            var h = r.model.getBBox().center(),\n                u = a.center().rotate(h, -l);\n            e.setAttribute(\"transform\", \"translate(\" + u.x + \",\" + u.y + \") rotate(\" + l + \")\");\n          }\n        }\n      },\n      toggleArea: function toggleArea(t) {\n        this.childNodes.area.style.display = t ? \"\" : \"none\";\n      },\n      onPointerDown: function onPointerDown(t) {\n        t.stopPropagation(), t.preventDefault(), this.paper.undelegateEvents(), this.delegateDocumentEvents(), this.focus(), this.toggleArea(this.options.restrictArea), this.relatedView.model.startBatch(\"anchor-move\", {\n          ui: !0,\n          tool: this.cid\n        });\n      },\n      resetAnchor: function resetAnchor(t) {\n        var e = this.type,\n            i = this.relatedView.model;\n        t ? i.prop([e, \"anchor\"], t, {\n          rewrite: !0,\n          ui: !0,\n          tool: this.cid\n        }) : i.removeProp([e, \"anchor\"], {\n          ui: !0,\n          tool: this.cid\n        });\n      },\n      onPointerMove: function onPointerMove(t) {\n        var e,\n            i = this.relatedView,\n            n = this.type,\n            r = i.getEndView(n),\n            o = i.getEndMagnet(n),\n            s = E.normalizeEvent(t),\n            a = this.paper.clientToLocalPoint(s.clientX, s.clientY),\n            l = this.options.snap;\n\n        if (\"function\" == typeof l && (a = l.call(i, a, r, o, n, i, this), a = new g.Point(a)), this.options.restrictArea) {\n          var h = r.getNodeUnrotatedBBox(o),\n              u = r.model.angle(),\n              c = r.model.getBBox().center(),\n              d = a.clone().rotate(c, u);\n          h.containsPoint(d) || (a = h.pointNearestToPoint(d).rotate(c, -u));\n        }\n\n        var f = this.options.anchor;\n        \"function\" == typeof f && (e = f.call(i, a, r, o, n, i)), this.resetAnchor(e), this.update();\n      },\n      onPointerUp: function onPointerUp(t) {\n        this.paper.delegateEvents(), this.undelegateDocumentEvents(), this.blur(), this.toggleArea(!1);\n        var e = this.relatedView;\n        this.options.redundancyRemoval && e.removeRedundantLinearVertices({\n          ui: !0,\n          tool: this.cid\n        }), e.model.stopBatch(\"anchor-move\", {\n          ui: !0,\n          tool: this.cid\n        });\n      },\n      onPointerDblClick: function onPointerDblClick() {\n        this.resetAnchor(), this.update();\n      }\n    }),\n        m = p.extend({\n      name: \"source-anchor\",\n      type: \"source\"\n    }),\n        v = p.extend({\n      name: \"target-anchor\",\n      type: \"target\"\n    });\n    n.linkTools = {\n      Vertices: r,\n      Segments: s,\n      SourceArrowhead: u,\n      TargetArrowhead: h,\n      SourceAnchor: m,\n      TargetAnchor: v,\n      Button: c,\n      Remove: d,\n      Boundary: f\n    };\n  }(joint, joint.util, V, g);\n  joint.dia.Element.define(\"erd.Entity\", {\n    size: {\n      width: 150,\n      height: 60\n    },\n    attrs: {\n      \".outer\": {\n        fill: \"#2ECC71\",\n        stroke: \"#27AE60\",\n        \"stroke-width\": 2,\n        points: \"100,0 100,60 0,60 0,0\"\n      },\n      \".inner\": {\n        fill: \"#2ECC71\",\n        stroke: \"#27AE60\",\n        \"stroke-width\": 2,\n        points: \"95,5 95,55 5,55 5,5\",\n        display: \"none\"\n      },\n      text: {\n        text: \"Entity\",\n        \"font-family\": \"Arial\",\n        \"font-size\": 14,\n        \"ref-x\": .5,\n        \"ref-y\": .5,\n        \"y-alignment\": \"middle\",\n        \"text-anchor\": \"middle\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon class=\"outer\"/><polygon class=\"inner\"/></g><text/></g>'\n  }), joint.shapes.erd.Entity.define(\"erd.WeakEntity\", {\n    attrs: {\n      \".inner\": {\n        display: \"auto\"\n      },\n      text: {\n        text: \"Weak Entity\"\n      }\n    }\n  }), joint.dia.Element.define(\"erd.Relationship\", {\n    size: {\n      width: 80,\n      height: 80\n    },\n    attrs: {\n      \".outer\": {\n        fill: \"#3498DB\",\n        stroke: \"#2980B9\",\n        \"stroke-width\": 2,\n        points: \"40,0 80,40 40,80 0,40\"\n      },\n      \".inner\": {\n        fill: \"#3498DB\",\n        stroke: \"#2980B9\",\n        \"stroke-width\": 2,\n        points: \"40,5 75,40 40,75 5,40\",\n        display: \"none\"\n      },\n      text: {\n        text: \"Relationship\",\n        \"font-family\": \"Arial\",\n        \"font-size\": 12,\n        \"ref-x\": .5,\n        \"ref-y\": .5,\n        \"y-alignment\": \"middle\",\n        \"text-anchor\": \"middle\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon class=\"outer\"/><polygon class=\"inner\"/></g><text/></g>'\n  }), joint.shapes.erd.Relationship.define(\"erd.IdentifyingRelationship\", {\n    attrs: {\n      \".inner\": {\n        display: \"auto\"\n      },\n      text: {\n        text: \"Identifying\"\n      }\n    }\n  }), joint.dia.Element.define(\"erd.Attribute\", {\n    size: {\n      width: 100,\n      height: 50\n    },\n    attrs: {\n      ellipse: {\n        transform: \"translate(50, 25)\"\n      },\n      \".outer\": {\n        stroke: \"#D35400\",\n        \"stroke-width\": 2,\n        cx: 0,\n        cy: 0,\n        rx: 50,\n        ry: 25,\n        fill: \"#E67E22\"\n      },\n      \".inner\": {\n        stroke: \"#D35400\",\n        \"stroke-width\": 2,\n        cx: 0,\n        cy: 0,\n        rx: 45,\n        ry: 20,\n        fill: \"#E67E22\",\n        display: \"none\"\n      },\n      text: {\n        \"font-family\": \"Arial\",\n        \"font-size\": 14,\n        \"ref-x\": .5,\n        \"ref-y\": .5,\n        \"y-alignment\": \"middle\",\n        \"text-anchor\": \"middle\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><ellipse class=\"outer\"/><ellipse class=\"inner\"/></g><text/></g>'\n  }), joint.shapes.erd.Attribute.define(\"erd.Multivalued\", {\n    attrs: {\n      \".inner\": {\n        display: \"block\"\n      },\n      text: {\n        text: \"multivalued\"\n      }\n    }\n  }), joint.shapes.erd.Attribute.define(\"erd.Derived\", {\n    attrs: {\n      \".outer\": {\n        \"stroke-dasharray\": \"3,5\"\n      },\n      text: {\n        text: \"derived\"\n      }\n    }\n  }), joint.shapes.erd.Attribute.define(\"erd.Key\", {\n    attrs: {\n      ellipse: {\n        \"stroke-width\": 4\n      },\n      text: {\n        text: \"key\",\n        \"font-weight\": \"800\",\n        \"text-decoration\": \"underline\"\n      }\n    }\n  }), joint.shapes.erd.Attribute.define(\"erd.Normal\", {\n    attrs: {\n      text: {\n        text: \"Normal\"\n      }\n    }\n  }), joint.dia.Element.define(\"erd.ISA\", {\n    type: \"erd.ISA\",\n    size: {\n      width: 100,\n      height: 50\n    },\n    attrs: {\n      polygon: {\n        points: \"0,0 50,50 100,0\",\n        fill: \"#F1C40F\",\n        stroke: \"#F39C12\",\n        \"stroke-width\": 2\n      },\n      text: {\n        text: \"ISA\",\n        \"font-size\": 18,\n        \"ref-x\": .5,\n        \"ref-y\": .3,\n        \"y-alignment\": \"middle\",\n        \"text-anchor\": \"middle\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon/></g><text/></g>'\n  }), joint.dia.Link.define(\"erd.Line\", {}, {\n    cardinality: function cardinality(t) {\n      this.set(\"labels\", [{\n        position: -20,\n        attrs: {\n          text: {\n            dy: -8,\n            text: t\n          }\n        }\n      }]);\n    }\n  });\n  joint.shapes.basic.Circle.define(\"fsa.State\", {\n    attrs: {\n      circle: {\n        \"stroke-width\": 3\n      },\n      text: {\n        \"font-weight\": \"800\"\n      }\n    }\n  }), joint.dia.Element.define(\"fsa.StartState\", {\n    size: {\n      width: 20,\n      height: 20\n    },\n    attrs: {\n      circle: {\n        transform: \"translate(10, 10)\",\n        r: 10,\n        fill: \"#000000\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle/></g></g>'\n  }), joint.dia.Element.define(\"fsa.EndState\", {\n    size: {\n      width: 20,\n      height: 20\n    },\n    attrs: {\n      \".outer\": {\n        transform: \"translate(10, 10)\",\n        r: 10,\n        fill: \"#ffffff\",\n        stroke: \"#000000\"\n      },\n      \".inner\": {\n        transform: \"translate(10, 10)\",\n        r: 6,\n        fill: \"#000000\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle class=\"outer\"/><circle class=\"inner\"/></g></g>'\n  }), joint.dia.Link.define(\"fsa.Arrow\", {\n    attrs: {\n      \".marker-target\": {\n        d: \"M 10 0 L 0 5 L 10 10 z\"\n      }\n    },\n    smooth: !0\n  });\n  joint.dia.Element.define(\"org.Member\", {\n    size: {\n      width: 180,\n      height: 70\n    },\n    attrs: {\n      rect: {\n        width: 170,\n        height: 60\n      },\n      \".card\": {\n        fill: \"#FFFFFF\",\n        stroke: \"#000000\",\n        \"stroke-width\": 2,\n        \"pointer-events\": \"visiblePainted\",\n        rx: 10,\n        ry: 10\n      },\n      image: {\n        width: 48,\n        height: 48,\n        ref: \".card\",\n        \"ref-x\": 10,\n        \"ref-y\": 5\n      },\n      \".rank\": {\n        \"text-decoration\": \"underline\",\n        ref: \".card\",\n        \"ref-x\": .9,\n        \"ref-y\": .2,\n        \"font-family\": \"Courier New\",\n        \"font-size\": 14,\n        \"text-anchor\": \"end\"\n      },\n      \".name\": {\n        \"font-weight\": \"800\",\n        ref: \".card\",\n        \"ref-x\": .9,\n        \"ref-y\": .6,\n        \"font-family\": \"Courier New\",\n        \"font-size\": 14,\n        \"text-anchor\": \"end\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect class=\"card\"/><image/></g><text class=\"rank\"/><text class=\"name\"/></g>'\n  }), joint.dia.Link.define(\"org.Arrow\", {\n    source: {\n      selector: \".card\"\n    },\n    target: {\n      selector: \".card\"\n    },\n    attrs: {\n      \".connection\": {\n        stroke: \"#585858\",\n        \"stroke-width\": 3\n      }\n    },\n    z: -1\n  });\n  joint.shapes.basic.Generic.define(\"chess.KingWhite\", {\n    size: {\n      width: 42,\n      height: 38\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\"><path      d=\"M 22.5,11.63 L 22.5,6\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />    <path      d=\"M 20,8 L 25,8\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />    <path      d=\"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\"      style=\"fill:#ffffff; stroke:#000000; stroke-linecap:butt; stroke-linejoin:miter;\" />    <path      d=\"M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z \"      style=\"fill:#ffffff; stroke:#000000;\" />    <path      d=\"M 11.5,30 C 17,27 27,27 32.5,30\"      style=\"fill:none; stroke:#000000;\" />    <path      d=\"M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5\"      style=\"fill:none; stroke:#000000;\" />    <path      d=\"M 11.5,37 C 17,34 27,34 32.5,37\"      style=\"fill:none; stroke:#000000;\" />  </g></g></g>'\n  }), joint.shapes.basic.Generic.define(\"chess.KingBlack\", {\n    size: {\n      width: 42,\n      height: 38\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path       d=\"M 22.5,11.63 L 22.5,6\"       style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\"       id=\"path6570\" />    <path       d=\"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\"       style=\"fill:#000000;fill-opacity:1; stroke-linecap:butt; stroke-linejoin:miter;\" />    <path       d=\"M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z \"       style=\"fill:#000000; stroke:#000000;\" />    <path       d=\"M 20,8 L 25,8\"       style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />    <path       d=\"M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.51,26.6 L 22.5,24.5 C 20,18 9.906,14 6.997,19.85 C 4.5,25.5 11.85,28.85 11.85,28.85\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 11.5,30 C 17,27 27,27 32.5,30 M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5 M 11.5,37 C 17,34 27,34 32.5,37\"       style=\"fill:none; stroke:#ffffff;\" />  </g></g></g>'\n  }), joint.shapes.basic.Generic.define(\"chess.QueenWhite\", {\n    size: {\n      width: 42,\n      height: 38\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(-1,-1)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(15.5,-5.5)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(32,-1)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(7,-4.5)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(24,-4)\" />    <path      d=\"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38,14 L 31,25 L 31,11 L 25.5,24.5 L 22.5,9.5 L 19.5,24.5 L 14,10.5 L 14,25 L 7,14 L 9,26 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 11.5,30 C 15,29 30,29 33.5,30\"      style=\"fill:none;\" />    <path      d=\"M 12,33.5 C 18,32.5 27,32.5 33,33.5\"      style=\"fill:none;\" />  </g></g></g>'\n  }), joint.shapes.basic.Generic.define(\"chess.QueenBlack\", {\n    size: {\n      width: 42,\n      height: 38\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#000000; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <g style=\"fill:#000000; stroke:none;\">      <circle cx=\"6\"    cy=\"12\" r=\"2.75\" />      <circle cx=\"14\"   cy=\"9\"  r=\"2.75\" />      <circle cx=\"22.5\" cy=\"8\"  r=\"2.75\" />      <circle cx=\"31\"   cy=\"9\"  r=\"2.75\" />      <circle cx=\"39\"   cy=\"12\" r=\"2.75\" />    </g>    <path       d=\"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z\"       style=\"stroke-linecap:butt; stroke:#000000;\" />    <path       d=\"M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z\"       style=\"stroke-linecap:butt;\" />    <path       d=\"M 11,38.5 A 35,35 1 0 0 34,38.5\"       style=\"fill:none; stroke:#000000; stroke-linecap:butt;\" />    <path       d=\"M 11,29 A 35,35 1 0 1 34,29\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 12.5,31.5 L 32.5,31.5\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 11.5,34.5 A 35,35 1 0 0 33.5,34.5\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 10.5,37.5 A 35,35 1 0 0 34.5,37.5\"       style=\"fill:none; stroke:#ffffff;\" />  </g></g></g>'\n  }), joint.shapes.basic.Generic.define(\"chess.RookWhite\", {\n    size: {\n      width: 32,\n      height: 34\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14\"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 34,14 L 31,17 L 14,17 L 11,14\" />    <path      d=\"M 31,17 L 31,29.5 L 14,29.5 L 14,17\"      style=\"stroke-linecap:butt; stroke-linejoin:miter;\" />    <path      d=\"M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5\" />    <path      d=\"M 11,14 L 34,14\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />  </g></g></g>'\n  }), joint.shapes.basic.Generic.define(\"chess.RookBlack\", {\n    size: {\n      width: 32,\n      height: 34\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#000000; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z \"      style=\"stroke-linecap:butt;stroke-linejoin:miter;\" />    <path      d=\"M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12,35.5 L 33,35.5 L 33,35.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 13,31.5 L 32,31.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 14,29.5 L 31,29.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 14,16.5 L 31,16.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 11,14 L 34,14\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />  </g></g></g>'\n  }), joint.shapes.basic.Generic.define(\"chess.BishopWhite\", {\n    size: {\n      width: 38,\n      height: 38\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-rule:evenodd; fill-opacity:1; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:round; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <g style=\"fill:#ffffff; stroke:#000000; stroke-linecap:butt;\">       <path        d=\"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z\" />      <path        d=\"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\" />      <path        d=\"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\" />    </g>    <path      d=\"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />  </g></g></g>'\n  }), joint.shapes.basic.Generic.define(\"chess.BishopBlack\", {\n    size: {\n      width: 38,\n      height: 38\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-rule:evenodd; fill-opacity:1; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:round; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <g style=\"fill:#000000; stroke:#000000; stroke-linecap:butt;\">       <path        d=\"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z\" />      <path        d=\"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\" />      <path        d=\"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\" />    </g>    <path       d=\"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\"       style=\"fill:none; stroke:#ffffff; stroke-linejoin:miter;\" />  </g></g></g>'\n  }), joint.shapes.basic.Generic.define(\"chess.KnightWhite\", {\n    size: {\n      width: 38,\n      height: 37\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\"      style=\"fill:#ffffff; stroke:#000000;\" />    <path      d=\"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\"      style=\"fill:#ffffff; stroke:#000000;\" />    <path      d=\"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\"      style=\"fill:#000000; stroke:#000000;\" />    <path      d=\"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\"      transform=\"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\"      style=\"fill:#000000; stroke:#000000;\" />  </g></g></g>'\n  }), joint.shapes.basic.Generic.define(\"chess.KnightBlack\", {\n    size: {\n      width: 38,\n      height: 37\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\"      style=\"fill:#000000; stroke:#000000;\" />    <path      d=\"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\"      style=\"fill:#000000; stroke:#000000;\" />    <path      d=\"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\"      style=\"fill:#ffffff; stroke:#ffffff;\" />    <path      d=\"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\"      transform=\"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\"      style=\"fill:#ffffff; stroke:#ffffff;\" />    <path      d=\"M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z \"      style=\"fill:#ffffff; stroke:none;\" />  </g></g></g>'\n  }), joint.shapes.basic.Generic.define(\"chess.PawnWhite\", {\n    size: {\n      width: 28,\n      height: 33\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><path d=\"M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z \"  style=\"opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:nonzero; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\" /></g></g>'\n  }), joint.shapes.basic.Generic.define(\"chess.PawnBlack\", {\n    size: {\n      width: 28,\n      height: 33\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><path d=\"M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z \"  style=\"opacity:1; fill:#000000; fill-opacity:1; fill-rule:nonzero; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\" /></g></g>'\n  });\n  joint.shapes.basic.Generic.define(\"pn.Place\", {\n    size: {\n      width: 50,\n      height: 50\n    },\n    attrs: {\n      \".root\": {\n        r: 25,\n        fill: \"#ffffff\",\n        stroke: \"#000000\",\n        transform: \"translate(25, 25)\"\n      },\n      \".label\": {\n        \"text-anchor\": \"middle\",\n        \"ref-x\": .5,\n        \"ref-y\": -20,\n        ref: \".root\",\n        fill: \"#000000\",\n        \"font-size\": 12\n      },\n      \".tokens > circle\": {\n        fill: \"#000000\",\n        r: 5\n      },\n      \".tokens.one > circle\": {\n        transform: \"translate(25, 25)\"\n      },\n      \".tokens.two > circle:nth-child(1)\": {\n        transform: \"translate(19, 25)\"\n      },\n      \".tokens.two > circle:nth-child(2)\": {\n        transform: \"translate(31, 25)\"\n      },\n      \".tokens.three > circle:nth-child(1)\": {\n        transform: \"translate(18, 29)\"\n      },\n      \".tokens.three > circle:nth-child(2)\": {\n        transform: \"translate(25, 19)\"\n      },\n      \".tokens.three > circle:nth-child(3)\": {\n        transform: \"translate(32, 29)\"\n      },\n      \".tokens.alot > text\": {\n        transform: \"translate(25, 18)\",\n        \"text-anchor\": \"middle\",\n        fill: \"#000000\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle class=\"root\"/><g class=\"tokens\" /></g><text class=\"label\"/></g>'\n  }), joint.shapes.pn.PlaceView = joint.dia.ElementView.extend({\n    initialize: function initialize() {\n      joint.dia.ElementView.prototype.initialize.apply(this, arguments), this.model.on(\"change:tokens\", function () {\n        this.renderTokens(), this.update();\n      }, this);\n    },\n    render: function render() {\n      joint.dia.ElementView.prototype.render.apply(this, arguments), this.renderTokens(), this.update();\n    },\n    renderTokens: function renderTokens() {\n      var e = this.$(\".tokens\").empty();\n      e[0].className.baseVal = \"tokens\";\n      var t = this.model.get(\"tokens\");\n      if (t) switch (t) {\n        case 1:\n          e[0].className.baseVal += \" one\", e.append(V(\"<circle/>\").node);\n          break;\n\n        case 2:\n          e[0].className.baseVal += \" two\", e.append(V(\"<circle/>\").node, V(\"<circle/>\").node);\n          break;\n\n        case 3:\n          e[0].className.baseVal += \" three\", e.append(V(\"<circle/>\").node, V(\"<circle/>\").node, V(\"<circle/>\").node);\n          break;\n\n        default:\n          e[0].className.baseVal += \" alot\", e.append(V(\"<text/>\").text(t + \"\").node);\n      }\n    }\n  }), joint.shapes.basic.Generic.define(\"pn.Transition\", {\n    size: {\n      width: 12,\n      height: 50\n    },\n    attrs: {\n      rect: {\n        width: 12,\n        height: 50,\n        fill: \"#000000\",\n        stroke: \"#000000\"\n      },\n      \".label\": {\n        \"text-anchor\": \"middle\",\n        \"ref-x\": .5,\n        \"ref-y\": -20,\n        ref: \"rect\",\n        fill: \"#000000\",\n        \"font-size\": 12\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect class=\"root\"/></g></g><text class=\"label\"/>'\n  }), joint.dia.Link.define(\"pn.Link\", {\n    attrs: {\n      \".marker-target\": {\n        d: \"M 10 0 L 0 5 L 10 10 z\"\n      }\n    }\n  });\n  joint.shapes.basic.Generic.define(\"devs.Model\", {\n    inPorts: [],\n    outPorts: [],\n    size: {\n      width: 80,\n      height: 80\n    },\n    attrs: {\n      \".\": {\n        magnet: !1\n      },\n      \".label\": {\n        text: \"Model\",\n        \"ref-x\": .5,\n        \"ref-y\": 10,\n        \"font-size\": 18,\n        \"text-anchor\": \"middle\",\n        fill: \"#000\"\n      },\n      \".body\": {\n        \"ref-width\": \"100%\",\n        \"ref-height\": \"100%\",\n        stroke: \"#000\"\n      }\n    },\n    ports: {\n      groups: {\n        in: {\n          position: {\n            name: \"left\"\n          },\n          attrs: {\n            \".port-label\": {\n              fill: \"#000\"\n            },\n            \".port-body\": {\n              fill: \"#fff\",\n              stroke: \"#000\",\n              r: 10,\n              magnet: !0\n            }\n          },\n          label: {\n            position: {\n              name: \"left\",\n              args: {\n                y: 10\n              }\n            }\n          }\n        },\n        out: {\n          position: {\n            name: \"right\"\n          },\n          attrs: {\n            \".port-label\": {\n              fill: \"#000\"\n            },\n            \".port-body\": {\n              fill: \"#fff\",\n              stroke: \"#000\",\n              r: 10,\n              magnet: !0\n            }\n          },\n          label: {\n            position: {\n              name: \"right\",\n              args: {\n                y: 10\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><rect class=\"body\"/><text class=\"label\"/></g>',\n    portMarkup: '<circle class=\"port-body\"/>',\n    portLabelMarkup: '<text class=\"port-label\"/>',\n    initialize: function initialize() {\n      joint.shapes.basic.Generic.prototype.initialize.apply(this, arguments), this.on(\"change:inPorts change:outPorts\", this.updatePortItems, this), this.updatePortItems();\n    },\n    updatePortItems: function updatePortItems(t, e, o) {\n      var r = joint.util.uniq(this.get(\"inPorts\")),\n          i = joint.util.difference(joint.util.uniq(this.get(\"outPorts\")), r),\n          n = this.createPortItems(\"in\", r),\n          s = this.createPortItems(\"out\", i);\n      this.prop(\"ports/items\", n.concat(s), joint.util.assign({\n        rewrite: !0\n      }, o));\n    },\n    createPortItem: function createPortItem(t, e) {\n      return {\n        id: e,\n        group: t,\n        attrs: {\n          \".port-label\": {\n            text: e\n          }\n        }\n      };\n    },\n    createPortItems: function createPortItems(t, e) {\n      return joint.util.toArray(e).map(this.createPortItem.bind(this, t));\n    },\n    _addGroupPort: function _addGroupPort(t, e, o) {\n      var r = this.get(e);\n      return this.set(e, Array.isArray(r) ? r.concat(t) : [t], o);\n    },\n    addOutPort: function addOutPort(t, e) {\n      return this._addGroupPort(t, \"outPorts\", e);\n    },\n    addInPort: function addInPort(t, e) {\n      return this._addGroupPort(t, \"inPorts\", e);\n    },\n    _removeGroupPort: function _removeGroupPort(t, e, o) {\n      return this.set(e, joint.util.without(this.get(e), t), o);\n    },\n    removeOutPort: function removeOutPort(t, e) {\n      return this._removeGroupPort(t, \"outPorts\", e);\n    },\n    removeInPort: function removeInPort(t, e) {\n      return this._removeGroupPort(t, \"inPorts\", e);\n    },\n    _changeGroup: function _changeGroup(t, e, o) {\n      return this.prop(\"ports/groups/\" + t, joint.util.isObject(e) ? e : {}, o);\n    },\n    changeInGroup: function changeInGroup(t, e) {\n      return this._changeGroup(\"in\", t, e);\n    },\n    changeOutGroup: function changeOutGroup(t, e) {\n      return this._changeGroup(\"out\", t, e);\n    }\n  }), joint.shapes.devs.Model.define(\"devs.Atomic\", {\n    size: {\n      width: 80,\n      height: 80\n    },\n    attrs: {\n      \".label\": {\n        text: \"Atomic\"\n      }\n    }\n  }), joint.shapes.devs.Model.define(\"devs.Coupled\", {\n    size: {\n      width: 200,\n      height: 300\n    },\n    attrs: {\n      \".label\": {\n        text: \"Coupled\"\n      }\n    }\n  }), joint.dia.Link.define(\"devs.Link\", {\n    attrs: {\n      \".connection\": {\n        \"stroke-width\": 2\n      }\n    }\n  });\n  joint.shapes.basic.Generic.define(\"uml.Class\", {\n    attrs: {\n      rect: {\n        width: 200\n      },\n      \".uml-class-name-rect\": {\n        stroke: \"black\",\n        \"stroke-width\": 2,\n        fill: \"#3498db\"\n      },\n      \".uml-class-attrs-rect\": {\n        stroke: \"black\",\n        \"stroke-width\": 2,\n        fill: \"#2980b9\"\n      },\n      \".uml-class-methods-rect\": {\n        stroke: \"black\",\n        \"stroke-width\": 2,\n        fill: \"#2980b9\"\n      },\n      \".uml-class-name-text\": {\n        ref: \".uml-class-name-rect\",\n        \"ref-y\": .5,\n        \"ref-x\": .5,\n        \"text-anchor\": \"middle\",\n        \"y-alignment\": \"middle\",\n        \"font-weight\": \"bold\",\n        fill: \"black\",\n        \"font-size\": 12,\n        \"font-family\": \"Times New Roman\"\n      },\n      \".uml-class-attrs-text\": {\n        ref: \".uml-class-attrs-rect\",\n        \"ref-y\": 5,\n        \"ref-x\": 5,\n        fill: \"black\",\n        \"font-size\": 12,\n        \"font-family\": \"Times New Roman\"\n      },\n      \".uml-class-methods-text\": {\n        ref: \".uml-class-methods-rect\",\n        \"ref-y\": 5,\n        \"ref-x\": 5,\n        fill: \"black\",\n        \"font-size\": 12,\n        \"font-family\": \"Times New Roman\"\n      }\n    },\n    name: [],\n    attributes: [],\n    methods: []\n  }, {\n    markup: ['<g class=\"rotatable\">', '<g class=\"scalable\">', '<rect class=\"uml-class-name-rect\"/><rect class=\"uml-class-attrs-rect\"/><rect class=\"uml-class-methods-rect\"/>', \"</g>\", '<text class=\"uml-class-name-text\"/><text class=\"uml-class-attrs-text\"/><text class=\"uml-class-methods-text\"/>', \"</g>\"].join(\"\"),\n    initialize: function initialize() {\n      this.on(\"change:name change:attributes change:methods\", function () {\n        this.updateRectangles(), this.trigger(\"uml-update\");\n      }, this), this.updateRectangles(), joint.shapes.basic.Generic.prototype.initialize.apply(this, arguments);\n    },\n    getClassName: function getClassName() {\n      return this.get(\"name\");\n    },\n    updateRectangles: function updateRectangles() {\n      var a = this.get(\"attrs\"),\n          t = [{\n        type: \"name\",\n        text: this.getClassName()\n      }, {\n        type: \"attrs\",\n        text: this.get(\"attributes\")\n      }, {\n        type: \"methods\",\n        text: this.get(\"methods\")\n      }],\n          i = 0;\n      t.forEach(function (t) {\n        var e = Array.isArray(t.text) ? t.text : [t.text],\n            s = 20 * e.length + 20;\n        a[\".uml-class-\" + t.type + \"-text\"].text = e.join(\"\\n\"), a[\".uml-class-\" + t.type + \"-rect\"].height = s, a[\".uml-class-\" + t.type + \"-rect\"].transform = \"translate(0,\" + i + \")\", i += s;\n      });\n    }\n  }), joint.shapes.uml.ClassView = joint.dia.ElementView.extend({\n    initialize: function initialize() {\n      joint.dia.ElementView.prototype.initialize.apply(this, arguments), this.listenTo(this.model, \"uml-update\", function () {\n        this.update(), this.resize();\n      });\n    }\n  }), joint.shapes.uml.Class.define(\"uml.Abstract\", {\n    attrs: {\n      \".uml-class-name-rect\": {\n        fill: \"#e74c3c\"\n      },\n      \".uml-class-attrs-rect\": {\n        fill: \"#c0392b\"\n      },\n      \".uml-class-methods-rect\": {\n        fill: \"#c0392b\"\n      }\n    }\n  }, {\n    getClassName: function getClassName() {\n      return [\"<<Abstract>>\", this.get(\"name\")];\n    }\n  }), joint.shapes.uml.AbstractView = joint.shapes.uml.ClassView, joint.shapes.uml.Class.define(\"uml.Interface\", {\n    attrs: {\n      \".uml-class-name-rect\": {\n        fill: \"#f1c40f\"\n      },\n      \".uml-class-attrs-rect\": {\n        fill: \"#f39c12\"\n      },\n      \".uml-class-methods-rect\": {\n        fill: \"#f39c12\"\n      }\n    }\n  }, {\n    getClassName: function getClassName() {\n      return [\"<<Interface>>\", this.get(\"name\")];\n    }\n  }), joint.shapes.uml.InterfaceView = joint.shapes.uml.ClassView, joint.dia.Link.define(\"uml.Generalization\", {\n    attrs: {\n      \".marker-target\": {\n        d: \"M 20 0 L 0 10 L 20 20 z\",\n        fill: \"white\"\n      }\n    }\n  }), joint.dia.Link.define(\"uml.Implementation\", {\n    attrs: {\n      \".marker-target\": {\n        d: \"M 20 0 L 0 10 L 20 20 z\",\n        fill: \"white\"\n      },\n      \".connection\": {\n        \"stroke-dasharray\": \"3,3\"\n      }\n    }\n  }), joint.dia.Link.define(\"uml.Aggregation\", {\n    attrs: {\n      \".marker-target\": {\n        d: \"M 40 10 L 20 20 L 0 10 L 20 0 z\",\n        fill: \"white\"\n      }\n    }\n  }), joint.dia.Link.define(\"uml.Composition\", {\n    attrs: {\n      \".marker-target\": {\n        d: \"M 40 10 L 20 20 L 0 10 L 20 0 z\",\n        fill: \"black\"\n      }\n    }\n  }), joint.dia.Link.define(\"uml.Association\"), joint.shapes.basic.Generic.define(\"uml.State\", {\n    attrs: {\n      \".uml-state-body\": {\n        width: 200,\n        height: 200,\n        rx: 10,\n        ry: 10,\n        fill: \"#ecf0f1\",\n        stroke: \"#bdc3c7\",\n        \"stroke-width\": 3\n      },\n      \".uml-state-separator\": {\n        stroke: \"#bdc3c7\",\n        \"stroke-width\": 2\n      },\n      \".uml-state-name\": {\n        ref: \".uml-state-body\",\n        \"ref-x\": .5,\n        \"ref-y\": 5,\n        \"text-anchor\": \"middle\",\n        fill: \"#000000\",\n        \"font-family\": \"Courier New\",\n        \"font-size\": 14\n      },\n      \".uml-state-events\": {\n        ref: \".uml-state-separator\",\n        \"ref-x\": 5,\n        \"ref-y\": 5,\n        fill: \"#000000\",\n        \"font-family\": \"Courier New\",\n        \"font-size\": 14\n      }\n    },\n    name: \"State\",\n    events: []\n  }, {\n    markup: ['<g class=\"rotatable\">', '<g class=\"scalable\">', '<rect class=\"uml-state-body\"/>', \"</g>\", '<path class=\"uml-state-separator\"/>', '<text class=\"uml-state-name\"/>', '<text class=\"uml-state-events\"/>', \"</g>\"].join(\"\"),\n    initialize: function initialize() {\n      this.on({\n        \"change:name\": this.updateName,\n        \"change:events\": this.updateEvents,\n        \"change:size\": this.updatePath\n      }, this), this.updateName(), this.updateEvents(), this.updatePath(), joint.shapes.basic.Generic.prototype.initialize.apply(this, arguments);\n    },\n    updateName: function updateName() {\n      this.attr(\".uml-state-name/text\", this.get(\"name\"));\n    },\n    updateEvents: function updateEvents() {\n      this.attr(\".uml-state-events/text\", this.get(\"events\").join(\"\\n\"));\n    },\n    updatePath: function updatePath() {\n      var t = \"M 0 20 L \" + this.get(\"size\").width + \" 20\";\n      this.attr(\".uml-state-separator/d\", t, {\n        silent: !0\n      });\n    }\n  }), joint.shapes.basic.Circle.define(\"uml.StartState\", {\n    type: \"uml.StartState\",\n    attrs: {\n      circle: {\n        fill: \"#34495e\",\n        stroke: \"#2c3e50\",\n        \"stroke-width\": 2,\n        rx: 1\n      }\n    }\n  }), joint.shapes.basic.Generic.define(\"uml.EndState\", {\n    size: {\n      width: 20,\n      height: 20\n    },\n    attrs: {\n      \"circle.outer\": {\n        transform: \"translate(10, 10)\",\n        r: 10,\n        fill: \"#ffffff\",\n        stroke: \"#2c3e50\"\n      },\n      \"circle.inner\": {\n        transform: \"translate(10, 10)\",\n        r: 6,\n        fill: \"#34495e\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle class=\"outer\"/><circle class=\"inner\"/></g></g>'\n  }), joint.dia.Link.define(\"uml.Transition\", {\n    attrs: {\n      \".marker-target\": {\n        d: \"M 10 0 L 0 5 L 10 10 z\",\n        fill: \"#34495e\",\n        stroke: \"#2c3e50\"\n      },\n      \".connection\": {\n        stroke: \"#2c3e50\"\n      }\n    }\n  });\n  joint.shapes.basic.Generic.define(\"logic.Gate\", {\n    size: {\n      width: 80,\n      height: 40\n    },\n    attrs: {\n      \".\": {\n        magnet: !1\n      },\n      \".body\": {\n        width: 100,\n        height: 50\n      },\n      circle: {\n        r: 7,\n        stroke: \"black\",\n        fill: \"transparent\",\n        \"stroke-width\": 2\n      }\n    }\n  }, {\n    operation: function operation() {\n      return !0;\n    }\n  }), joint.shapes.logic.Gate.define(\"logic.IO\", {\n    size: {\n      width: 60,\n      height: 30\n    },\n    attrs: {\n      \".body\": {\n        fill: \"white\",\n        stroke: \"black\",\n        \"stroke-width\": 2\n      },\n      \".wire\": {\n        ref: \".body\",\n        \"ref-y\": .5,\n        stroke: \"black\"\n      },\n      text: {\n        fill: \"black\",\n        ref: \".body\",\n        \"ref-x\": .5,\n        \"ref-y\": .5,\n        \"y-alignment\": \"middle\",\n        \"text-anchor\": \"middle\",\n        \"font-weight\": \"bold\",\n        \"font-variant\": \"small-caps\",\n        \"text-transform\": \"capitalize\",\n        \"font-size\": \"14px\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect class=\"body\"/></g><path class=\"wire\"/><circle/><text/></g>'\n  }), joint.shapes.logic.IO.define(\"logic.Input\", {\n    attrs: {\n      \".wire\": {\n        \"ref-dx\": 0,\n        d: \"M 0 0 L 23 0\"\n      },\n      circle: {\n        ref: \".body\",\n        \"ref-dx\": 30,\n        \"ref-y\": .5,\n        magnet: !0,\n        class: \"output\",\n        port: \"out\"\n      },\n      text: {\n        text: \"input\"\n      }\n    }\n  }), joint.shapes.logic.IO.define(\"logic.Output\", {\n    attrs: {\n      \".wire\": {\n        \"ref-x\": 0,\n        d: \"M 0 0 L -23 0\"\n      },\n      circle: {\n        ref: \".body\",\n        \"ref-x\": -30,\n        \"ref-y\": .5,\n        magnet: \"passive\",\n        class: \"input\",\n        port: \"in\"\n      },\n      text: {\n        text: \"output\"\n      }\n    }\n  }), joint.shapes.logic.Gate.define(\"logic.Gate11\", {\n    attrs: {\n      \".input\": {\n        ref: \".body\",\n        \"ref-x\": -2,\n        \"ref-y\": .5,\n        magnet: \"passive\",\n        port: \"in\"\n      },\n      \".output\": {\n        ref: \".body\",\n        \"ref-dx\": 2,\n        \"ref-y\": .5,\n        magnet: !0,\n        port: \"out\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><image class=\"body\"/></g><circle class=\"input\"/><circle class=\"output\"/></g>'\n  }), joint.shapes.logic.Gate.define(\"logic.Gate21\", {\n    attrs: {\n      \".input1\": {\n        ref: \".body\",\n        \"ref-x\": -2,\n        \"ref-y\": .3,\n        magnet: \"passive\",\n        port: \"in1\"\n      },\n      \".input2\": {\n        ref: \".body\",\n        \"ref-x\": -2,\n        \"ref-y\": .7,\n        magnet: \"passive\",\n        port: \"in2\"\n      },\n      \".output\": {\n        ref: \".body\",\n        \"ref-dx\": 2,\n        \"ref-y\": .5,\n        magnet: !0,\n        port: \"out\"\n      }\n    }\n  }, {\n    markup: '<g class=\"rotatable\"><g class=\"scalable\"><image class=\"body\"/></g><circle class=\"input input1\"/><circle  class=\"input input2\"/><circle class=\"output\"/></g>'\n  }), joint.shapes.logic.Gate11.define(\"logic.Repeater\", {\n    attrs: {\n      image: {\n        \"xlink:href\": \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzIuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICA8L2c+Cjwvc3ZnPgo=\"\n      }\n    }\n  }, {\n    operation: function operation(I) {\n      return I;\n    }\n  }), joint.shapes.logic.Gate11.define(\"logic.Not\", {\n    attrs: {\n      image: {\n        \"xlink:href\": \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzkuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDI2NzEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzYiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA4MCwyNSBBIDQsNCAwIDEgMSA3MiwyNSBBIDQsNCAwIDEgMSA4MCwyNSB6IgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEsMCkiIC8+CiAgPC9nPgo8L3N2Zz4K\"\n      }\n    }\n  }, {\n    operation: function operation(I) {\n      return !I;\n    }\n  }), joint.shapes.logic.Gate21.define(\"logic.Or\", {\n    attrs: {\n      image: {\n        \"xlink:href\": \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik9SIEFOU0kuc3ZnIgogICBpbmtzY2FwZTpvdXRwdXRfZXh0ZW5zaW9uPSJvcmcuaW5rc2NhcGUub3V0cHV0LnN2Zy5pbmtzY2FwZSI+CiAgPGRlZnMKICAgICBpZD0iZGVmczQiPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTAgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjcxNCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iMSA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMC41IDogMC4zMzMzMzMzMyA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODA2IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODE5IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjM3Mi4wNDcyNCA6IDM1MC43ODczOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI3NDQuMDk0NDggOiA1MjYuMTgxMDkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzc3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49Ijc1IDogNDAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTUwIDogNjAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDYwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTMyNzUiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNTAgOiAzMy4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTAwIDogNTAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTU1MzMiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzIgOiAyMS4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNjQgOiAzMiA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMzIgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjU1NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDE2LjY2NjY2NyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDI1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAyNSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iNCIKICAgICBpbmtzY2FwZTpjeD0iMTEzLjAwMDM5IgogICAgIGlua3NjYXBlOmN5PSIxMi44OTM3MzEiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9InB4IgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImcyNTYwIgogICAgIHNob3dncmlkPSJmYWxzZSIKICAgICBpbmtzY2FwZTpncmlkLWJib3g9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1wb2ludHM9InRydWUiCiAgICAgZ3JpZHRvbGVyYW5jZT0iMTAwMDAiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxMzk5IgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9Ijg3NCIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iMzciCiAgICAgaW5rc2NhcGU6d2luZG93LXk9Ii00IgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNzAsMjUgYyAyMCwwIDI1LDAgMjUsMCIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMSwxNSA1LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzIsMzUgNSwzNSIKICAgICAgIGlkPSJwYXRoMzk0NCIgLz4KICAgIDxnCiAgICAgICBpZD0iZzI1NjAiCiAgICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI2LjUsLTM5LjUpIj4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICA8L2c+Cjwvc3ZnPgo=\"\n      }\n    }\n  }, {\n    operation: function operation(I, g) {\n      return I || g;\n    }\n  }), joint.shapes.logic.Gate21.define(\"logic.And\", {\n    attrs: {\n      image: {\n        \"xlink:href\": \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IkFORCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI4IgogICAgIGlua3NjYXBlOmN4PSI1Ni42OTgzNDgiCiAgICAgaW5rc2NhcGU6Y3k9IjI1LjMyNjg5OSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZvbnQtc2l6ZTptZWRpdW07Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zdHJldGNoOm5vcm1hbDt0ZXh0LWluZGVudDowO3RleHQtYWxpZ246c3RhcnQ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7bGluZS1oZWlnaHQ6bm9ybWFsO2xldHRlci1zcGFjaW5nOm5vcm1hbDt3b3JkLXNwYWNpbmc6bm9ybWFsO3RleHQtdHJhbnNmb3JtOm5vbmU7ZGlyZWN0aW9uOmx0cjtibG9jay1wcm9ncmVzc2lvbjp0Yjt3cml0aW5nLW1vZGU6bHItdGI7dGV4dC1hbmNob3I6c3RhcnQ7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDozO21hcmtlcjpub25lO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGU7Zm9udC1mYW1pbHk6Qml0c3RyZWFtIFZlcmEgU2FuczstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkJpdHN0cmVhbSBWZXJhIFNhbnMiCiAgICAgICBkPSJNIDMwLDUgTCAzMCw2LjQyODU3MTQgTCAzMCw0My41NzE0MjkgTCAzMCw0NSBMIDMxLjQyODU3MSw0NSBMIDUwLjQ3NjE5LDQ1IEMgNjEuNzQ0MDk4LDQ1IDcwLjQ3NjE5LDM1Ljk5OTk1NSA3MC40NzYxOSwyNSBDIDcwLjQ3NjE5LDE0LjAwMDA0NSA2MS43NDQwOTksNS4wMDAwMDAyIDUwLjQ3NjE5LDUgQyA1MC40NzYxOSw1IDUwLjQ3NjE5LDUgMzEuNDI4NTcxLDUgTCAzMCw1IHogTSAzMi44NTcxNDMsNy44NTcxNDI5IEMgNDAuODM0MjY0LDcuODU3MTQyOSA0NS45MTgzNjgsNy44NTcxNDI5IDQ4LjA5NTIzOCw3Ljg1NzE0MjkgQyA0OS4yODU3MTQsNy44NTcxNDI5IDQ5Ljg4MDk1Miw3Ljg1NzE0MjkgNTAuMTc4NTcxLDcuODU3MTQyOSBDIDUwLjMyNzM4MSw3Ljg1NzE0MjkgNTAuNDA5MjI3LDcuODU3MTQyOSA1MC40NDY0MjksNy44NTcxNDI5IEMgNTAuNDY1MDI5LDcuODU3MTQyOSA1MC40NzE1NDMsNy44NTcxNDI5IDUwLjQ3NjE5LDcuODU3MTQyOSBDIDYwLjIzNjg1Myw3Ljg1NzE0MyA2Ny4xNDI4NTcsMTUuNDk3MDk4IDY3LjE0Mjg1NywyNSBDIDY3LjE0Mjg1NywzNC41MDI5MDIgNTkuNzYwNjYyLDQyLjE0Mjg1NyA1MCw0Mi4xNDI4NTcgTCAzMi44NTcxNDMsNDIuMTQyODU3IEwgMzIuODU3MTQzLDcuODU3MTQyOSB6IgogICAgICAgaWQ9InBhdGgyODg0IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2NjY2NzY2NjY3Nzc3NzY2NjIiAvPgogIDwvZz4KPC9zdmc+Cg==\"\n      }\n    }\n  }, {\n    operation: function operation(I, g) {\n      return I && g;\n    }\n  }), joint.shapes.logic.Gate21.define(\"logic.Nor\", {\n    attrs: {\n      image: {\n        \"xlink:href\": \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjEiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjY3NzY0NCIKICAgICBpbmtzY2FwZTpjeT0iMjIuMTAyMzQ0IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjM3IgogICAgIGlua3NjYXBlOndpbmRvdy15PSItNCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc5LDI1IEMgOTksMjUgOTUsMjUgOTUsMjUiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHNvZGlwb2RpOnR5cGU9ImFyYyIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgICBpZD0icGF0aDI2MDQiCiAgICAgICAgIHNvZGlwb2RpOmN4PSI3NSIKICAgICAgICAgc29kaXBvZGk6Y3k9IjI1IgogICAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgICAgc29kaXBvZGk6cnk9IjQiCiAgICAgICAgIGQ9Ik0gNzksMjUgQSA0LDQgMCAxIDEgNzEsMjUgQSA0LDQgMCAxIDEgNzksMjUgeiIKICAgICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTI2LjUsMzkuNSkiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K\"\n      }\n    }\n  }, {\n    operation: function operation(I, g) {\n      return !(I || g);\n    }\n  }), joint.shapes.logic.Gate21.define(\"logic.Nand\", {\n    attrs: {\n      image: {\n        \"xlink:href\": \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5BTkQgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iMTYiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjI4MzMwNyIKICAgICBpbmtzY2FwZTpjeT0iMTYuNDQyODQzIgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzksMjUgQyA5MS44LDI1IDk1LDI1IDk1LDI1IgogICAgICAgaWQ9InBhdGgzMDU5IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMxLDE1IDUsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMiwzNSA1LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmb250LXNpemU6bWVkaXVtO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1pbmRlbnQ6MDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO2xpbmUtaGVpZ2h0Om5vcm1hbDtsZXR0ZXItc3BhY2luZzpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lO2RpcmVjdGlvbjpsdHI7YmxvY2stcHJvZ3Jlc3Npb246dGI7d3JpdGluZy1tb2RlOmxyLXRiO3RleHQtYW5jaG9yOnN0YXJ0O2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MzttYXJrZXI6bm9uZTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlO2ZvbnQtZmFtaWx5OkJpdHN0cmVhbSBWZXJhIFNhbnM7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpCaXRzdHJlYW0gVmVyYSBTYW5zIgogICAgICAgZD0iTSAzMCw1IEwgMzAsNi40Mjg1NzE0IEwgMzAsNDMuNTcxNDI5IEwgMzAsNDUgTCAzMS40Mjg1NzEsNDUgTCA1MC40NzYxOSw0NSBDIDYxLjc0NDA5OCw0NSA3MC40NzYxOSwzNS45OTk5NTUgNzAuNDc2MTksMjUgQyA3MC40NzYxOSwxNC4wMDAwNDUgNjEuNzQ0MDk5LDUuMDAwMDAwMiA1MC40NzYxOSw1IEMgNTAuNDc2MTksNSA1MC40NzYxOSw1IDMxLjQyODU3MSw1IEwgMzAsNSB6IE0gMzIuODU3MTQzLDcuODU3MTQyOSBDIDQwLjgzNDI2NCw3Ljg1NzE0MjkgNDUuOTE4MzY4LDcuODU3MTQyOSA0OC4wOTUyMzgsNy44NTcxNDI5IEMgNDkuMjg1NzE0LDcuODU3MTQyOSA0OS44ODA5NTIsNy44NTcxNDI5IDUwLjE3ODU3MSw3Ljg1NzE0MjkgQyA1MC4zMjczODEsNy44NTcxNDI5IDUwLjQwOTIyNyw3Ljg1NzE0MjkgNTAuNDQ2NDI5LDcuODU3MTQyOSBDIDUwLjQ2NTAyOSw3Ljg1NzE0MjkgNTAuNDcxNTQzLDcuODU3MTQyOSA1MC40NzYxOSw3Ljg1NzE0MjkgQyA2MC4yMzY4NTMsNy44NTcxNDMgNjcuMTQyODU3LDE1LjQ5NzA5OCA2Ny4xNDI4NTcsMjUgQyA2Ny4xNDI4NTcsMzQuNTAyOTAyIDU5Ljc2MDY2Miw0Mi4xNDI4NTcgNTAsNDIuMTQyODU3IEwgMzIuODU3MTQzLDQyLjE0Mjg1NyBMIDMyLjg1NzE0Myw3Ljg1NzE0MjkgeiIKICAgICAgIGlkPSJwYXRoMjg4NCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2Njc2NjY2Nzc3Nzc2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDQwMDgiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg==\"\n      }\n    }\n  }, {\n    operation: function operation(I, g) {\n      return !(I && g);\n    }\n  }), joint.shapes.logic.Gate21.define(\"logic.Xor\", {\n    attrs: {\n      image: {\n        \"xlink:href\": \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhPUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjUuNjU2ODU0MiIKICAgICBpbmtzY2FwZTpjeD0iMjUuOTM4MTE2IgogICAgIGlua3NjYXBlOmN5PSIxNy4yMzAwNSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzAuMzg1NzE3LDE1IEwgNC45OTk5OTk4LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5NzY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEuMzYyMDkxLDM1IEwgNC45OTk5OTk4LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPGcKICAgICAgIGlkPSJnMjU2MCIKICAgICAgIGlua3NjYXBlOmxhYmVsPSJMYXllciAxIgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjYuNSwtMzkuNSkiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDM1MTYiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi4yNSw4MS41MDAwMDUgQyAtMy44NDczNzQsODQuMTQ0NDA1IC00LjUsODQuNTAwMDA1IC00LjUsODQuNTAwMDA1IEwgLTguMTU2MjUsODQuNTAwMDA1IEwgLTYuMTU2MjUsODIuMDYyNTA1IEMgLTYuMTU2MjUsODIuMDYyNTA1IC0wLjUsNzUuMDYyNDUxIC0wLjUsNjQuNSBDIC0wLjUsNTMuOTM3NTQ5IC02LjE1NjI1LDQ2LjkzNzUgLTYuMTU2MjUsNDYuOTM3NSBMIC04LjE1NjI1LDQ0LjUgTCAtNC41LDQ0LjUgQyAtMy43MTg3NSw0NS40Mzc1IC0zLjA3ODEyNSw0Ni4xNTYyNSAtMi4yODEyNSw0Ny41IEMgLTAuNDA4NTMxLDUwLjU5OTgxNSAyLjUsNTYuNTI2NjQ2IDIuNSw2NC41IEMgMi41LDcyLjQ1MDY1IC0wLjM5NjY5Nyw3OC4zNzk0MjUgLTIuMjUsODEuNTAwMDA1IHoiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY3NjY2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K\"\n      }\n    }\n  }, {\n    operation: function operation(I, g) {\n      return (!I || g) && (I || !g);\n    }\n  }), joint.shapes.logic.Gate21.define(\"logic.Xnor\", {\n    attrs: {\n      image: {\n        \"xlink:href\": \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhOT1IgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNTU3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTYuNjY2NjY3IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDI1IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI0IgogICAgIGlua3NjYXBlOmN4PSI5NS43MjM2NiIKICAgICBpbmtzY2FwZTpjeT0iLTI2Ljc3NTAyMyIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjAwMDAwMDI0O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc4LjMzMzMzMiwyNSBDIDkxLjY2NjY2NiwyNSA5NSwyNSA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMC4zODU3MTcsMTUgTCA0Ljk5OTk5OTgsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk3NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMS4zNjIwOTEsMzUgTCA0Ljk5OTk5OTgsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoMzUxNiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjI1LDgxLjUwMDAwNSBDIC0zLjg0NzM3NCw4NC4xNDQ0MDUgLTQuNSw4NC41MDAwMDUgLTQuNSw4NC41MDAwMDUgTCAtOC4xNTYyNSw4NC41MDAwMDUgTCAtNi4xNTYyNSw4Mi4wNjI1MDUgQyAtNi4xNTYyNSw4Mi4wNjI1MDUgLTAuNSw3NS4wNjI0NTEgLTAuNSw2NC41IEMgLTAuNSw1My45Mzc1NDkgLTYuMTU2MjUsNDYuOTM3NSAtNi4xNTYyNSw0Ni45Mzc1IEwgLTguMTU2MjUsNDQuNSBMIC00LjUsNDQuNSBDIC0zLjcxODc1LDQ1LjQzNzUgLTMuMDc4MTI1LDQ2LjE1NjI1IC0yLjI4MTI1LDQ3LjUgQyAtMC40MDg1MzEsNTAuNTk5ODE1IDIuNSw1Ni41MjY2NDYgMi41LDY0LjUgQyAyLjUsNzIuNDUwNjUgLTAuMzk2Njk3LDc4LjM3OTQyNSAtMi4yNSw4MS41MDAwMDUgeiIKICAgICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2Njc2NjY2NzYyIgLz4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDM1NTEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg==\"\n      }\n    }\n  }, {\n    operation: function operation(I, g) {\n      return (!I || !g) && (I || g);\n    }\n  }), joint.dia.Link.define(\"logic.Wire\", {\n    attrs: {\n      \".connection\": {\n        \"stroke-width\": 2\n      },\n      \".marker-vertex\": {\n        r: 7\n      }\n    },\n    router: {\n      name: \"orthogonal\"\n    },\n    connector: {\n      name: \"rounded\",\n      args: {\n        radius: 10\n      }\n    }\n  }, {\n    arrowheadMarkup: ['<g class=\"marker-arrowhead-group marker-arrowhead-group-<%= end %>\">', '<circle class=\"marker-arrowhead\" end=\"<%= end %>\" r=\"7\"/>', \"</g>\"].join(\"\"),\n    vertexMarkup: ['<g class=\"marker-vertex-group\" transform=\"translate(<%= x %>, <%= y %>)\">', '<circle class=\"marker-vertex\" idx=\"<%= idx %>\" r=\"10\" />', '<g class=\"marker-vertex-remove-group\">', '<path class=\"marker-vertex-remove-area\" idx=\"<%= idx %>\" d=\"M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z\" transform=\"translate(5, -33)\"/>', '<path class=\"marker-vertex-remove\" idx=\"<%= idx %>\" transform=\"scale(.8) translate(9.5, -37)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\">', \"<title>Remove vertex.</title>\", \"</path>\", \"</g>\", \"</g>\"].join(\"\")\n  });\n  if (\"object\" == typeof exports) var graphlib = require(\"graphlib\"),\n      dagre = require(\"dagre\");\n  graphlib = graphlib || \"undefined\" != typeof window && window.graphlib, dagre = dagre || \"undefined\" != typeof window && window.dagre, joint.layout.DirectedGraph = {\n    exportElement: function exportElement(e) {\n      return e.size();\n    },\n    exportLink: function exportLink(e) {\n      var t = e.get(\"labelSize\") || {};\n      return {\n        minLen: e.get(\"minLen\") || 1,\n        weight: e.get(\"weight\") || 1,\n        labelpos: e.get(\"labelPosition\") || \"c\",\n        labeloffset: e.get(\"labelOffset\") || 0,\n        width: t.width || 0,\n        height: t.height || 0\n      };\n    },\n    importElement: function importElement(e, t, i) {\n      var n = this.getCell(t),\n          r = i.node(t);\n      e.setPosition ? e.setPosition(n, r) : n.set(\"position\", {\n        x: r.x - r.width / 2,\n        y: r.y - r.height / 2\n      });\n    },\n    importLink: function importLink(e, t, i) {\n      var n = this.getCell(t.name),\n          r = i.edge(t),\n          o = r.points || [];\n\n      if ((e.setVertices || e.setLinkVertices) && (joint.util.isFunction(e.setVertices) ? e.setVertices(n, o) : n.set(\"vertices\", o.slice(1, o.length - 1))), e.setLabels && \"x\" in r && \"y\" in r) {\n        var a = {\n          x: r.x,\n          y: r.y\n        };\n        if (joint.util.isFunction(e.setLabels)) e.setLabels(n, a, o);else {\n          var s = g.Polyline(o),\n              l = s.closestPointLength(a),\n              d = s.pointAtLength(l),\n              p = l / s.length();\n          n.label(0, {\n            position: {\n              distance: p,\n              offset: g.Point(a).difference(d).toJSON()\n            }\n          });\n        }\n      }\n    },\n    layout: function layout(e, t) {\n      var i;\n      i = e instanceof joint.dia.Graph ? e : new joint.dia.Graph().resetCells(e, {\n        dry: !0,\n        sort: !1\n      }), e = null, t = joint.util.defaults(t || {}, {\n        resizeClusters: !0,\n        clusterPadding: 10,\n        exportElement: this.exportElement,\n        exportLink: this.exportLink\n      });\n      var n = i.toGraphLib({\n        directed: !0,\n        multigraph: !0,\n        compound: !0,\n        setNodeLabel: t.exportElement,\n        setEdgeLabel: t.exportLink,\n        setEdgeName: function setEdgeName(e) {\n          return e.id;\n        }\n      }),\n          r = {},\n          o = t.marginX || 0,\n          a = t.marginY || 0;\n\n      if (t.rankDir && (r.rankdir = t.rankDir), t.align && (r.align = t.align), t.nodeSep && (r.nodesep = t.nodeSep), t.edgeSep && (r.edgesep = t.edgeSep), t.rankSep && (r.ranksep = t.rankSep), t.ranker && (r.ranker = t.ranker), o && (r.marginx = o), a && (r.marginy = a), n.setGraph(r), dagre.layout(n, {\n        debugTiming: !!t.debugTiming\n      }), i.startBatch(\"layout\"), i.fromGraphLib(n, {\n        importNode: this.importElement.bind(i, t),\n        importEdge: this.importLink.bind(i, t)\n      }), t.resizeClusters) {\n        var s = n.nodes().filter(function (e) {\n          return 0 < n.children(e).length;\n        }).map(i.getCell.bind(i)).sort(function (e, t) {\n          return t.getAncestors().length - e.getAncestors().length;\n        });\n        joint.util.invoke(s, \"fitEmbeds\", {\n          padding: t.clusterPadding\n        });\n      }\n\n      i.stopBatch(\"layout\");\n      var l = n.graph();\n      return g.Rect(o, a, Math.abs(l.width - 2 * o), Math.abs(l.height - 2 * a));\n    },\n    fromGraphLib: function fromGraphLib(t, i) {\n      var n = (i = i || {}).importNode || joint.util.noop,\n          r = i.importEdge || joint.util.noop,\n          o = this instanceof joint.dia.Graph ? this : new joint.dia.Graph();\n      return t.nodes().forEach(function (e) {\n        n.call(o, e, t, o, i);\n      }), t.edges().forEach(function (e) {\n        r.call(o, e, t, o, i);\n      }), o;\n    },\n    toGraphLib: function toGraphLib(e, t) {\n      t = t || {};\n\n      for (var i = joint.util.pick(t, \"directed\", \"compound\", \"multigraph\"), n = new graphlib.Graph(i), r = t.setNodeLabel || joint.util.noop, o = t.setEdgeLabel || joint.util.noop, a = t.setEdgeName || joint.util.noop, s = e.get(\"cells\"), l = 0, d = s.length; l < d; l++) {\n        var p = s.at(l);\n\n        if (p.isLink()) {\n          var g = p.get(\"source\"),\n              h = p.get(\"target\");\n          if (!g.id || !h.id) break;\n          n.setEdge(g.id, h.id, o(p), a(p));\n        } else if (n.setNode(p.id, r(p)), n.isCompound() && p.has(\"parent\")) {\n          var u = p.get(\"parent\");\n          s.has(u) && n.setParent(p.id, u);\n        }\n      }\n\n      return n;\n    }\n  }, joint.dia.Graph.prototype.toGraphLib = function (e) {\n    return joint.layout.DirectedGraph.toGraphLib(this, e);\n  }, joint.dia.Graph.prototype.fromGraphLib = function (e, t) {\n    return joint.layout.DirectedGraph.fromGraphLib.call(this, e, t);\n  };\n  joint.g = g;\n  joint.V = joint.Vectorizer = V;\n  return joint;\n});","map":null,"metadata":{},"sourceType":"script"}